<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry-jian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-05T14:45:03.308Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>li jian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="http://yoursite.com/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2020-03-05T14:40:31.000Z</published>
    <updated>2020-03-05T14:45:03.308Z</updated>
    
    <content type="html"><![CDATA[<p>1.系统信息<br>    arch 显示机器的处理器架构(1)<br>    uname -m 显示机器的处理器架构(2)<br>    uname -r 显示正在使用的内核版本<br>    dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>    hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>    hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>    cat /proc/cpuinfo 显示CPU info的信息<br>    cat /proc/interrupts 显示中断<br>    cat /proc/meminfo 校验内存使用<br>    cat /proc/swaps 显示哪些swap被使用<br>    cat /proc/version 显示内核的版本<br>    cat /proc/net/dev 显示网络适配器及统计<br>    cat /proc/mounts 显示已加载的文件系统<br>    lspci -tv 罗列 PCI 设备<br>    lsusb -tv 显示 USB 设备<br>    date 显示系统日期<br>    cal 2007 显示2007年的日历表<br>    date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>    clock -w 将时间修改保存到 BIOS </p><p>2.关机 (系统的关机、重启以及登出 )<br>    shutdown -h now 关闭系统(1)<br>    init 0 关闭系统(2)<br>    telinit 0 关闭系统(3)<br>    shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>    shutdown -c 取消按预定时间关闭系统<br>    shutdown -r now 重启(1)<br>    reboot 重启(2)<br>    logout 注销 </p><p>3.文件和目录<br>    cd /home 进入 ‘/ home’ 目录’<br>    cd .. 返回上一级目录<br>    cd ../.. 返回上两级目录<br>    cd 进入个人的主目录<br>    cd ~user1 进入个人的主目录<br>    cd - 返回上次所在的目录<br>    pwd 显示工作路径<br>    ls 查看目录中的文件<br>    ls -F 查看目录中的文件<br>    ls -l 显示文件和目录的详细资料<br>    ls -a 显示隐藏文件<br>    ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>    tree 显示文件和目录由根目录开始的树形结构(1)<br>    lstree 显示文件和目录由根目录开始的树形结构(2)<br>    mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>    mkdir dir1 dir2 同时创建两个目录<br>    mkdir -p /tmp/dir1/dir2 创建一个目录树<br>    rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>    rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>    rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>    rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>    mv dir1 new_dir 重命名/移动 一个目录<br>    cp file1 file2 复制一个文件<br>    cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>    cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>    cp -a dir1 dir2 复制一个目录<br>    ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>    ln file1 lnk1 创建一个指向文件或目录的物理链接<br>    touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>    file file1 outputs the mime type of the file as text<br>    iconv -l 列出已知的编码<br>    iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>    find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><p>4.文件搜索<br>     find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>    find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>    find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>    find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>    find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>    find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>    find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>    locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>    whereis halt 显示一个二进制文件、源码或man的位置<br>    which halt 显示一个二进制文件或可执行文件的完整路径 </p><p>5.挂载一个文件系统<br>    mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>    umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>    fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>    umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>    mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>    mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>    mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>    mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>    mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>    mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>    mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>    mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><p>6.磁盘空间<br>    df -h 显示已经挂载的分区列表<br>    ls -lSr |more 以尺寸大小排列文件和目录<br>    du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>    du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>    rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>    dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><p>7.用户和群组<br>    groupadd group_name 创建一个新用户组<br>    groupdel group_name 删除一个用户组<br>    groupmod -n new_group_name old_group_name 重命名一个用户组<br>    useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>    useradd user1 创建一个新用户<br>    userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>    usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>    passwd 修改口令<br>    passwd user1 修改一个用户的口令 (只允许root执行)<br>    chage -E 2005-12-31 user1 设置用户口令的失效期限<br>    pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>    grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>    newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><p>8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消<br>    ls -lh 显示权限<br>    ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>    chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>    chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>    chown user1 file1 改变一个文件的所有人属性<br>    chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>    chgrp group1 file1 改变文件的群组<br>    chown user1:group1 file1 改变一个文件的所有人和群组属性<br>    find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>    chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>    chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>    chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>    chmod g-s /home/public 禁用一个目录的 SGID 位<br>    chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>    chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><ol start="9"><li>chattr +a file1 只允许以追加方式读写文件<br> chattr +c file1 允许这个文件能被内核自动压缩/解压<br> chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br> chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br> chattr +s file1 允许一个文件被安全地删除<br> chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br> chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br> lsattr 显示特殊的属性 </li></ol><p>10.打包和压缩文件<br>    bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>    bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>    gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>    gzip file1 压缩一个叫做 ‘file1’的文件<br>    gzip -9 file1 最大程度压缩<br>    rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>    rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>    rar x file1.rar 解压rar包<br>    unrar x file1.rar 解压rar包<br>    tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>    tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>    tar -tf archive.tar 显示一个包中的内容<br>    tar -xvf archive.tar 释放一个包<br>    tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>    tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>    tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>    tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>    tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>    zip file1.zip file1 创建一个zip格式的压缩包<br>    zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>    unzip file1.zip 解压一个zip格式压缩包 </p><p>11.RPM 包 - （Fedora, Redhat及类似系统）<br>     rpm -ivh package.rpm 安装一个rpm包<br>    rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>    rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>    rpm -F package.rpm 更新一个确定已经安装的rpm包<br>    rpm -e package_name.rpm 删除一个rpm包<br>    rpm -qa 显示系统中所有已经安装的rpm包<br>    rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>    rpm -qi package_name 获取一个已安装包的特殊信息<br>    rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>    rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>    rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>    rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>    rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>    rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>    rpm -q package_name –changelog 显示一个rpm包的修改历史<br>    rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>    rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>    rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>    rpm –checksig package.rpm 确认一个rpm包的完整性<br>    rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>    rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>    rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>    rpm -Vp package.rpm 确认一个rpm包还未安装<br>    rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>    rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>    rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><p>12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）<br>    yum install package_name 下载并安装一个rpm包<br>    yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>    yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>    yum update package_name 更新一个rpm包<br>    yum remove package_name 删除一个rpm包<br>    yum list 列出当前系统中安装的所有包<br>    yum search package_name 在rpm仓库中搜寻软件包<br>    yum clean packages 清理rpm缓存删除下载的包<br>    yum clean headers 删除所有头文件<br>    yum clean all 删除所有缓存的包和头文件 </p><p>13.DEB 包 (Debian, Ubuntu 以及类似系统)<br>    dpkg -i package.deb 安装/更新一个 deb 包<br>    dpkg -r package_name 从系统删除一个 deb 包<br>    dpkg -l 显示系统中所有已经安装的 deb 包<br>    dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>    dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>    dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>    dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>    dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p><p>14.APT 软件工具 (Debian, Ubuntu 以及类似系统)<br>    apt-get install package_name 安装/更新一个 deb 包<br>    apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>    apt-get update 升级列表中的软件包<br>    apt-get upgrade 升级所有已安装的软件<br>    apt-get remove package_name 从系统删除一个deb包<br>    apt-get check 确认依赖的软件仓库正确<br>    apt-get clean 从下载的软件包中清理缓存<br>    apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><p>15.查看文件内容<br>    cat file1 从第一个字节开始正向查看文件的内容<br>    tac file1 从最后一行开始反向查看一个文件的内容<br>    more file1 查看一个长文件的内容<br>    less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>    head -2 file1 查看一个文件的前两行<br>    tail -2 file1 查看一个文件的最后两行<br>    tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p><p>16.文本处理<br>    cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>    cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>    cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>    grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>    grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>    grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>    grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>    sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>    sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>    sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>    echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>    sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>    sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>    sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>    sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>    sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>    sed -n ‘5p;5q’ example.txt 查看第5行<br>    sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>    cat -n file1 标示文件的行数<br>    cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>    echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>    echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>    paste file1 file2 合并两个文件或两栏的内容<br>    paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>    sort file1 file2 排序两个文件的内容<br>    sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>    sort file1 file2 | uniq -u 删除交集，留下其他的行<br>    sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>    comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>    comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>    comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p><p>17.字符设置和文件格式转换<br>    dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>    unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>    recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>    recode -l | more 显示所有允许的转换格式 </p><p>18.文件系统分析<br>    badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>    fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>    fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>    e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>    e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>    fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>    fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>    fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>    dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p><p>19.初始化一个文件系统<br>    mkfs /dev/hda1 在hda1分区创建一个文件系统<br>    mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>    mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>    mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>    fdformat -n /dev/fd0 格式化一个软盘<br>    mkswap /dev/hda3 创建一个swap文件系统 </p><p>20.SWAP文件系统<br>    mkswap /dev/hda3 创建一个swap文件系统<br>    swapon /dev/hda3 启用一个新的swap文件系统<br>    swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p><p>21.备份<br>    dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>    dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>    restore -if /tmp/home0.bak 还原一个交互式备份<br>    rsync -rogpav –delete /home /tmp 同步两边的目录<br>    rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>    rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>    rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>    dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>    dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>    tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>    ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>    ( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>    tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>    find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>    find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>    dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>    dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p><p>22.光盘<br>    cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>    mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>    mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>    mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>    cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>    gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>    mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>    cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>    cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>    cdrecord –scanbus 扫描总线以识别scsi通道<br>    dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><p>23.网络 - （以太网和WIFI无线）<br>     ifconfig eth0 显示一个以太网卡的配置<br>    ifup eth0 启用一个 ‘eth0’ 网络设备<br>    ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>    ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>    ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>    dhclient eth0 以dhcp模式启用 ‘eth0’<br>    route -n show routing table<br>    route add -net 0/0 gw IP_Gateway configura default gateway<br>    route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>    route del 0/0 gw IP_gateway remove static route<br>    echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>    hostname show hostname of system<br>    host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(1)<br>    nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(2)<br>    ip link show show link status of all interfaces<br>    mii-tool eth0 show link status of ‘eth0’<br>    ethtool eth0 show statistics of network card ‘eth0’<br>    netstat -tup show all active network connections and their PID<br>    netstat -tupl show all network services listening on the system and their PID<br>    tcpdump tcp port 80 show all HTTP traffic<br>    iwlist scan show wireless networks<br>    iwconfig eth1 show configuration of a wireless network card<br>    hostname show hostname<br>    host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>    nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>    whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.系统信息&lt;br&gt;    arch 显示机器的处理器架构(1)&lt;br&gt;    uname -m 显示机器的处理器架构(2)&lt;br&gt;    uname -r 显示正在使用的内核版本&lt;br&gt;    dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux高级</title>
    <link href="http://yoursite.com/2020/03/05/linux%E9%AB%98%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/03/05/linux%E9%AB%98%E7%BA%A7/</id>
    <published>2020-03-05T02:28:55.000Z</published>
    <updated>2020-03-05T02:28:55.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="http://yoursite.com/2020/03/04/linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/04/linux%E5%9F%BA%E7%A1%80/</id>
    <published>2020-03-04T13:07:16.000Z</published>
    <updated>2020-03-04T14:58:04.540Z</updated>
    
    <content type="html"><![CDATA[<p>1.查看虚拟机的编码：<br>    locale<br>    echo $LANG<br>2. echo：是查看后面的内容<br>    [root@localhost ~]# echo people<br>    people</p><hr><ol start="3"><li>$ : 表示某个变量的值<br> [root@localhost ~]# shuaige=lijian<br> [root@localhost ~]# echo $shuaige<br> lijian</li></ol><hr><h2 id="4-pwd-查看当前在那个路径"><a href="#4-pwd-查看当前在那个路径" class="headerlink" title="4.pwd: 查看当前在那个路径"></a>4.pwd: 查看当前在那个路径</h2><p>5.快照：创建一个linux系统好的状态，一旦系统出了问题的时候，可以恢复到当时创建快照时好的系统状态<br>  挂起： 将虚拟机暂停在某个时间点</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.查看虚拟机的编码：&lt;br&gt;    locale&lt;br&gt;    echo $LANG&lt;br&gt;2. echo：是查看后面的内容&lt;br&gt;    [root@localhost ~]# echo people&lt;br&gt;    people&lt;/p&gt;
&lt;hr&gt;
&lt;ol start=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python笔录</title>
    <link href="http://yoursite.com/2020/02/15/python%E7%AC%94%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/15/python%E7%AC%94%E5%BD%95/</id>
    <published>2020-02-15T08:54:55.732Z</published>
    <updated>2020-02-26T14:56:47.635Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: python笔录<br>date: 2020-02-15 16:54:55<br>tags:</p><hr><p>1.做列表类的题目心得：(踩过好多坑)<br>    len() 函数的用法： 例子  num1 = [1,2,3]<br>                            print(len(num1))  =&gt;  3<br>    对于range()函数循环取值后：(包前不包后)<br>                            for i in range(len(num1)):<br>                                print(i)  =&gt;    0,1,2<br>    可迭代对象是指 可以使用for语句进行循环取值的对象：<br>            list tuple dict set  str    可迭代对象之间是可以相互转化的  list(str)</p><hr><p>2.列表推导式：推导式 就是把  list  dict set  之间进行转换  没有元组推导式<br>基本格式：variable = [‘out_exp_res’ for out_exp in input list if ‘out_exp == 2]<br>        out_exp_res: 列表生成元素表达式  或则反回值<br>        for put_exp in input_list  迭代input_list 将out_exp 传入 out_exp_res<br>        if out_exp == 2            根据条件过滤哪些值<br>    例子： 将字符串变成列表  条件 只将大写输出：<br>            mystr = ‘abcABC’<br>            mylist = [item for item in mystr if item.isupper()]<br>            print(mylist)                                       =&gt;[‘A’, ‘B’, ‘C’]<br>3.字典推导式：（集合推导式  就只需要需要key）<br>基本格式：variable = {out_key:out_value for out_key,out_value in input if out_exp==2}</p><hr><p>4.可迭代对象的判断：<br>    from collections.abc import Iterable<br>         isinstance(a,Iterable) =&gt; Ture<br>    或者取dir 查看这个对象是否具有 <strong>iter</strong>这个对象</p><hr><ol start="5"><li>迭代器：<br> 迭代器是有状态的，可以被next()调用，函数调用并不断返回下一个值的对象=&gt;迭代器<br> x = [1,2,3]<br> y = iter(x)   =&gt;   y = x.<strong>iter</strong>() 可以在可迭代对象中相互转换<br> print(next(y)) =&gt; 1      next表示一次取出迭代器里面的元素一次取一个元素<pre><code>当取完了就不能再取了  就会报错StopIteration</code></pre>for 后面要接可迭代对象的原因： 可迭代对象 =&gt; 生成一个迭代器 =&gt; 里面有Next方法 依次取值<br>迭代器的特点：  迭代器是有next方法的<pre><code>迭代器的数据不是立即生成的  当用户显示或隐式方法调用__next__()才会才会成数据 迭代器中只存放了下一个数据的计算方法</code></pre>迭代器的使用情景： 1. 数据量很大  2. 按顺序取值</li></ol><hr><ol start="6"><li><p>迭代器生成一个无限序列：</p><pre><code>from itertools import count#生成一个无限大的序列，从start开始counter = count(start = 10)print(counter, type(counter))print(next(counter))  =&gt; 无限取值</code></pre><p>迭代器从一个有限序列中生成一个无限序列：</p><pre><code>   from itertools import cycleimport  timeweek = cycle([1,2,3,4,5,6,7,8,9])for i in week:    print(i)    time.sleep(1)</code></pre></li></ol><hr><p>7.可迭代对象与迭代器的区别：</p><h1 id="取值：-index-key-随机取值-只能通过next方法进行向下取值"><a href="#取值：-index-key-随机取值-只能通过next方法进行向下取值" class="headerlink" title="取值：  index/key 随机取值                    只能通过next方法进行向下取值"></a>取值：  index/key 随机取值                    只能通过next方法进行向下取值</h1><h1 id="存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）"><a href="#存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）" class="headerlink" title="存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）"></a>存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）</h1><h1 id="迭代器的好处：-在瞬时间-占用的内存少-计算量小"><a href="#迭代器的好处：-在瞬时间-占用的内存少-计算量小" class="headerlink" title="迭代器的好处：  在瞬时间 占用的内存少  计算量小"></a>迭代器的好处：  在瞬时间 占用的内存少  计算量小</h1><hr><p>8.生成器：<br>    生成器是一种特殊的迭代器，它不需要手动编写<strong>iter</strong>() 和 <strong>next</strong>()方法，只需要一个<br>    yiled 关键字     （生成器一定是迭代器，反之不成立）<br>  生成器表达式：<br>       1.使用()生成generator(生成器) 将两表推到式的[]改为()即可得到生成器<br>           a = (x for x in range(10 ** 9))<br>       2.yield： 包含yield表达式的函数是特殊的函数，叫做生成器函数<br>                 被调用时将返回一个迭代器，调用时用next 或者 send(msg)<br>                 ~ 一个生成器中可以有多个yield<br>                 ~ 一旦遇到yield 就会保存当前状态 然后返回yield后面的值<br>                 例子： def max1(i)<br>                             yield i       yield执行后就会保存状态，下次从yield开始执行<br>                           print(manx(1))  =&gt;  生成一个生成器<br>                           print(next(max1))  =&gt;  依次取值<br>       3.send数据：<br>           用户可以使用send 来跟生成器进行交互  send的数据会输入到生成器yield的位置<br>       4.yield from:<br>           当我们想从一个生成器取到内部的数据的时候<br>  ~生成器的好处：<br>          可以用更少的中间变量写流式代码<br>          相比其他容器对象他能节省内存<br>          可以减少代码的使用</p><hr><p>9.关于查看程序执行时间的方法  时间戳<br>    import time<br>    #时间戳   从1970.1.1 0点0时0秒<br>    start = time.time()<br>    a = [x for x in range(10*9)]<br>    print(time.time()-start)</p><hr><ol start="10"><li>常见的编程范式：<ul><li>面向过程编程：根据操作数据的语句块来实现功能</li><li>面向对象编程：把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法</li><li>函数式编程： 如果一个函数可以接受函数作为参数，并且返回一个结果，这个函数为函数式编程</li></ul></li></ol><hr><ol start="11"><li>高阶函数： 一个函数中把另一个函数作为参数传入，这个参数为函数的函数为高阶函数</li></ol><ul><li><p>map函数：  map( 函数名[方法] , 可迭代对象 )   一一映射进行处理 返回值为迭代器<br>  例子：   def f(x):                        ret = map(lambda x:x*x,range(10))</p><pre><code>    return x*xret = map(f,range(10))print(list(ret))</code></pre></li><li><p>filter函数(过滤)： filter( 函数名[方法] , 可迭代对象 )  返回值为迭代器    </p><pre><code>filter把传入的函数依次作用于每个元素，然后根据返回值式Ture还是False决定保留还是丢弃 保留True</code></pre><p>  例子：    num1 = [1,2,3,4]</p><pre><code># 0=&gt;Fales   1=&gt;Tureret = filter(lambda x:x%2,num1)print(list(ret))</code></pre></li><li><p>sorted函数(排序)：  sort(可迭代对象，函数名[方法])<br>  例子： sorted([2,3,4,-1],key = abs)    返回值为list</p></li><li><p>reduce函数():把结果继续和序列的下一个元素做累加计算</p><pre><code>reduce(函数，可迭代对象)</code></pre><p>  例子：from functools import reduce</p><pre><code>reduce(lambda x,y:x*10+y,[1,3,7,5,9])    =&gt;13759</code></pre></li></ul><hr><ol start="12"><li><p>类(class):类里面的变量称为类属性(每个实例都可以使用)   类中函数里面的变量称为实例属性 </p><pre><code>      每个类中都有一个__init__ 方法(自动调用) 作用是来初始化类的 调用的时候直接：      solution = 类名(类对象)例子： class Soultion(object):        def __init__(self,age,name,sex):            self.age = age            self.name = name            self.sex = sex     solution = Soultion(age=10,name=&apos;lijian&apos;,sex=&apos;男&apos;)    print(solution.name)    print(solution.age)    print(solution.sex)</code></pre><p><strong>new</strong> 方法：  开始创建实例  def <strong>new</strong> (cls,* args, ** kwargs):</p><pre><code>                return object.__new__(cls)这样就会创建一个实例 后面的__init__方法就会初始化创建出来的实例</code></pre><p>注意： object 中包含了<strong>new</strong> <strong>init</strong> 这两个方法 一般不需要自行写入</p><pre><code>类和方法是可以动态添加属性和方法的    bus317.color = green  这样就给实例添加了一个属性Bus317.color = blue   这样就给类添加了一个属性一个实例有自己的属性的时候 先使用自己的 再使用公共的</code></pre></li></ol><hr><p>13.用类创建迭代器：<br>    利用菲不拉契数列例子：<br>        class Fib(object):<br>    def <strong>init</strong>(self):<br>        self.prev = 0<br>        self.current = 1</p><pre><code>def __next__(self):    self.prev,self.current = self.current,self.prev + self.current    return self.prev# 创建迭代器  只需要放回他自己就好def __iter__(self):    return selffib = Fib()print(fib.__next__())</code></pre><hr><h2 id="14-类-self-表示调用该方法的实例本身"><a href="#14-类-self-表示调用该方法的实例本身" class="headerlink" title="14.类-self: 表示调用该方法的实例本身"></a>14.类-self: 表示调用该方法的实例本身</h2><p>15.类的继承：<br>    在一个继承类中，如果父类有一个方法而子类也有一个相同的方法，在执行的时候子类会先用自己的方法，符合就近原则。但是子类没有该方法 就会自动的去查找父类和object中是否有该方法。如果<br>    都没有的话就会出现AttributeError这样的错误</p><pre><code>super().sports()      在子类于父类有同样的方法的时候，要求子类在调用该方法的时候先去父类调用该方法</code></pre><hr><p>16.装饰器(类方法)  @classmethod  在一个类里面定义只作用于这个类的方法<br>    @classmethod<br>    def add(cls):      cls是出现在那个类里面就表示哪个类<br>        cls.count += 1    </p><hr><p>17 定义一个异常类;  异常类都继承于 Exception<br>     #异常类的定义<br>    class ListLenghtError(Exception):<br>        pass</p><pre><code>li = list(range(8))if len(li) &gt;= 10:    raise ListLenghtErrorelse:    print(&quot;列表正确&quot;)</code></pre><hr><p>18.类的继承中的多态<br>    多态：多种状态，在面向对象语言中，接口的多种不同的实现方式<br>    python是一种多态语言，裳称鸭子类型</p><pre><code>def talk_with(self,obj):      obj:是子类中的某个类    obj.talk()               有了这个多态 就可以用现在处在的这个类直接调用别的类中的talk方法    父类名.某个子类中的方法()   就可实现调用</code></pre><hr><p>19.经典类与新式类：<br>    python2： 经典类是按照深度优先来继承的   新式类是按照C3算法来继承的<br>    python3： 同意按照C3算法来继承<br>            MRO: 方法解析顺序  解决当定义了多个同名的方法/属性的时候让用户找到正确的对象所实现的一种算法<br>            C3算法： * 子类会先于父类被检查<br>                     * 多个父类会根据他们在列表中的顺序被检查<br>                     * 如果对下一个类存在两个合法的选择，选择第一个父类<br>                     mro() :  可以直接退出C3 算法 </p><hr><p>20  * 实例方法： def <strong>init</strong>():    这个方法是给实例用的 一定要传递一个实例或者调用<br>    * 静态方法： @staticmethod<br>    * 类方法： @classmethod  cls表示类本身   在哪个类里面就表示哪个类  </p><pre><code>在方法中，没有使用实例信息，也没有使用类信息     @staticmethod 静态方法在方法中，没有使用实例信息，使用到了类信息       @classmathod  类方法在方法中，用到实例信息，没有使用到类信息         普通实例方法在方法中，用到实例信息和类信息                  实例方法+类方法例子：    class Tst(object):    #类属性(静态属性)    class_attribute = &apos;A&apos;    def __init__(self):        #实例属性        self.instance_attrubute = &apos;B&apos;    #实例方法    def instance_method(self):        print(&apos;这是一个实例方法&apos;)        print(self.instance_attrubute)        print(self.class_attribute)    # 类方法    =》 装饰器    #把classmethod下面的方法变为类方法    @classmethod    def class_method(cls):        print(&apos;这是个类方法&apos;)        #类方法只能调用类属性        print(cls.class_attribute)    #静态方法    @staticmethod    def static_method():        print(&apos;这是个静态方法&apos;)        print(Tst.class_attribute)    #用实例来调用实例方法    tst = Tst()    tst.instance_method()    #用类来调用类方法    Tst.class_method()    #用实例来调用方法    tst.class_method()    #用实例来调用静态方法    tst.static_method()    #用类来调用静态方法    Tst.static_method()</code></pre><hr><p>21.属性包装 ：@ property   将方法转化为属性来使用<br>        当生成一个包装后 python会自动生成 @类名.setter  @类名.delete 等包装<br>    例子：</p><pre><code>    class Person(object):def __init__(self,name,age):    self.name = name    self._age = age@propertydef age(self):    print(&apos;property_age&apos;)    return self._age# 这是用做修改的功能@age.setterdef age(self,value):      if 0&lt;value&lt;100:        self._age = value    else:        raise ValueError(&apos;超出范围&apos;)# 这是删除的功能@age.deleterdef age(self):    del self._agep1 =  Person(&apos;cali&apos;,19)#当作属性可以直接访问print(p1.age)p1.age = 10print(p1.age)</code></pre><hr><p>22.类中的下划线：   _age 表示是私有的     <strong>age 表示是强制不能使用的<br>                                       强行访问的方式  obj._classname</strong>foo<br>                                       obj 实例名   classname 类名</p><hr><ol start="23"><li>魔术方法：<ul><li><strong>new</strong> 创建实例:<br>  def <strong>new</strong>(cls,* args, ** kwargs):<pre><code>return upper().__new__(cls)</code></pre></li><li><strong>init</strong> 初始化实例：<br>  def <strong>init</strong>(self):<pre><code>return 初始化实例</code></pre></li><li><strong>del</strong> 删除方法：<br>  def <strong>del</strong>(self):<pre><code>return 删除方法   自动调用    </code></pre></li><li><strong>getitem</strong> 获取数据</li><li><strong>setitem</strong> 设置数据</li><li><strong>iter</strong>    可迭代</li><li><strong>eq</strong>(self,other)     符号 ==<pre><code>tst1.__eq__(txt2)    self.tst1 == other.tst2</code></pre></li><li><strong>ne</strong> (self,other)    !=</li><li><strong>it</strong> (self,other)    &lt;</li><li><strong>gt</strong> (self,other)    &lt;=</li><li><strong>add</strong>(self,other)    +</li><li><strong>mul</strong>(self,other)    *</li><li><strong>len</strong> (self)  长度</li><li><strong>str</strong> (self)  友好的输出实例信息=&gt;非正式</li><li><strong>repr</strong>(self)  友好的输出实例信息=&gt;正式  结果放在列表中</li><li><strong>dict</strong>(self)  类的属性</li><li><strong>doc</strong> (self)  类的文档</li><li><strong>name</strong>(self)  类名</li><li><strong>module</strong>(self)  类定义所在的模块</li><li><strong>bases</strong> (self)  类所有父类构成元素</li></ul></li></ol><hr><p>24.自省: 检查某些事务以确定他是什么 他是干什么的能做什么<br>         类似于：dir()    typle()<br>    自省的方法：<br>        * getattr(obj,’name’):获取成员<br>            getattr(实例名，属性值)<br>        * hasattr(obj,’name’):检查是否含有成员<br>            hasattr(实例名，属性值)<br>        * setattr(obj,’age’,value): 设置成员<br>            getattr(实例名，属性值,修改值)<br>        * delattr(obj,’name’):删除成员<br>            delattr(实例名，属性值)</p><hr><p>25.python元类：  元类就是用来创建类的类   类是由type创建的  type是默认的一个元类<br>    type创建类    type(类名，(object),{方法:函数})<br>        第一个参数： 是写出类名<br>        第二个参数： 继承自谁<br>        第三个参数： ‘方法名’:函数(方法)</p><hr><p>26.抽象基类：  from abc import ABCmeta,abstractmethod        metaclass = ABCMeta<br>            @abstractmethod  下面的函数可以在子类中出现了该方法就可以直接调用</p><hr><p>27.闭包：在函数中可以(嵌套)<br>    定义另外一个函数，如果内部函数引用了外部的函数变量，则可能产生闭包<br>    闭包可以用来在一个函数于一组“私有”变量之间创建关联关系<br>    在给定函数被多次调用的过程中，这些私有变量能够保持其持久性<br>闭包形成的条件：<br>    * 有一个内嵌的函数<br>    * 内部函数必须要引用外部函数的变量<br>    * 外部函数返回内部函数(函数名)<br>闭包的特点：闭合范围内的变量是有状态的 随着调用 会不断的更新     </p><p>例子：<br>    def func01():<br>    a = 1<br>    def func02():<br>        # 表示使用上一层函数的变量<br>        nonlocal a<br>        #从右往左计算 那么a就没有值<br>        a = a+1<br>        print(a)<br>    return func02()</p><hr><p>28.编写装饰器;（作用：给函数添加功能）<br>    编写装饰器的固定模板：</p><pre><code>import functoolsdef 装饰器名(func):    @functools.wraps(实例函数)    def _dec(*args,**kwargs)        你想添加的功能        result = func(*args,**kwargs)        你想添加的功能        return resultreturn _dec带参数的装饰器的模板：def permission_required(user):    def dec(func):        def _dec(*args,**kwargs):            # 你想添加的功能            result = func(*args,**kwargs)            # 你想添加的功能            return result        return _dec    return dec例子：import functools    def login_required(func):        @functools.wraps(func)   =》 是可以提示哪个函数被调用        def _dec(a,b,*args,** kwargs):            if name == &apos;root&apos;:                print(f&quot;{func.__name__}被调用&quot;)                return func(a,b,*args,** kwargs) =&gt;                                 可变长参数   不用管函数传入的参数什么样子            else:                print(&apos;有问题&apos;)                return False        return _dec    @login_required    def add(a,b,*args,** kwargs):        print(a+b)        return a+b    add(1,2,&apos;root&apos;)</code></pre><hr><p>29.用类来实现装饰器<br>    <strong>init</strong> 初始化类         <strong>call</strong>  传入参数的时候使用</p><p>例子：</p><pre><code>class logging(object):def __init__(self,func):    self.func = func# 当函数中有参数的时候  会调用__call__ 方法def __call__(self, *args, **kwargs):    reslut  =  self.func(*args,**kwargs)    print(f&apos;{self.func.__name__}被调用&apos;)    return reslut</code></pre><p>@logging<br>def add(a,b):<br>    return a+b<br>print(add(1,2))</p><hr><p> 30.上下文管理器： 上下文管理器是一个包装任意代码块的对象<br>     进入上下文管理器时，每次代码执行的一致性<br>     当退出上下文管理器时，相关的资源会被正确回收 即使内部代码出错，退出步骤也会执行<br>     上下文管理器用的最多的就是  作为确保资源正确清理的一种方式<br>     重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性</p><p> with语句： 仅仅能对上下文管理协议的对象使用<br>             with语句的作用是返回一个遵循特定协议的的对象，具体来说就是必须要定义一个<br>             <strong>enter</strong>方法和<strong>exit</strong>方法</p><p>with的工作原理：<br>    with open() as f:            with context_expras cm:<br>        # obj.<strong>enter</strong>()                dosomething<br>        f.read()<br>        # obj.<strong>exit</strong>()</p><ul><li>在进入代码块之前会执行obj.<strong>enter</strong>()语句（自动调用）</li><li>在退出代码块之前会执行obj.<strong>exit</strong>()语句（自动调用）</li></ul><p>编写上下文管理器：   重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性<br>例子：<br>    class A(object):<br>        def <strong>init</strong>(self):                                  =&gt;第一步<br>        pass<br>        def <strong>enter</strong>(self):                                =&gt;第二步<br>        pass<br>        def <strong>exit</strong>(self, exc_type, exc_val, exc_tb):        =&gt;第四步<br>        pass<br>    with A() as a:<br>        print(‘xxx’)                                        =&gt;第三步</p><hr><p>31.上下文自动管理模块： contextlib 可以用简单的方法创建上下文管理器(没弄懂)<br>    @cotextlib.contextmanage  这是一个上下文管理的装饰器</p><hr><h2 id="32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出"><a href="#32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出" class="headerlink" title="32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出"></a>32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出</h2><p>33.logging日志的记录:</p><pre><code>import logging#配置loging#level 记录等级比自己高的日志logging.basicConfig(level=logging.INFO,format=&apos;%(asctime)s-%(name)s-%(message)s&apos;)#创建日子记录器logger= logging.getLogger(&apos;cali_game&apos;)#记日志logging.debug(&quot;这是一个debug&quot;)logging.info(&quot;这是一个info&quot;)logging.warning(&quot;这是一个warning&quot;)logging.error(&quot;这是一个error&quot;)logging.critical(&quot;这是一个critical&quot;)try:    raise ValueError(&apos;value error&apos;)except Exception as ex:    logging.exception(ex)print(&quot;finished&quot;)</code></pre><p>将日志放入log文件中</p><pre><code>import logging#创建日志记录器logger = logging.getLogger(__name__)#为logger做日志配置logger.setLevel(level=logging.INFO)#把内容输出到文件中去filehander = logging.FileHandler(&apos;log.txt&apos;)filehander.setLevel(level=logging.DEBUG)formatter = logging.Formatter(&apos;%(asctime)s -%(name)s:[%(levelname)s]:%(message)s&apos;)filehander.setFormatter(formatter)#给日志记录器添加存储位置logger.addHandler(filehander)logging.debug(&quot;这是一个debug&quot;)logging.info(&quot;这是一个info&quot;) logging.warning(&quot;这是一个warning&quot;)logging.error(&quot;这是一个error&quot;)logging.critical(&quot;这是一个critical&quot;)</code></pre><hr><p>34.调试方式：asset断言<br>    assert expression ,(arguments)<br>    assert 表达式 参数                 直接报错退出</p><p>例子：<br>    score = input(“输入”)<br>    assert score.isdigit(),”输入的有问题”</p><hr><p>35.pdb 调试器<br>    可以直接使用启动调试器<br>        python -m pdb mypdb_base.py<br>    pdb 指令<br>        下一条语句  n next<br>        打印变量信息： p 变量名<br>        打印脚本信息： l<br>        退出pdb  q<br>        查看帮助  h</p><hr><p>36.列表中的数 自由排列  排列数列  从4个里面选出3个 排列<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p><hr><p>37.列表中的数自由组合<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p><hr><p>38.排列组合  生成密码<br>    import itertools<br>    mylist = list(itertools.product([1,2,3,4],repeat=3))<br>    print(mylist)<br>    print(len(mylist))</p><hr><p>39.正则表达式：<br>    re模块使python有了正则的功能 就是根据一种模式 来提取某些地方的数据</p><p>re.match函数：  match(pattern,string,flags = 0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>match.group: 返回匹配的字符串<br>match.start: 返回的是匹配的开始的位置<br>match.end:   返回的是匹配的结束的位置<br>match.groups:返回分组的全部内容 （””,””,,””）</p><p>功能：尝试从字符串的起始位置开始匹配的一个模式，如果不是起始位置匹配成功的话，返回None<br>例子：   import re<br>        print(re.match(‘www’,’wwW.baidu.com’,flags=re.I))  re.I :表示忽略大小写</p><!-- 结果：    <re.Match object; span=(0, 3), match='wwW'> --><p>re.search函数：  search(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串，会现显示前面的那段<br>      如果匹配不成功的话会返回None<br>例子：   import re<br>        print(re.search(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p><!-- 结果：<re.Match object; span=(7, 10), match='wwW'> --><p>re.findall函数：findall(pattern,string,flags=0)    <!-- (\)记得转义 --><br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个列表，<br>    如果没有则会返回None<br>例子：  import re<br>        print(re.findall(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p><!-- 结果：    ['wwW', 'wwW'] --><!-- ret = re.finditer(r'[a-c\-]at', message) -->  \的重要性  有特殊意义的都是需要转义<p>re.finditer函数： finditer(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>                 ?:i   是表示内联的标记<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个迭代器<br>    如果没有则会返回None<br>例子：   import re<br>        print(re.finditer(‘(lijian)’,’lijian a good man,lijian a handsome man’))<br>    <!-- 结果：<callable_iterator object at 0x0000024A9EC8ED30> --></p><hr><p>40.正则表达式：匹配单个字符和数字<br> .  匹配除换行符以外的任意字符<br>        例子：   import re<br>                print(re.search(‘.’,’lijian is a good man’))<br>        <!-- 结果：   <re.Match object; span=(0, 1), match='l'> --></p><p> [] 字符集合，表示匹配方括号中所包含的任意一个字符<br>    [a-z]: 匹配任意小写字母</p><!--      [A-Z]: 匹配任意大写字母         [0-9]: 匹配任意数字         [0-9a-zA-Z] : 匹配任意数字于字母         [^lijian]:匹配出了lijian这几个字符意外的所有字符  --><pre><code> ^: 脱字符 表示不匹配集合中的字符 取反 \d: 匹配所有的数字 效果同[0-9] \D:    匹配所有的非数字 效果同[^\d] \w: 匹配所有的数字 字母 下划线 \W: 匹配非数字 字母 下划线 \s: 匹配任意的空白符（空格，换行，回车，换页，制表）效果同：[ \f\n\r\t] \S: 匹配任非任意的空白符 [^ \f\n\r\t] 例子：  import re       print(re.search(&apos;[0-9]&apos;,&apos;lijian is a good man 2&apos;))&lt;!-- 结果：&lt;re.Match object; span=(21, 22), match=&apos;2&apos;&gt; --</code></pre><hr><p>41.正则表达式：匹配锚字符（边界字符）<br>  ^  行首匹配  筛选某个字符串开头的方式   每行的开头<br>                   import re<br>               print(re.search(‘^lijian’,’lijian is a good man 2’))<br>        <!-- 结果：<re.Match object; span=(0, 6), match='lijian'> --><br>  $  行尾匹配  筛选某个字符串结尾的方式    每行的结尾<br>                  import re<br>               print(re.search(‘2&amp;’,’lijian is a good man 2’))<br>         <!-- 结果：<re.Match object; span=(21, 22), match='2'> --><br>  \A  匹配字符串的开始     换行后的第一字符串也不行  就是整个字符串的开头<br>          re.M(换行模式)模式下不会匹配他的行首<br>                  import re<br>                print(re.findall(‘\Alijian’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘lijian’]<br>  \Z   匹配字符串的结束     换行后的最后一个字符串也不行  就是整个字符串的结尾<br>          re.M(换行模式)模式下不会匹配他的行尾<br>                  import re<br>                print(re.findall(‘manb\Z’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘manb’]<br>  \b   匹配以什么结尾的单词<br>                  import re<br>                  print(re.search(r’er\B’,’nerve’))  记得raw<br>              <!-- 结果： <re.Match object; span=(1, 3), match='er'> --><br>  \B   匹配中间含有什么的单词<br>                  import re<br>                  print(re.search(r’er\b’,’never’))   记得raw<br>              <!-- 结果：<re.Match object; span=(3, 5), match='er'> --></p><hr><p>42.正则表达式：匹配多个字符<br>    (x,y,x)   匹配括号里的xyz (把xyz看成一个整体)<br>                import re<br>                print(re.findall(‘(laugh)’,’never not to laugh myself’))<br>            <!-- 结果：<re.Match object; span=(13, 18), match='laugh'> --><br>    x？        匹配0个或者1个x  (就是将匹配的x一个一个显示出来)非贪婪匹配 尽可能少的匹配<br>                import re<br>                print(re.findall(‘x?’,’xxx’))<br>            <!-- 结果：['x', 'x', 'x', ''] --><br>    x*         匹配多个x   (就是将相邻的x合成一个字符串输出) 贪婪匹配 尽可能多的匹配<br>                import re<br>                print(re.findall (‘x*’, ‘xxx’))<br>            <!-- 结果：['xxx', ''] --><br>    x+         匹配至少一个x  (就是在有x的情况下 将相邻的x合成一个字符串输出)<br>                贪婪匹配 尽可能多的匹配</p><pre><code>            import re            print(re.findall(&apos;x+&apos;,&apos;xxxbxxxx&apos;))        &lt;!-- 结果：[&apos;xxx&apos;, &apos;xxxx&apos;] --&gt;x{n}        匹配确定含有n个x的字符串（n 是一个非负整数） 贪婪匹配 将相邻的n个x一起打印            import re            print(re.findall(&apos;x{4}&apos;,&apos;xxxbxxxx&apos;))        &lt;!-- 结果：[&apos;xxxx&apos;] --&gt;x{n,}        匹配至少含有n个x的字符串 （n 是一个非负整数）贪婪匹配 将相邻的n个x一起打印            import re            print(re.findall(&apos;x{4,}&apos;,&apos;xxxbxxxxxx&apos;))        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;x{n,m}   匹配至少含有n个最多m个x的字符串（n，m是一个非负整数）            贪婪匹配 将符合要求的相邻的n个x一起打印            import re            print(re.findall(&apos;x{4,6}&apos;,&apos;xxxbxxxxxx&apos;))        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;x|y      匹配含有x或者y的字符串               import re            print(re.findall(&apos;((x|y)aaa)&apos;,&apos;xaaa-yaaa&apos;))        &lt;!-- 结果：[(&apos;xaaa&apos;, &apos;x&apos;), (&apos;yaaa&apos;, &apos;y&apos;)] --&gt;</code></pre><hr><p>43.正则表达式-特殊匹配<br>    * ？    + ？    x ？<br>    最小匹配，通长是尽可能多的匹配，可以使用这种解决贪婪匹配</p><h2 id="x-类似-xyz-但是不表示一个组-？p-分组命名"><a href="#x-类似-xyz-但是不表示一个组-？p-分组命名" class="headerlink" title="   (?:x)  类似(xyz)  但是不表示一个组      ？p  分组命名"></a>   (?:x)  类似(xyz)  但是不表示一个组      ？p<name>  分组命名</h2><p>44.正则表达式-字符串的替换和修改<br> sub(pattern,repl,string,count=0,flags=0) =&gt; 打印的类型  str<br> subn(pattern,repl,sttring,count=0,flags=0) =&gt; 打印的类型 tuple<br> 例子：   sub<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.sub(‘good’,’nice’,str1))<br> <!--  结果：lijian a nice nice man --><br> 例子：   subn<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.subn(‘good’,’nice’,str1))<br> <!--  结果：('lijian a nice nice man', 2) --><br> pattern:正则表达式（规则）<br> repl : 指定的用来替换的字符串<br> string： 目标字符串<br> count：最多替换次数<br>功能：在目标字符串中按照匹配规则进行匹配字符串，然后在将字符串替换成指定的字符串，count可以指定替换的次数</p><hr><p>45.正则表达式-分组<br>    正则表达式除了简单的判断是否匹配之外，正则表达式还有提取子串的功能<br>    用（）表示的就是提取分组<br>    提取数据：  m.group(0)   最外层<br>               m.group(1)    依次往里取组</p><hr><p>46.正则表达式-编译   将正则表达式变成一个对象 对用户友好<br>    当我们使用正则表达式的时候 re模块<br>    1.编译正则表达式，如果正则表达式不和法，会报错<br>    2.用编译后的正则表达式去匹配对象<br>    compile(pattern,flags=0)<br>功能：将正则表达式进行封装 到时候去匹配的时候 如果是按照正则表示的规则来的就会输出 否则就会输出None   (最常用)</p><p>例子：<br>    import re<br>    re_QQ = re.compile(r’[1-9]\d{5,9}$’)<br>    print(re_QQ.search(‘1234568789’))</p><!-- 结果：<re.Match object; span=(0, 10), match='1234568789'> --><hr><p>47.踩坑记录：<br>    message = “a.jpg, a.gif, a.css, b.gif, b.css”<br>    ret = re.findall(r’[a-zA-Z0-9].(?:jpg|gif)’, message)   =》 ?: 表示不是一个组<br>    print(ret)   </p><hr><p>49.练习：<br>长度为8-10的用户名（以字母、下划线开头，由字母、数字、下划线组成）<br>    content = “””<br>    a<br>    1aaaaaaaa<br>    <em>a<br>    <em>1<br>    asdfasddf<br>    11<br>    ad_a<br>    asd+s<br>    abcdefghi<br>    1aaaaaa<em>a<br>    1aaaaaaa a<br>    aaa</em>aaa_aa<br>    1234562452<br>    a_______</em></em><br>    <strong><strong><strong>_____</strong></strong></strong><br>    “””<br>    # ^ 表示以什么开头    $ 表示以什么结尾  [字母或者下划线]   \w 字母 数字 下划线   {7,9}长度<br>    ret = re.findall(r”^[a-zA-Z_]\w{7,9}$”,content,re.M)<br>    print(ret)</p><p>电子邮箱验证(<!-- xxx1@xxx2.xxx3 -->，xxx1、xxx2由字母数字下划线组成，xxx1长度为6-18)</p><!--     mystr = """    a@163.com    aaaasdf@16.com    aaaasdf@16.net    asd*wwf@sdf.com    """ --><!-- ^ 表示以什么开头  \w字母 数字 下划线   +一个以上  \. 将点转义  (?:com|net)？:是不将括号看为分组 |或ret = re.findall(r"^\w{6,18}@\w+\.[a-z]+$",mystr,re.M)ret = re.findall(r"^\w{6,18}@\w+\.(?:com|net)$",mystr,re.M)print(mystr) --><!-- #  URL地址验证(http[s]://www.baidu.com[/?a=111&b=111], --><p>mystr = “””</p><!-- http://www.baidu.comhttp://baidu.comhttps://www.baidu.comhttps://t.cnhttps://www.baidu.com/?a=111&b=111 --><!-- """ret = re.findall(r"^http[s]?://\w+\.\w+\.(?:com|cn)",mystr,re.M)print(ret) --><!-- msg = """Feng Tel: 18392013983Feng Tel: 183 9201 3983Feng Tel: 183-9201-3983Feng Tel: (+86) 183 9201 3983Feng Tel: (+86) 18392013983Feng Tel: (+01)18392013983"""# (?:\(\+\d{2}\))? 一个整体是否存在(+86)   [ -]?空格和-中的一个  \d{3} 三个数字ret = re.findall(r"(?:\(\+\d{2}\)[ -]?)?\d{3}[ -]?\d{4}[ -]?\d{4}",msg,re.M)print(ret) --><hr><p>50.爬虫爬取网站照片：<br>    ### 总结 =&gt;<br>    ### 需求 =&gt; <a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a> =&gt; 图片保存当前目录的imgs目录下<br>    # 获取网页的内容<br>    import requests<br>    import os</p><pre><code>headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&quot;}response = requests.get(&quot;https://movie.douban.com/&quot;,                    headers=headers)# 添加headers的user-agent的目的是告诉douban，我不是一个脚本，我是Firefox浏览器html = response.text# 从html页面中获取所有的图片链接# &lt;img src=&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2581067467.jpg&quot;all_imgs_link = re.findall(r&apos;src=&quot;(.*?\.(jpg|png|gif|bmp|webp))&quot;&apos;, html)# 路径 。扩展名# print(all_imgs_link)# 将这些图片保存到当前目录的imgs目录下output_dir = &apos;./imgs&apos;if not os.path.exists(output_dir):    os.mkdir(output_dir)for i,pic_url in enumerate(all_imgs_link):    # 把图片存在本地 =&gt; 二进制文件 =&gt; content    #                            =&gt; text =&gt; content转化成str    img = requests.get(pic_url[0], headers=headers).content    # filepath = output_dir/i.pic_url[1]    filepath = f&quot;{output_dir}/{i}.{pic_url[1]}&quot;    print(filepath)    with open(filepath, &apos;wb&apos;) as f:        f.write(img)</code></pre><hr><p>51.断言：（存在问题）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: python笔录&lt;br&gt;date: 2020-02-15 16:54:55&lt;br&gt;tags:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.做列表类的题目心得：(踩过好多坑)&lt;br&gt;    len() 函数的用法： 例子  num1 = [1,2,3]&lt;br&gt;    
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>flask_jinja2</title>
    <link href="http://yoursite.com/2020/02/13/flask-jinja2/"/>
    <id>http://yoursite.com/2020/02/13/flask-jinja2/</id>
    <published>2020-02-13T14:29:13.000Z</published>
    <updated>2020-02-13T14:29:56.836Z</updated>
    
    <content type="html"><![CDATA[<pre><code>base.html 文件： &lt;!DOCTYPE html&gt;   &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;{% block title %}{% endblock %}</title>        <style>        .nav{            background: #3a3a3a;            height: 65px;        }        ul{            overflow: hidden;        }        ul li{            float: left;            list-style: none;            padding: 0 10px;            line-height: 65px;        }        ul li a{            color: white;        }    </style></head><body>    <div class="nav">    <ul>        <li><a href="#">首页</a></li>        <li><a href="#">发布问答</a></li>    </ul></div>{% block main %}{% endblock %}        &lt;/body&gt;        &lt;/html&gt;    login.html:        {% extends 'base.html' %}        {% block title %}    登陆页面{% endblock %}        {% block main %}    <p>这是登陆页面</p>{% endblock %}    index.html:        {% extends 'base.html' %}        {% block title %}    首页{% endblock %}        {% block main %}    <p>这是首页面</p>{% endblock %}6.URL链接和加载静态文件    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径    * 可以加载css文件，js文件 image文件    image文件：    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;    js文件：     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;    css文件：    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;*url链接：使用url_for(视图函数名)，从而反转url 跳转页面        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;url链接和加载静态文件的例子：    Py文件：        from flask import Flask,render_template        app = Flask(__name__)        @app.route(&apos;/&apos;)        def index():            return render_template(&apos;index.html&apos;)        @app.route(&apos;/login/&apos;)        def login():            return render_template(&apos;login.html&apos;)        if __name__ == &apos;__main__&apos;:            app.run(debug=True)    index.html文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;        &lt;/body&gt;        &lt;/html&gt;    index.js文件：        /**         * Created by 栩森 on 2020/2/4.         */        alert(&apos;我是李坚&apos;)    index.css文件：           a{                background: red;            }    login.html 文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;h1&gt;这是登陆页面&lt;/h1&gt;        &lt;/body&gt;        &lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;base.html 文件：

 &amp;lt;!DOCTYPE html&amp;gt;
   &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
        &amp;lt;head&amp;gt;
            &amp;lt;meta charset=&amp;quot
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask-jinja</title>
    <link href="http://yoursite.com/2020/02/09/Flask-jinja/"/>
    <id>http://yoursite.com/2020/02/09/Flask-jinja/</id>
    <published>2020-02-09T07:48:18.000Z</published>
    <updated>2020-02-09T11:29:53.255Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.如何渲染Jinja2模板和传参：(主要是 &apos;render_template&apos;函数)* 渲染模板：    * 模板放在 templates 文件夹下面    * 从 flask 中导入 render_template 函数    * 在视图函数中，使用 render_template    #注意：在templates文件夹下面没有其他文件夹的话可以直接render_template(文件名)* 模板传参数：    * 如果只有一个或则少量参数的时候，可以直接在render_template函数中添加关键字就好         #   return render_template(&apos;index.html&apos;,&apos;user&apos; = &apos;username&apos;)    * 如果有多个参数的时候就需要把参数放入一个字典中，然后在&apos;render_template&apos;中使用**    把字典中的参数传递    &apos;&apos;&apos;            @app.route(&apos;/&apos;)            def index():                context = {                    &apos;username&apos;:&apos;李坚&apos;,                    &apos;gender&apos;:&apos;男&apos;,                    &apos;age&apos;: 18                }                return render_template(&apos;index.html&apos;,**context)    &apos;&apos;&apos;* 在模板中，如果需要使用变量，语法是&apos;{{params}}&apos;                &lt;p&gt;用户名：&apos;{{ username }}&apos;&lt;/p&gt;        * 在访问类的属性或则是字典或则是列表的时候，可以通过&apos;{{params.proper}}&apos;的形式，或则是&apos;{{params[]}}&apos;                   &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;模板的渲染和传参的实例：    from flask import Flask,render_template    app = Flask(__name__)    @app.route(&apos;/&apos;)    def index():        context = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;gender&apos;:&apos;男&apos;,            &apos;age&apos;: 18        }        return render_template(&apos;index.html&apos;,**context)    if __name__ == &apos;__main__&apos;:        app.run(debug= True)Jinja模板：        &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        这是HTML文件中的文字        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;模板的渲染和传参的实例：（含有类的例子）    from flask import Flask,render_template    app = Flask(__name__)    @app.route(&apos;/&apos;)    def index():        class Preson(object):            name = &apos;李坚&apos;            age = 20        p = Preson()        context = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;gender&apos;:&apos;男&apos;,            &apos;age&apos;: 18,            &apos;person&apos;: p        }        return render_template(&apos;index.html&apos;,**context)    if __name__ == &apos;__main__&apos;:        app.run(debug= True)Jinja模板：        &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        这是HTML文件中的文字        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;        &lt;hr&gt;        &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;        &lt;p&gt;年您：{{ person.age }}&lt;/p&gt;        &lt;/hr&gt;    &lt;/body&gt;    &lt;/html&gt;2.if判断语句* 语法格式：（Jinja模板中）    {% if xxx %}{% else %}{% endif %}if判断语句的具体实例（根据id的不同显示不同的页面）from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&lt;id&gt;/&apos;)def index(id):    if id == &apos;1&apos;:        user = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;age&apos; : 10        }    return render_template(&apos;index2.html&apos;,user=user)if __name__ == &apos;__main__&apos;:    app.run(debug= True)&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    {% if user %}        <a href="#">{{ user.username }}</a>        <a href="#">注销</a>    {% else %}        <a href="#">登陆</a>        <a href="#">注册</a>    {% endif %}&lt;/body&gt;&lt;/html&gt;3.for循环遍历列表和字典：* 字典的遍历和语法与&apos;python&apos;一样，可以使用&apos;item()&apos; &apos;keys()&apos; &apos;values()&apos;等函数    {% for k,v in user.item() %}<p>{{ k }}:{{ v }}</p>{% endfor %}* 列表的遍历：    {% for webisit in webisits %}<p>{{ webisit }}</p>{% endfor %}for循环的案例：（四大名著的表格排序）from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    books=[        {            &apos;name&apos;:&apos;西游记&apos;,            &apos;author&apos;:&apos;吴承恩&apos;,            &apos;price&apos;:&apos;100&apos;        },        {            &apos;name&apos;:&apos;红楼梦&apos;,            &apos;author&apos;:&apos;曹雪芹&apos;,            &apos;price&apos;:&apos;50&apos;        },        {            &apos;name&apos;:&apos;三国演义&apos;,            &apos;author&apos;:&apos;罗贯中&apos;,            &apos;price&apos;:&apos;150&apos;        },        {            &quot;name&quot;:&apos;水浒传&apos;,            &quot;author&quot;:&apos;施耐庵&apos;,            &quot;price&quot;:200        }    ]    return render_template(&apos;index2.html&apos;,books=books)if __name__ == &apos;__main__&apos;:    app.run(debug= True)Jinja模板&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;th&gt;书名&lt;/th&gt;            &lt;th&gt;作者&lt;/th&gt;            &lt;th&gt;价格&lt;/th&gt;        &lt;/thead&gt;        &lt;tbody&gt;        {% for book in books %}            <tr>                <td>{{book.name}}</td>                <td>{{book.author}}</td>                <td>{{book.price}}</td>            </tr>        {% endfor %}        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;4.过滤器：    * 介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来（就是设置一个默认的，然后再用户没有设置的时候就可以直接过滤 输出默认的值）* 语法：     {{ avater(用户输入的值的名字) | default（过滤器）('xxx')}}* default（过滤器）:如果当前变量不存在的时候，这个时候就可以指定默认值* length: 求列表或则字符串或则字典 元组的长度过滤器的例子：（将图片的参数进行传递 ）    from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    return render_template(&apos;index2.html&apos;,family=&apos;https://avatars2.githubusercontent.com/u/60211293?s=40&amp;v=4&apos;)if __name__ == &apos;__main__&apos;:    app.run(debug= True)Jinja模板：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;过滤器的例子：（关于评论的显示 ）Jinja模板：    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;    &lt;hr&gt;    &lt;p&gt;评论数:({{comments|length}})&lt;/p&gt;    &lt;ul&gt;        {% for comment in comments %}        <li>            <a href="#">{{comment.user}}</a>            <p>{{ comment.content }}</p>        </li>    {% endfor %}    &lt;/ul&gt;    &lt;/body&gt;    &lt;/html&gt;python文件：from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    comments = [        {            &apos;user&apos;: &apos;李建安&apos;,            &apos;content&apos;:&apos;xxx&apos;        },        {            &apos;user&apos;: &apos;李坚&apos;,            &apos;content&apos;:&apos;xxx&apos;        }    ]    return render_template(&apos;index2.html&apos;,comments=comments)if __name__ == &apos;__main__&apos;:    app.run(debug= True)5.继承和block块* 作用：可以把一些公共的代码放在父模板中（base.HTML）文件* 语法：#    {% extend 'base.html'%}block 实现：    * 作用：可以让子模版实现自己的需求，父模板需要提前定义好    * 注意：子模板中的代码必须放在block块中，不然没有效果    具体的block语法例子：{% block 模块名 %}{% endblock %}继承和block的具体实例：py文件：from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index():    return render_template('index.html')@app.route('/login/')def login():    return render_template('login.html')if __name__ == '__main__':    app.run(debug= True)base.html 文件： <!DOCTYPE html>   <html lang="en"><head>    <meta charset="UTF-8">    <title>{% block title %}{% endblock %}&lt;/title&gt;            &lt;style&gt;            .nav{                background: #3a3a3a;                height: 65px;            }            ul{                overflow: hidden;            }            ul li{                float: left;                list-style: none;                padding: 0 10px;                line-height: 65px;            }            ul li a{                color: white;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;nav&quot;&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发布问答&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    {% block main %}{% endblock %}</body></html>login.html:{% extends 'base.html' %}{% block title %}    登陆页面{% endblock %}        {% block main %}    <p>这是登陆页面</p>{% endblock %}    index.html:        {% extends 'base.html' %}        {% block title %}    首页{% endblock %}        {% block main %}    <p>这是首页面</p>{% endblock %}6.URL链接和加载静态文件    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径    * 可以加载css文件，js文件 image文件    image文件：    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;    js文件：     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;    css文件：    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;*url链接：使用url_for(视图函数名)，从而反转url 跳转页面        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;url链接和加载静态文件的例子：    Py文件：        from flask import Flask,render_template        app = Flask(__name__)        @app.route(&apos;/&apos;)        def index():            return render_template(&apos;index.html&apos;)        @app.route(&apos;/login/&apos;)        def login():            return render_template(&apos;login.html&apos;)        if __name__ == &apos;__main__&apos;:            app.run(debug=True)    index.html文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;        &lt;/body&gt;        &lt;/html&gt;    index.js文件：        /**         * Created by 栩森 on 2020/2/4.         */        alert(&apos;我是李坚&apos;)    index.css文件：           a{                background: red;            }    login.html 文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;h1&gt;这是登陆页面&lt;/h1&gt;        &lt;/body&gt;        &lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1.如何渲染Jinja2模板和传参：(主要是 &amp;apos;render_template&amp;apos;函数)

* 渲染模板：
    * 模板放在 templates 文件夹下面
    * 从 flask 中导入 render_template 函数
  
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端学习随笔记录</title>
    <link href="http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-09T02:55:00.000Z</published>
    <updated>2020-02-26T14:56:37.750Z</updated>
    
    <content type="html"><![CDATA[<p>1.css样式中：<br>    * id选择器： #id<br>    * class选择器： .class<br>    * 普通选择器： <h><br>    * 注意：如果想优先使用一个样式：在样式后面加入 ！important<br>    * 浮动： float left 左浮动  是将两行的东西放到同一行<br>            float right 右浮动  是将两行的东西放到同一行</p><hr><p>2.盒子模型：<br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>    Border(边框) - 围绕在内边距和内容外的边框。<br>    Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>    Content(内容) - 盒子的内容，显示文本和图像。</p><hr><p>3.css选择器<br>    * 分组选择器: h1,p1,h2<br>    * 后代选择器：.class p        .class div p<br>    * 相邻选择器 ： div+p<br>    * 普通兄弟选择器： div~p<br>    * 包含title属性对象选择器： [title],[id]<br>    * 伪类选择器： 标签名：自己定义的名字（使有相同的标签名的css精细化）</p><hr><p>4.javascript：具有动态交互的时，需要使用的语言<br>    * 在函数中定义参数的时候 有var时就是局部变量  没有的是的就是全局变量<br>        function func01(){<br>            var func01 = a<br>    }</p><hr><p>5.js运算符中 三元运算符的格式   ？xx1:xx2<br>    voteable = (age&lt;18)?’年龄太小’：’年龄达到’  符合要求输出前面 否则输出后面<br>———————————————————————————–6</p><p>6.js中弹窗的输出：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    // alert 弹窗     alert(&apos;abc&apos;);    //弹出现在的使时间    alert(new Date().toLocaleString());&lt;/script&gt; </code></pre><hr><p>7.JS中的其他输出</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;JS的输出&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1 id=&quot;title&quot;&gt;我是标题&lt;/h1&gt;        &lt;!-- 事件 双击 移动 --&gt;        &lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            // 弹窗            window.alert(&apos;提示信息1&apos;);            // 写入内容到html文档            // 当使用document.write时 如果页面加载完毕，会覆盖整个内容            document.write(&apos;我是document_write_01\n&apos;);            document.write(&apos;我是document_write_01&apos;);            // 获取页面上ID=title的对象  并用inneHtml 修改对象的数据            document.getElementById(&apos;title&apos;).innerHTML=&apos;我是HIML标题&apos;;            console.log(&apos;这是一些console日记&apos;);            // 定义函数            function func01(){                document.write(&apos;我是函数&apos;);            }        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>————————————————————————————8.JS的函数：<br>    var a=1 =&gt; 这是一个局部变量    a = 1 =&gt; 这是一个全局变量</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button onclick=&quot;sum02(1,2)&quot;&gt;点击计算&lt;/button&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function sum02(arg1,arg2){                result = sum(arg1,arg2);                console.log(result)            }            function sum(arg1,arg2){                return arg1+arg2;            }            console.log(sum(1,2))        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>9.时间和函数的结合</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;事件与函数相结合&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间1&lt;/button&gt;&lt;br/&gt;        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间2&lt;/button&gt;&lt;br/&gt;        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间3&lt;/button&gt;&lt;br/&gt;        &lt;button onmousedown=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;        &lt;button onmouseover=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function func01(obj){            obj.innerHTML = Date()        }    &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>10.js中的json字符串：json 是各个语言之间进行数据交互的桥梁</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;事件与函数相结合&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间1&lt;/button&gt;&lt;br/&gt;        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间2&lt;/button&gt;&lt;br/&gt;        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间3&lt;/button&gt;&lt;br/&gt;        &lt;button onmousedown=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;        &lt;button onmouseover=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function func01(obj){            obj.innerHTML = Date()        }    &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>11.js中获取元素的方式：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;// 获取元素的第一种方式 getElementById  var demo = document.getElementById(id=&apos;demo&apos;);console.log(demo);// 通过本来就有的标签来获取元素var h1s = document.getElementsByTagName(&apos;h1&apos;)console.log(h1s)// 通过class名来获取元素var sty01s = document.getElementsByClassName(&apos;sty01&apos;)console.log(sty01s)// 通过标签名来获取元素var nov1 = document.getElementsByName(&apos;nov&apos;)console.log(nov1)// 通过索引的方式来读取获取元素里面的内容console.log(nov1[0].innerHTML)// 获取一个div下的第一元素console.log(demo.firstElementChild);// 获取一个div下的第一元素的名字console.log(demo.firstElementChild.nodeName)// 获取一个div下的第一元素的文本内容console.log(demo.firstElementChild.innerHTML)// 修改div下的第一元素里的内容demo.firstElementChild.innerHTML = &apos;2020-02-09&apos;&lt;/script&gt;</code></pre><hr><p>12.js中事件及其元素的获取</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 添加事件的一种方式 --&gt;        &lt;h1 onclick=&quot;changetext(this)&quot;&gt;添加事件方法一 &lt;/h1&gt;                &lt;!-- 添加元素的第二种方式 --&gt;        &lt;h1&gt;添加事件方法二&lt;/h1&gt;        &lt;button id=&quot;myBtn1&quot;&gt;点我1&lt;/button&gt;        &lt;p id=&apos;content&apos;&gt;这是要修改的内容&lt;/p&gt;                &lt;!-- 添加事件方法3 --&gt;        &lt;button id=&quot;myBtn3&quot;&gt;点我&lt;/button&gt;        &lt;p id=&quot;content1&quot;&gt;这是要修改的内容&lt;/p&gt;                    &lt;script type=&quot;text/javascript&quot;&gt;            function changetext(obj){                obj.innerHTML = &apos;这里被点击了&apos;            }            function changecontent(){                document.getElementById(&apos;content&apos;).innerHTML = &apos;添加事件修改类容&apos;            }            // 添加事件的方法二            document.getElementById(&apos;myBtn1&apos;).onclick = changecontent            // 添加事件方法三            document.getElementById(&apos;myBtn3&apos;).addEventListener(&apos;click&apos;,function(){                document.getElementById(&apos;content1&apos;).innerHTML = &apos;这是修改后的内容&apos;            })            // document.getElementById(&apos;myBtn3&apos;).removeEventListener(&apos;onclick&apos;,changecontent)        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>13.在仿照百度页面的时候注意的问题<br>    事件监听：  onfocus 获取焦点   onblur 失去焦点<br>        * 用户名的input =&gt; onfocus 获取焦点 =&gt; 执行函数<br>        * 用户名的input =&gt; onblur  失去焦点  =&gt; 检查<br>    this =&gt; 在事件监控器中，默认又一个this的变量，表示的监听的对象本身<br>            当输入为空的时候，删除提示的信息</p><hr><p>14.Jquery<br>    Jquery是Javascript的一个库<br>    资源来源是   下载到本地 或者直接引用网络地址<br>    安装/导入/加载  <!--  <script src=""></script>> --><br>    jquery-1.10.2.min.js   压缩资源 =&gt; 线上环境<br>    jquery-1.10.2.js       非压缩资源 =&gt;开发环境<br>jquery的安装  是直接导入就好      </p><!-- <script src="http://libs.baidu.com/jquery/1.10.2/jquery.min.js"> --><p>基础的语法：     $(selector).action()<br>                美元符号定义 jQuery<br>                选择符（selector）”查询”和”查找” HTML 元素<br>                jQuery 的 action() 执行对元素的操作<br>选择器：在页面中选取所有 p 元素:    $(“p”)<br>        console.log($(‘p’))<br>        通过id来选择元素          $(‘#idname’)<br>        console.log($(‘#username’))<br>        通过类来选择元素          $(‘.classname’)<br>        console.log($(‘.register’))</p><hr><p>15.升级pip 就可以直接配置国内源<br>    python -m pip install –upgrade pip<br>    pip config set global.index-url <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><hr><p>16.获取服务器的信息的过程<br>    get请求方式</p><pre><code>// 获取服务器的信息   url = &apos;http://127.0.0.1:5000/check_form?username=&apos;   $.get(url+this.value,function(data){       console.log(data);           if (data == &apos;200&apos;){           $(&apos;#userinfo&apos;).html(&quot;&lt;img src=&apos;imgs/ok_small.png&apos;&gt;用户名合法&quot;)       }else{           $(&apos;#userinfo&apos;).html(&apos;用户名太受欢迎&apos;)       }   })                                                            </code></pre><hr><p>17.AJAX  与服务器进行数据交换并更新部分网页的艺术，在不重新加载整个页面的情况下<br>    AJAX    =    异步 JavaScript 和 XML</p><p>jqury中AJAX数据交换请求  post get   (json模式下的转换)</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt;&lt;br/&gt;    &lt;button id=&quot;btn1&quot;&gt;点击加载-get&lt;/button&gt;    &lt;div id=&quot;content1&quot;&gt;信息待加载...&lt;/div&gt;    &lt;button id=&quot;btn2&quot;&gt;点击加载-post&lt;/button&gt;    &lt;div id=&quot;content2&quot;&gt;信息待加载...&lt;/div&gt;    &lt;button id=&quot;btn3&quot;&gt;点击加载-JSON&lt;/button&gt;    &lt;div id=&quot;content3&quot;&gt;信息待加载...&lt;/div&gt;    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // Ajax是什么？        // 有什么用？        // 为什么要用Ajax?        // $(选择器).action =&gt; 当文档加载完成之后，执行以下代码        $(document).ready(function (){            url = &quot;http://127.0.0.1:5000/check_form&quot;;            // 发送一个Post请求: $.post(url, data, function)            // data =&gt; object 字典格式            username = $(&apos;#text1&apos;).val()            $(&quot;#btn1&quot;).click(function(){                $.get(url, {&quot;username&quot;:username},function(data){                    $(&quot;#content1&quot;).html(data);                })                                })            $(&quot;#btn2&quot;).click(function(){                $.post(url, {&quot;username&quot;:username},function(data){                    $(&quot;#content2&quot;).html(data);                })                            })            // 获取JSON字符串的方法            $(&quot;#btn3&quot;).click(function(){                var url = &quot;http://localhost:5000/show_detail&quot;                username = $(&quot;#username&quot;).val()                $.getJSON(url,function(data){                    $(&quot;#content3&quot;).html(JSON.stringify(data));                })                            })        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>18.jQuery-ajax-ajax的请求方式：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;button id=&quot;btn4&quot; type=&quot;button&quot;&gt;加载数据&lt;/button&gt;        &lt;div id=&quot;content4&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(&quot;#btn4&quot;).click(function (){            $.ajax({                // 请求地址                url:&quot;http://127.0.0.1:5000/check_form&quot;,                // type 请求的方式                type : &apos;GET&apos;,                // data: 如果有参数到这里设置                data:{                    &quot;username&quot;:&quot;a1234567&quot;,                },                // dataType：指定数据类型  json text xml html                dataType:&apos;text&apos;,                // timeout:超时  毫秒为单位                timeout:5000,                // async: 设置是否异步                async: true,                // 如果执行成功 执行函数                data: 是接口返回的数据                textStatus： 状态码  success error                xhr:xmlHttpRequest                success:function(data,textStatus,xhr){                    console.log(&quot;请求成功&quot;)                    console.log(data)                    console.log(textStatus)                    console.log(xhr)                    $(&apos;#content4&apos;).html(data)                },                // 如果执行失败                error:function(xhr,textStatus){                    console.log(&apos;请求失败&apos;)                    console.log(data)                    console.log(xhr)                },                // 整个ajax执行完成后                complete:function(){                    console.log(&quot;ajax执行完成&quot;)                },                // 执行开始前                beforeSend:function(xhr){                    console.log(&quot;发送请求前&quot;)                    console.log(xhr)                }            })        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>19.jQuery-ajax-ajax的请求方式-跨域访问：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;text&quot; id=&quot;wd&quot; /&gt;        &lt;button id=&quot;btn4&quot;&gt;sp0-baidu-ajax&lt;/button&gt;        &lt;div id=&quot;content4&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        /*        同源策略: 当浏览器在访问资源的时候，只能允许访问同源的数据                 协议、主机（ip/域名）、端口  全部相同，数据是同源的        跨域共享CORS: 协议、主机（ip/域名）、端口 任意一个不同，都认为是跨域访问        如何实现跨域共享CORS: 浏览器支持、服务端支持                 方法1： jsonp =&gt; html页面请求jsonp,服务端处理                 方法2： 服务端做cors处理        */        // 加载 &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;        // 参数 wd 下一站幸福        // 将接口返回的数据显示到content4中        $(&quot;#btn4&quot;).click(function (){            $.ajax({                url: &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;,                // url: &quot;http://cache.video.iqiyi.com/jp/avlist/202861101/1/&quot;,                data: {&quot;wd&quot;:$(&quot;#wd&quot;).val()},                dataType: &apos;jsonp&apos;,                // jsonp 默认值 =&gt;callback                jsonp: &apos;cb&apos;,                success: function(data){                    console.log(data);                    $(&quot;#content4&quot;).html(JSON.stringify(data))                }            })        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>20.跨域访问的解决方法  Cors  jsonp<br>    同源测试： 已拦截跨源请求：同源策略禁止读取位于 <a href="http://localhost:5000/show_detail的" target="_blank" rel="noopener">http://localhost:5000/show_detail的</a><br>    远程资源  因为缺少: CORS头 缺少   ‘Access-Allow-Origin’<br>    允许访问资源  会访问并获取url的结果 但是不会处理这个结果<br>同源策略：  域名 协议 端口都相同</p><p>CORS处理的方式：<br>    1.浏览器发送Ajax<br>    2.服务器从处理这个请求，并且在请求上加上Access-Control-Allow-Origin:主机<br>    3.浏览器匹配Orgin字段和Access-Control-Allow-Origin字段是否一致 如果一致就处理<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p><p>JOSONP原理：可以通过动态创建script标签 然后利用src属性进行跨区域<br>JSONP 优点： 没有简便  没有兼容性问题<br>JSONP 缺点： 只支持GET请求</p><p>总结：<br>1.什么是同源策略？为什么要有同源策略<br>    同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。<br>    当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。<br>    如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p><p>2.想跨域访问 有什么办法解决<br>    Cors  jsonp</p><p>3.CORS的原理？如何做<br>    CORS处理的方式：<br>    1.浏览器发送Ajax<br>    2.服务器从处理这个请求，并且在请求上加上Access-Control-Allow-Origin:主机<br>    3.浏览器匹配Orgin字段和Access-Control-Allow-Origin字段是否一致 如果一致就处理<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p><p>4.JSONP的原理？如何做<br>    JOSONP原理：可以通过动态创建script标签 然后利用src属性进行跨区域</p><p>5.CORS和JSONP的区别<br>    JSONP 优点： 没有简便  没有兼容性问题<br>    JSONP 缺点： 只支持GET请求<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p><p>6.什么是Ajax<br>    AJAX  与服务器进行数据交换并更新部分网页的艺术，在不重新加载整个页面的情况下<br>    AJAX    =    异步 JavaScript 和 XML<br>7.为什么要用AJAX？<br>    在不重新加载页面的情况下进行数据的交互</p><p>8.什么场景下使用Ajax?<br>    例如在触发某个事件的时候 需要提取后台的数据时</p><hr><p>21.表单提交 submit与butten 的区别<br>    input =&gt; button 和 submit 的区别<br>    button 只是一个普通的按钮<br>    submit 当点击时，会自动用method的方式提交表单到action<br>    提交表单中带有name属性的元素的表单控制的值<br>    get =&gt; 参数直接加到url末尾？name = value$name=value<br>    post =&gt; request-headers</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form&gt;            &lt;p&gt;&lt;label&gt;用户名&lt;/label&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt;            &lt;p&gt;&lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt;            &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/p&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>表单提交的方法： post 与get   submit button</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form id=&quot;form1&quot; method=&quot;post&quot; action=&quot;/login/&quot;&gt;            &lt;p&gt;&lt;label&gt;用户名&lt;/label&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot;/&gt;&lt;/p&gt;            &lt;p&gt;&lt;label&gt;密码&lt;/label&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt;&lt;/p&gt;            &lt;p&gt;&lt;input id=&quot;bt_button&quot; type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;input id=&quot;bt_submit&quot; type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/p&gt;        &lt;/form&gt;        &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            $(&quot;#bt_submit&quot;).click(function(){                // 只有返回true 才会提交表单                // 判断的语句                return true                // 判断的语句                return false            })            $(&quot;#bt_button&quot;).click(function(){                return $(&quot;#form1&quot;).submit()            })        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>22.bootstrap ： 基于HTML css Javascript  框架<br> css: 写好了一些样式<br> JS : 写好了一些事件 函数等<br>在使用bootstrap时候 可以直接连接网上资源：<br>    当只要css样式的时候 可以只加载bootstrap.css文件<br>    当要有交互的内容的时候  可以加载bootstrap.js文件 当时之前要加载jq文件</p><pre><code>&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;&lt;!-- 注意 bookstrap是基于javaquary 的   我们要先加载jq资源 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 加载jq --&gt;&lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></pre><hr><p>23.栅格系统：<br>    * bootstrap 把元素分成12等分<br>    * 响应式： 可以根据屏幕的大小，展示不同的大小内容<br>例子：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;        &lt;style&gt;            [class*=&quot;col-&quot;] {                /*padding-top: 15px;*/                /*padding-bottom: 15px;*/                /*background-color: #eee;*/                background-color: rgba(86, 61, 124, .15);                /*border: 1px solid #ddd;*/                border: 1px solid rgba(86, 61, 124, .2);            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!-- 创建一个容器 --&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;h1&gt;你好，世界&lt;/h1&gt;            &lt;h2&gt;1.栅格系统&lt;/h2&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-xs-4&quot;&gt;md4&lt;/div&gt;                &lt;div class=&quot;col-xs-6&quot;&gt;md6&lt;/div&gt;                &lt;div class=&quot;col-xs-2&quot;&gt;md2&lt;/div&gt;            &lt;/div&gt;            &lt;!-- 响应式 --&gt;            &lt;h3&gt;2.响应式例子：&lt;/h3&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-md-4 col-xs-6&quot;&gt;md4&lt;/div&gt;                &lt;div class=&quot;col-md-6 col-xs-6&quot;&gt;md6&lt;/div&gt;                &lt;div class=&quot;col-md-2 col-xs-6&quot;&gt;md2&lt;/div&gt;                &lt;div class=&quot;col-md-2 col-xs-6&quot;&gt;md2&lt;/div&gt;            &lt;/div&gt;             &lt;!-- 小练习 --&gt;            &lt;h3&gt;3.小练习&lt;/h3&gt;            &lt;div class=&quot;row&quot;&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;1&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;2&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;3&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;4&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;5&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;6&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;7&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;8&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;9&lt;/div&gt;                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;10&lt;/div&gt;                    &lt;/div&gt;            &lt;h3&gt;4.列偏移&lt;/h3&gt;            &lt;div class=&quot;raw&quot;&gt;                &lt;div class=&quot;col-md-4&quot;&gt;1&lt;/div&gt;                &lt;div class=&quot;col-md-4 col-md-offset-2&quot;&gt;2&lt;/div&gt;            &lt;/div&gt;            &lt;h3&gt;5.列嵌套&lt;/h3&gt;            &lt;!-- 将被嵌套的对象看成一个目标 进行切分 --&gt;            &lt;div class=&quot;raw&quot;&gt;                &lt;div class=&quot;col-xs-5&quot;&gt;1&lt;/div&gt;                &lt;div class=&quot;col-xs-7&quot;&gt;                    &lt;div class=&quot;col-xs-6&quot;&gt;2&lt;/div&gt;                    &lt;div class=&quot;col-xs-6&quot;&gt;3&lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>栅格系统还有一些格式 可以参考<a href="https://v3.bootcss.com/css/#type" target="_blank" rel="noopener">https://v3.bootcss.com/css/#type</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.css样式中：&lt;br&gt;    * id选择器： #id&lt;br&gt;    * class选择器： .class&lt;br&gt;    * 普通选择器： &lt;h&gt;&lt;br&gt;    * 注意：如果想优先使用一个样式：在样式后面加入 ！important&lt;br&gt;    * 浮动： float
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask-Migrate</title>
    <link href="http://yoursite.com/2020/02/08/Flask-Migrate/"/>
    <id>http://yoursite.com/2020/02/08/Flask-Migrate/</id>
    <published>2020-02-08T12:03:10.000Z</published>
    <updated>2020-02-08T12:25:28.437Z</updated>
    
    <content type="html"><![CDATA[<p>1.Flask-Migrate的作用：（代码在models_Migrate文件中）<br>    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，<br>    如果需要修改就必须要先删除表格。<br>    Flask-migrate就是为了解决不能在表格中添加或者修改内容的作用，可以解决在修改模型后<br>    直接映射到表中。</p><p>2.下载安装Flask-Migrate ： pip install flask-migrate</p><p>3.flask-migrate必须要借助 flask-script ，这个包中MigrateCommand 中的关于数据库的命令</p><p>4.flask-migrate 相关的命令：<br>    * python manage.py db init : 初始化迁移脚本的环境 只需要执行一次<br>    * python manage.py db migrate 生成迁移文件，每次修改都要执行<br>    * pythin manage.py db upgrade 将迁移的文件映射到数据中 每次需改都需要运行一次</p><p>5.要将数据库中的模型 madols.py 导入到manage文件中，这样才会找到相关的模块</p><p>6.各个文件的代码：<br>    config.py （同之前的一样）</p><pre><code>models_Migrate.py文件 ：    from flask import Flask    # 引入exts中的db    from exts import db    import config    from models import Aritcle    app = Flask(__name__)    app.config.from_object(config)    #防止循环引用 初始化app    db.init_app(app)    &apos;&apos;&apos;    #手动将app推到服务器的栈里面（重点）    with app.app_context():        #这里通过db 将 models文件放入其中了（重点）        db.create_all()    &apos;&apos;&apos;    @app.route(&apos;/&apos;)    def hello_world():        return &apos;Hello World!&apos;    if __name__ == &apos;__main__&apos;:        app.run(debug=True)manage.py文件（重点）    from flask_script import Manager    from models_Migrate import app    from flask_migrate import Migrate,MigrateCommand    from exts import db    from models import Aritcle    manage = Manager(app)    #1.要使用flasj_migrate 必须绑定app和db    migrate = Migrate(app,db)    #2. 把MigrateCommand 命令添加到 manager中    manage.add_command(&apos;db&apos;,MigrateCommand)    if __name__ == &apos;__main__&apos;:        manage.run()exts.py文件：（是为了防止循环应用app）    from flask_sqlalchemy import SQLAlchemy    db = SQLAlchemy()models.py 文件：    #引入exts 中的 db    from exts import db    class Aritcle(db.Model):        id = db.Column(db.Integer,primary_key=True,autoincrement=True)        title = db.Column(db.String(100),nullable=False)        content = db.Column(db.Text,nullable=False)        tags = db.Column(db.String(100),nullable=False)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Flask-Migrate的作用：（代码在models_Migrate文件中）&lt;br&gt;    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，&lt;br&gt;    如果需要修改就必须要先删除表格。&lt;br&gt;    Flask-m
      
    
    </summary>
    
    
    
      <category term="代码在models_Migrate文件中" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>Flask-Script</title>
    <link href="http://yoursite.com/2020/02/07/Flask-Script/"/>
    <id>http://yoursite.com/2020/02/07/Flask-Script/</id>
    <published>2020-02-07T11:50:40.000Z</published>
    <updated>2020-02-07T13:57:36.128Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-Script的用处：<br>    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的<br>    服务器，设置数据库，定时任务等<br>Flask-Script的安装 ：     pip install flask-script  操作命令进行安装    </p><p>flask-Script :在创建好flask项目后 要在创建一个主文件manage.py<br>        manage.py的文件内容：</p><pre><code>#导入script的 Manager文件from flask_script import Manager#导入flask_scripr_demo文件中 appfrom flask_script_demo import app#初始化managemanage = Manager(app)#在命令行中可以执行的命令 装饰器@manage.commanddef runserver():    print(&quot;服务器启动&quot;)#因为是作为主app文件  则需要一下代码if __name__== &apos;__main__&apos;:    manage.run()</code></pre><p>在cmd运行命令的方法（必须在项目的目录下）<br>        python manage.py runserver<br>            显示：服务器启动</p><p>flask_script中有一集中控制数据库命令的文件db_script</p><pre><code>manage.py 中的内容：    #导入script的 Manager文件    from flask_script import Manager    #导入flask_scripr_demo文件中 app    from flask_script_demo import app    #导入文件db_script 文件中的DBmanager对象    from db_script import DBmanager    #初始化manage    manage = Manager(app)    #在命令行中可以执行的命令 装饰器    @manage.command    def runserver():        print(&quot;服务器启动&quot;)    #将db_script.py中的命令放到主app中来    manage.add_command(&apos;db&apos;,DBmanager)    #因为是作为主app文件  则需要一下代码    if __name__== &apos;__main__&apos;:        manage.run()db_script中的内容：    #导入flask_script文件 中的manager    from flask_script import Manager    #初始化    DBmanager = Manager()    #设置命令    @DBmanager.command    def init():        print(&quot;初始化服务器&quot;)    @DBmanager.command    def migrate():        print(&quot;迁移成功&quot;)</code></pre><p>在cmd中运行的语句： python manage.py db init<br>                     显示结果：初始化服务器成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flask-Script的用处：&lt;br&gt;    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的&lt;br&gt;    服务器，设置数据库，定时任务等&lt;br&gt;Flask-Script的安装 ：     pip install fla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python做题时发现的问题</title>
    <link href="http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-06T02:40:56.000Z</published>
    <updated>2020-02-15T04:46:10.015Z</updated>
    
    <content type="html"><![CDATA[<hr><p>1.枚举函数的使用：enumerate()<br>    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)<br>    具体用用法实例:</p><pre><code>类型一：    tmplist = [1234, 5677, 8899]    for index,app_id in enumerate(tmplist):        print index, app_id    输出：     0 1234     1 5677     2 8899类型二：（从下标1开始取值）    tmplist = [1234, 5677, 8899]    for index,app_id in enumerate(tmplist, 1):        print index, app_id    输出：     1 1234     2 5677     3 8899类型三：使用range()或xrange()         tmplist = [1234, 5677, 8899]            for i in range(len(tmplist)):                  print i,tmplist[i]        输出：         0 1234         1 5677         2 8899</code></pre><hr><p>2.关于def add(x, y) -&gt; int:中符号-&gt;的意思：<br>-&gt;常常出现在python函数定义的函数名后面，为函数添加元数据,描述函数的返回类型，从而方便开发人员使用<br>    简而言之就是这个函数返回的类型会是 int 类型，如果不是可以强制性进行转换为int类型</p><ul><li>-&gt;  _Attr则表明函数返回的是一个外部可访问的类的私有变量</li></ul><hr><p>3.进制转化器：<br>    bin:二进制   cot:八进制   int:十进制  hex:十六进制</p><hr><p>4.Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数   decimal(小数)<br>     * 从浮点数据转换为Decimal类型<br>        #导入模块<br>        from decimal import getcontext,Decimal,Context<br>        mydec = Decimal.from_float(12.222)<br>        print(mydec)<br>        #结果为  12.222153432115212315……..精准的数字<br>    *  从字符串转化为Decimal类型<br>        mydec = Decimal(‘3.14’)<br>        print(mydec)<br>    * raw  将转义字符原样输出  r”hello\tworld”</p><hr><p>5.字符串（列表）里面的切片操作和下标取值操作（重点：包含开始 不包含结束）（切片没有下标越界）<br>    * 语法：[start:stop:step]  start:开始字符  stop:结束字符  step:步长  （其值可以省略）<br>    * step &gt; 0，从左往右切片       step &lt;0，从右往左切片<br>    * 左[0,1,2,3,……]   右[…….,-4-3,-2,-1]<br>    *  my_str=”mystr”<br>       print(my_str.count(‘m’))  查看字符串里面右几个m  也可以指定字符串的长度进行查看<br>       print(my_str.count(‘m’，1，3))     </p><hr><p> 6.判断字符是否为纯数字组成  str.isdigit()<br>   判断字符串是否为大写    str.isupper()<br>   判断字符串是否只包含字母： str.isalpha()<br>   判断字符串里的单词是否开头大写其他地方小写： str.istitle()<br>   判断字符串是否只只包含字母或者数字： str.isalnum()</p><p>   将字符串转换为大写： str.upper()<br>   将字符串转换为小写： str.lower()<br>   将字符中的单词第一字母大写其他字母小写 ：str.title()<br>   指定sep作为分割符号 将字符串切割成列表，分隔符可以任意设置（默认为空格）：<br>                           str.spilt(‘sep’)<br>       将列表用str拼接成一个大的字符串： ‘str’.join(list)(用str来拼接字符串)<br>       去除字符串中首尾的字符串，不带参数默认去除空格： str.strip([string])<br>       将字符串里的一个字符进行替代： str.replace(‘old’’new’[替换的个数])<br>       将字符中间对齐: str.center(witdth,’填充符号’)<br>       将字符左对齐:str.ljust(witdth,’填充符号’)<br>       将字符右对齐:str.rjust(witdth,’填充符号’)</p><pre><code>end 是可以表示最后字符串末尾的方式    end=&apos;&apos; 表示用空字符来连接字符index函数的作用：可以查看两个字符串是否有相同的部分并且返回相同部分的下标（最开始部分）    haystack.index(needle)  haystack 与 needle 是两个字符串    返回的值为一个下标（int）</code></pre><hr><p>7.字符串格式化：<br>    {变量：[填充字符][对齐方式&lt;^&gt;][宽度][格式]}.format()</p><hr><p>8.math 模块 : import math<br>              math.方法<br>  getpass 模块： import getpass   隐藏密码的模块<br>                  getpass.getpass(“输入密码”)<br>  random模块： 随机生成一个范围内的数字<br>                  random.randint(0,100)  随机取0~100中的一个数字</p><hr><p>9.分支语句（if的三元运算）<br>    reslut = 条件成立的结果 if 条件 else 条件不成立的结果</p><hr><p>10.while语句：<br>    是符合该条件的情况下才会执行(注意 是需要一个结束的语句) 下面相关的内容<br>    while 条件：<br>        do sth<br>        break<br>    continue: 是指跳到循环的开头<br>    break: 表示退出循环</p><hr><p>11.for循环语句：<br>    for item in rang(3):<br>        do sth<br>    表循环几次  指定循环的次数</p><hr><ol start="12"><li>自增长问题：<br>a+=i : a = a+1<br>a-=1 : a = a-1<br>自有在for循环语句中遍历出数字来 才能实现自增长的作用</li></ol><hr><p>13.find()函数的用法：<br>    find()方法检测字符串S中是否包含子字符串sub，如果指定start（开始）和end（结束）范围，<br>    则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值(如果包含多个字串，只返回最左边出现的索引值)，查找失败返回-1。<br>    以本题为例：<br>    s=”abcd1234”<br>    s.find(“cd”)，在字符串s中查找字串”cd”第一次出现时s中的索引值，因为索引从0开始，所以结果为2，注意s中出现多次cd的情况，例如：<br>    s=”abcd1234cd”<br>    s.find(“cd”)的结果依然是2，找不到时返回-1，比如：<br>    s=”1234”<br>    s.find(“cd”)的结果为-1</p><hr><p>14.zip()函数的用法：<br>    该函数配合 for循环语句进行使用  for i in zip(* 列表)<br>    具体的用法例子演示：</p><pre><code>&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; a = [&quot;abc&quot;, &quot;abd&quot;, &quot;bbb&quot;]&gt;&gt;&gt; b = zip(a)&gt;&gt;&gt; for each in b:...     print(each)...(&apos;abc&apos;,)(&apos;abd&apos;,)(&apos;bbb&apos;,)如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表&gt;&gt;&gt; b = zip(*a)&gt;&gt;&gt; for each in b:...     print(each)...(&apos;a&apos;, &apos;a&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;b&apos;, &apos;b&apos;)(&apos;c&apos;, &apos;d&apos;, &apos;b&apos;)</code></pre><hr><p>15.set函数的使用（目前使用到的是他的去重的作用）<br>    x = set(‘worlld’)<br>    print(x):{‘r’,’o’,’l’,’w’,’d’}(形成了一个集合 并且去除了重复的项)<br>    还可以使用add和update对集合进行修改和添加</p><hr><p>16.python中随机生成一个数的函数：<br>    import random<br>    print(random.random())<br>    输出结果：0.9437475481805455</p><hr><p>17.python中format函数 ：<br>    一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能：</p><pre><code>print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))# 通过字典设置参数site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}print(&quot;网站名：{name}, 地址 {url}&quot;.format(**site))网站名：菜鸟教程, 地址 www.runoob.com# 通过列表索引设置参数my_list = [&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;]print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))  # &quot;0&quot; 是必须的网站名：菜鸟教程, 地址 www.runoob.com</code></pre><hr><p>18.pack和unpack<br>    星号具有打包的功能 a,*b = (1,2,3,4,5) =&gt; a = 1  b = [2,3,4,5]</p><hr><p>19.匿名函数： 不需要命名的函数 只能有一个表达式 不用写return（一次性使用）<br>    lambda arg1(参数1) ，arg2(参数2):表达式（要返回的数据）</p><hr><p>20.sorted(iterable,key,reverse) 函数 ： 起到排序的作用<br>    key -&gt; 是指定一个排序的方式(可以放入函数)   iterable -&gt;是变量名  reverse -&gt; 是否逆序<br>            .join的作用是排列方式用 ‘’来隔开<br>     例子： mystr = “aaAbmcDikLNog”<br>           print(‘’.join(sorted(mtstr,key=str.upper)))</p><hr><ol start="21"><li>在字符串中的replace函数：<br>replace()方法语法：str.replace(old, new,[max])<br>参数:<pre><code>old -- 将被替换的子字符串。new -- 新字符串，用于替换old子字符串。max -- 可选字符串, 替换不超过 max 次</code></pre>例子：<pre><code>str = &quot;this is string example....wow!!! this is really string&quot;;print str.replace(&quot;is&quot;, &quot;was&quot;）结果-&gt;thwas was string example....wow!!! thwas was really string</code></pre></li><li>if语句用一行的形式进行展示：<pre><code>c = a if a&gt;b else b</code></pre></li><li>get方法：<pre><code>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。dict.get(key, default=None)  如果没有key值 就会返回一个None</code></pre> pop方法：<pre><code>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值list.pop([index=-1]) 默认移除列表中最后一个值</code></pre></li></ol><hr><h2 id="24-global是表示全局变量-咳可以在局部变量里面设置global就会变成全局变量"><a href="#24-global是表示全局变量-咳可以在局部变量里面设置global就会变成全局变量" class="headerlink" title="24.global是表示全局变量  咳可以在局部变量里面设置global就会变成全局变量"></a>24.global是表示全局变量  咳可以在局部变量里面设置global就会变成全局变量</h2><p>25.val()函数的功能： 将一组字符型数据的数字部分转换成相应的数值型数据<br>            例如：   x = “12 5fdsa DA456”;<br>                    那么 val(x)应该返回125 后面的456不能返回来</p><pre><code>x= &apos;123 456&apos; 那么val(x)返回的是123456</code></pre><hr><p>26.next()函数：将迭代器里面的函数依次的返回出来<br>    b=[1,2,3,4]<br>    a=iter(b)<br>    next(a)会依次返回1,2,3,4，StopIteration，StopIteration..</p><hr><h2 id="27-可迭代对象：str-list-dict-tuple-set"><a href="#27-可迭代对象：str-list-dict-tuple-set" class="headerlink" title="27.可迭代对象：str list dict tuple set"></a>27.可迭代对象：str list dict tuple set</h2><p>28.在字典中 .get 方法 是会判断字典中是否有查找的这个值，如果没有<br>    就会返回一个None  或者自己设定一个值： .get(‘key’,’设定值’)<br>    字典中：删除的方法： dicts.pop(key):删出指定的字典key的值<br>                       dicts.popitem():删除键值对的  默认最后一个<br>    字典合并：dict1.update(dict2) =&gt;将dict2合并到dict1中<br>            dict(dict1,** dict2) =&gt;将dict1与dict2合并到生成的一个新字典中<br>    in与not in : 比较的是字典中key的比较<br>                或则进行 dict.values() 获取values值<br>    items() : 是可以获取 key和values 值</p><hr><p>29.集合：set()<br>    集合是无序的 不重复的数据组合<br>    集合是一个只包含key的字典   （hash对象就是不可变对象）<br>    集合会自动的去重<br>    集合坐添加的操作：s.add(iteme) =&gt; 添加一项<br>                     s.update(iteme) =&gt; 添加多项   s.update([10,37,42])<br>    集合的移除： s.remove()  =&gt; 如果移除的项没有在集合中 则会报错<br>                s.discard() =&gt; 移除的项么有在集合中 也不会报错<br>    集合的并集(|)和交集(&amp;)： 并集就是将两个集合加在一起  交集就是去公共部分<br>                            union 也是表示并集的方法<br>                            intersection  表示交际的方法<br>    集合的差集(-)：返回set中s中有t中没有的元素<br>                   s.different(t)      s-t<br>    集合的对称差集： 返回没有没有同时出现在两个集合中的元素<br>                    s.symmetric_different(t)       s^t</p><hr><p>30.JSON<br>    JSON(javaScript Object Notation)是一种轻量级的数据交换格式<br>    使用的时候需要导入  import JSON<br>    可以使用bejson 进行格式化的校验<br>    dumps 是将python中的字典转化为json中的str<br>    loads 是将json 中的实例 转化为 python中的 project  需要用’’’json 字符串’’’</p><hr><p>31.文件的基本操作：<br>    文本文件：<br>        优点：输出内容友好，不需要手动转换<br>        缺点：一个字符占一个字节，文件占用的存储空间较多，访问时效率不高<br>    二进制文件：<br>        优点：占用空间少，计算机读取时不需要进行准换<br>        缺点：无法直接以字符形式输出，必须要经过一个转换<br>    decode:解码（将二进制转化为汉字）<br>    encode:编码（将汉子转化为二进制）<br>    注意：解码和编码的方式要相同</p><hr><p>32.文件操作的格式：<br>    f = open(‘file/example’,encoding = ‘utf-8’)  打开文件<br>    f.readlines()    读文件<br>    f.close() 关闭文件</p><hr><p>33.打开文件Mode<br>    r  读模式   文件存在：正常打开   文件不存在：出错<br>    w  写模式   文件存在：写入，会覆盖原文件内容   文件不存在：创建新文件<br>    x  创建新文件 写入内容   文件存在：FileExistsError  文件不存在：创建新文件 写入<br>    a  追加模式  文件存在： 在原来的内容后追加    文件不存在：创建新文件<br>    b  二进制模式  python 下网络传输 只能用bytes模式  rb  rb+<br>    t  文本模式（默认）  r w x<br>    r+  可读写 文件不存咋会报错<br>    w+  可读写 将文件原内容清空 再写<br>    a+  可读可追加  在文件后面最佳内容<br>    x+  可读写  文件存在会报错</p><hr><p>34.判断文件编码：chardet<br>    安装 pip install chardet<br>    # 查看编码方式<br>    import chardet<br>    f = open(‘file/utf8’,mode=’rb’)<br>    print(chardet.detect(f.read()))<br>    结果：{‘encoding’: ‘utf-8’, ‘confidence’: 0.938125, ‘language’: ‘’}</p><hr><p>35.无需手动关闭文件的方法：（with语句）<br>    with open(‘file/utf8’,mode=’r’,encoding=’utf8’) as f1:<br>    for line in f1:<br>        print(line) </p><pre><code>查看文件是否关闭： f.closed  Ture:表示关闭  Fouls：没有关闭</code></pre><hr><p>36.读取文件内容：<br>    f.tell                 文件光标的位置（字节位置）                  整数int<br>    f.seek(cookie,whence=0)移动光标位置cookie：偏移量 whence：相对位置  NONE<br>    例子：f.seek(3,1)   1:表示当前位置  3:向右偏移三个位置   0：开始位置  2: 末尾<br>          f.seek(偏移量，相对位置)<br>    fp                     文件对象                  可迭代对象        IOWrapper<br>    fp.readlines()         返回当前到文末的一个列表                   list<br>    f.read()               返回当前到文末（字符串），可指定读几个字符串   str<br>    f.readline()           返回当前位置到行末                          str<br>    line.startwith(‘’)        表示每一行是否为某一个字符<br>       例子： for line in f:<br>                   print(‘’ if line.startswith(“#”) else line, end=’’)</p><hr><p>37.文件的写操作：<br>    import time<br>    with open(‘file/exaple’,’w’,encoding=”utf8”) as f :<br>    f.write(“第一次测试”)<br>    time.sleep(10)   #  这样的写入方式不是实时写入</p><p>   要实现实时写入方式的操作：  1.   f.flush()<br>                                2.   文件close后会写入<br>                                3.   当脚本休眠时间到后会写入<br>       实时写入<br>        import time<br>      with open(‘file/exaple’,’wb’,buffering=0) as f :<br>        while True:<br>            content = input(“&gt;”)<br>            #输入的字符串为q则退出   lower(): 转化为小写    strip():将开头可结尾的字符串转化为空<br>            if content.lower().strip() == ‘q’:<br>                break<br>            f.write(content.encode(‘utf8’))</p><hr><p>38.文件对象的其他方法：<br>    f.fileno()      返回文件描述符<br>    f.readline()    判断文件是否可读<br>    f.seekable()    指针是否可以移动<br>    f.truncate()    文件头开始截取指定参数的n个字节，其他的全部删除<br>    f.writable()    文件是否可以写<br>39.京东面试题：</p><pre><code>import randomdef create_ip_file(filename:str) -&gt; None:    with open(filename,&apos;w&apos;,encoding=&apos;utf8&apos;) as f:        for i in range(1200):            f.write(f&quot;172.25.254.{random.randint(1,255)}\n&quot;)def sort_by_id(filename,topnum = 10):    ip_dict = {}    with open(filename,&apos;r&apos;,encoding=&apos;utf8&apos;) as f:       for ip in f:           ip = ip.strip()           if ip in ip_dict:                ip_dict[ip] += 1           else:               ip_dict[ip] = 1    return sorted(ip_dict.items(),key=lambda x:x[1],reverse=True)[:topnum]FILENAME = &apos;file/ips.txt&apos;create_ip_file(FILENAME)for key,vaual in sort_by_id(FILENAME,topnum=10):    print(key,&apos;=&gt;&apos;,vaual)</code></pre><hr><p>40.OS库常用操作：<br>        os.getcwd()： 得到当前工作目录<br>        os.listdir(): 返回指定目录下的所有文件和目录名<br>        os.chdir(‘path’):转换目录<br>        os.path.isfile():检验给出的路径是否是一个文件<br>        os.path.isdir():检验给出的路径是否是一个目录<br>        os.path.isabs():判断是否是绝对路径<br>        os.path.exists():检验给出的路径是否存在<br>        os.path.split():反回一个路径的目录名和文件名<br>        os.path.splitext():分离扩展名<br>        os.path dirname():获取路径名<br>        os.path.basename():获取文件名<br>        os.path.getsize(filename):获取文件大小<br>        os.mkdir():    创建单个目录<br>        os.makedirs() ：创建多级目录<br>        os.mknod(): 创建空文件<br>        os.remove(): 删除文件<br>        os.rmdir(): 只能删除空目录<br>        os.removedirs(): 删除多个目录<br>        os.rename(old,new) : 重命名，文件或目录都是使用这个命令<br>        os.chmod():修改文件权限与时间戳<br>        os.stat(file) : 获取文件属性<br>41.在一个目录下创建文件，名字随机，将名字前面都加上李坚</p><pre><code>import osimport randomimport stringdef creat_files(path,filenum = 10) -&gt;None:    if not os.path.exists(path):        os.mkdir(path)    # 返回path路径    os.chdir(path)    for i in range(filenum):        filename = &apos;&apos;.join(random.choices(string.ascii_lowercase,k=6))        f = open(filename,encoding=&apos;utf8&apos;,mode=&apos;w&apos;)        f.close()def rename_files(path,prefix) -&gt; None:    for file in os.listdir(path):        if not file.startswith(prefix):            os.rename(f&apos;{path}/{file}&apos;,f&apos;{path}/{prefix}{file}&apos;)print(os.getcwd())creat_files(&apos;test03&apos;)os.chdir(&apos;..&apos;)print(os.getcwd())rename_files(&apos;test03&apos;,&apos;[李坚]-&apos;)</code></pre><hr><p>42.更具自己命名的模块进行导入<br>    modname = input(‘请输入模块名：’)<br>    import importlib<br>    mod = importlib.import_module(modname)<br>    print(mod)</p><hr><p>43.重命名的模块，可以用as取别名<br>    from pack01 import tree as three01</p><hr><p>44.模块的相对导入：<br>    当前执行文件所在目录不是一个包<br>    子目录及更深的目录都是包<br>模块的导入顺序：<br>    1.第一级内置模块<br>    2.第二级sys.path路径列表<br>    3.如果没有找到就会出错</p><hr><p>45.python下划线的含义：<br>    以单下划线开头的：_ foo  表示私有的， 不能用from xxx import * 导入<br>    以双下划线开头的：__ foo 表示私有的，    不能用from xxx import * 导入<br>    以双下划线开头和结尾的：__ foo __  代表python中特殊方法专用的表示符<br>在直接导入模块的后  是可以使用这些私有对象的   只是在from xxx import * 不能导入私有<br><strong>all</strong> 这个模块是规定在from xxx import * 时候会导入的那个模块   可以是私有的<br>    __ all __ = [‘<em>model’,’model’]<br>_</em> init __文件   是导入某一个包的时候就会直接导入 __ init __.py ..  </p><hr><p>46.<strong>name</strong>  ：  当只是当作自身来执行的时候  print(<strong>name</strong>)  =&gt; <strong>main</strong><br>                 当模块导入的时候   from xxx import x =&gt;会显示<strong>name</strong>在那个包和文件中<br>   <strong>file</strong> : 打印模块路径<br>   <strong>doc</strong>: 打印当前文档的注释信息    </p><hr><ol start="47"><li>if <strong>name</strong> == ‘<strong>main</strong>‘：<pre><code>func()</code></pre>表示：当执行文件自身的时候就会调用函数， 否则就不会调用函数（导入的时候不需要调用）</li></ol><hr><p>48.断言：  assert     一般在做测试的时候使用<br>        assert 1+2==5,’出错了’  =&gt;  显示：AssertionError：出错了</p><hr><p>49.异常处理<br>    try:<br>        执行的代码<br>    except 错误类型 as 接收错误详细的变量:（指定接受的错误类型）  except:(所有的错误类型)<br>        处理的内容<br>    except 错误类型 as 接收错误详细的变量(ex):（指定接受的错误类型）<br>        处理的内容<br>    else:（不经常用）<br>        没有发生异常额时候<br>    finally:（不经常用）<br>        不管是否出现错误都会执行<br>raise:引发一个错误    raise NameError(‘出错了’)  手动引发错误<br>        在函数中使用的较多<br>在 try,except中使用retrun进行返回 还是会执行finally中的return 并且返回的值还是finally中retun的值   如果finally中没有return 就会反回自身的return</p><h2 id="在finally-中要小心使用return-因为会导致异常丢失（重点）"><a href="#在finally-中要小心使用return-因为会导致异常丢失（重点）" class="headerlink" title="在finally 中要小心使用return  因为会导致异常丢失（重点）"></a>在finally 中要小心使用return  因为会导致异常丢失（重点）</h2><p>50.常见的异常错误：<br>    NameError      尝试访问一个没有审明的变量<br>    ZeroDivisionError  除数为0<br>    SynataxError     语法错误<br>    IndexError       索引超出序列范围<br>    KeyError         请求一个不存在的字典关键字<br>    IOError          输入输出错误<br>    AttributeError   尝试访问未知的对象属性<br>    ValueError       传递函数的参数类型不正确<br>    AssertionError   断言错误</p><hr><p>51.获取引用计数：getrefcount()<br>    from sys import getrefcount<br>    a = [1,2,3]<br>    print(getrefcount(a))  =&gt; 2   用户调用了一次  系统调用了一次 一共两次<br>    b = a<br>    print(getrefcount(b))  =&gt; 3<br>在不可边对象中 ：  系统自动的引用机制为2次<br>在可边对象中：     系统自动的引用机制为1次<br>引用类机制的引用次数就会增加   删除类机制引用次数会减少</p><hr><p>52.python垃圾回收<br>    当Python的某个对象的引用计数降为0的时候，就可以进行垃圾回收了<br>   gc机制： 自动内存管理机制  找到内存中无用的垃圾  清除垃圾让出内存</p><p>  三种情况下会触发垃圾回收：<br>     (引用计数为0后)                        import gc<br>      调用gc.collect()                        print(gc.get_threshold) =》(700,10,10)<br>       GC达到阈值时(700,10,10)<br>      程序退出时<br>53.字符串的intern机制：<br>    python对于短小的，只包含字母和数字的字符串会自动触发缓存机制 </p><hr><p>54.深拷贝与浅拷贝<br>    浅拷贝：a.copy()<br>    深拷贝：     improt copy    copy.deepcody(a)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;1.枚举函数的使用：enumerate()&lt;br&gt;    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)&lt;br&gt;    具体用用法实例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类型一：
    tmplist
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask-SQLAlchemy-DateBase</title>
    <link href="http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/"/>
    <id>http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/</id>
    <published>2020-02-04T07:21:13.000Z</published>
    <updated>2020-02-08T12:02:08.428Z</updated>
    
    <content type="html"><![CDATA[<p>1.MySQL-python中间件的介绍和安装<br>     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装<br>     * 在window下需要到’<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;</a><br>      这个网址下载对应的python版本的中间件<br>          对应的命令： pip install mysqlclient-1.4.6-cp38-cp38-win_amd64.whl<br>     * 注意：如果与python的版本不符合就会出现报错的现象</p><p>2.ORM与Flask-SQLALchemy的安装和介绍<br>    * ORM: Objct Relationship Mapping (模型关系映射)<br>    * flask-aqlalchemy是一套ORM框架<br>    * ORM的好处：可以不适用sql语句进行对数据的修改 ，可以直接使用类的语句就好.一个表<br>        就是一个类，一条数据就是一个对象<br>    * 安装Flask-SQLALchemy： pip install flask-sqlalchemy</p><pre><code>例子： class Ariticle(Moble):        id = int()        title = String()        content = Text()       #实例化           article = Article(id = 1,title = &apos;aaa&apos;,content = &apos;bbb&apos;)       #加入表格或者说类中            add(article)       #修改数据内容             article.title = &apos;ccc&apos;             update(article)       #删除内容             delete(article)</code></pre><p>3.SQLALchemy连接数据库<br>    SQLALchemy :SQLAlchemy采用简单的Python语言，为高效和高性能的数据库访问设计<br>                是访问和操作数据库的开源脚本<br>    * 在实际操作过程中遇到的问题：<br>        * 在Mysql workbeath 中修改连接密码：右键出现Edit connections 进行点击 进入后点击store in Vault 就可以进行修改<br>        * 如何进入Mysql 命令行的形式：找到Mysql sever 下的bin目录 再就如命令行输入<br>            ./mysql -u root -p<br>        * 创建一个新的数据库 命令     creat datebase  数据库名  charset  utf8<br>    使用flask_sqlalchemy中的SQLALchemy进行初始化：</p><pre><code>    #调用函数    from flask_sqlalchemy import SQLAlchemy    app = Flask(__name__)    #初始化一个对象    db = SQLAlchemy(app)设置配置文件&apos;config.py&apos;文件中添加一下配置#dialect+driver://username:password@host:post/database    DIALECT = &apos;mysql&apos;    DRIVER = &quot;mysqldb&quot;    USERNAME = &apos;root&apos;    PASSWORD = &apos;root&apos;    HOST = &apos;127.0.0.1&apos;    PORT = &apos;3306&apos;    DATABASE = &apos;db_demo1&apos;    SQLALCHEMY_DATABASE_URI = &quot;{}+{}://{}:{}@{}:{}/{}?charset=utf8&quot;.format(DIALECT,                                                   DRIVER,USERNAME,                                                   PASSWORD,HOST,PORT,                                                   DATABASE)    #去除警告信息    SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>   在app文件中，添加配置文件，并且进行测试</p><pre><code>from flask import Flask   #调用函数from flask_sqlalchemy import SQLAlchemy#引入config文件import configapp = Flask(__name__)#重点（不明白）app.config.from_object(config)#初始化一个对象db = SQLAlchemy(app)#进行测试db.create_all()</code></pre><p>4.SQLALchemy模型与表映射<br>    * 创建的这个表可以称作为一个类，这个类必须要继承自’db.Model’，然后映射到表中的时候<br>       必须写成’db.Column’的数据类型<br>    * 数据类型：<br>        * ‘db.Integer’代表的是整型（int）<br>        * ‘db.String’ 代表的是’varcher’,需要指定最长的长度<br>        * ‘db.Text’代表的是 ‘text’<br>    * 参数类型：<br>        * ‘primary_key’:代表的是将字段是否设置为主键<br>        * ‘autoincrement’: 代表的是这个主键是否为自增长的<br>        * ‘nullable’ : 表示该字段是否可以为空，数据库默认是能为空<br>    * 最后需要用’db.create_all’来将模型真正的创建到数据库中</p><p>   在实践过程中遇到的问题：</p><ul><li><p>对数据库的连接不熟练，以及配置文件的编写</p><pre><code>from flask import Flask</code></pre><p>   from flask_sqlalchemy import SQLAlchemy<br>   import config<br>   app = Flask(<strong>name</strong>)<br>   app.config.from_object(config)<br>   #初始化对象<br>   db = SQLAlchemy(app)</p><p>配置文件的编写：</p><h1 id="dialect-driver-username-password-host-post-database"><a href="#dialect-driver-username-password-host-post-database" class="headerlink" title="dialect+driver://username:password@host:post/database"></a>dialect+driver://username:password@host:post/database</h1><p>   DIALECT = ‘mysql’<br>   DRIVER = ‘mysqldb’<br>   USERNAME = ‘root’<br>   PASSWORD = ‘root’<br>   HOST = ‘127.0.0.1’<br>   POST = ‘3306’<br>   DATABASE = ‘db_mode2’<br>   SQLALCHEMY_DATABASE_URI = ‘{}+{}://{}:{}@{}:{}/{}?charset=utf8’.format(DIALECT,</p><pre><code>DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)</code></pre><p>   SQLALCHEMY_TRACK_MODIFICATIONS = False</p></li><li><p>在数据库中需要使用的语句：</p><pre><code>创建数据库： create database 数据库名 charset utf8查看数据库中的表 ： show tables 查看表的内容： desc 表名使用那个数据库： use 数据库名展现创建的表格： show create table 表名删除表格： drop table 表名</code></pre><ul><li><p>将SQL语句转化为py文件中类的语句<br>  ‘’’<br>SQL语句中创建表格<br>   create table article(</p><pre><code>id int primary key autoincrement,title varchar(100) not null,content text not null,</code></pre><p>   )<br>‘’’</p><p>class Article(db.Model):<br>   <strong>tablename</strong> =’article’<br>   id = db.Column(db.Integer,primary_key=True,autoincrement=True)<br>   title = db.Column(db.String(100),nullable=False)<br>   content = db.Column(db.Text,nullable=False)</p></li></ul></li></ul><p>创建一个表的例子：</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)#初始化对象db = SQLAlchemy(app)&apos;&apos;&apos;SQL语句中创建表格    create table article(        id int primary key autoincrement,        title varchar(100) not null,        content text not null,    )&apos;&apos;&apos;class Article(db.Model):    __tablename__ =&apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    content = db.Column(db.Text,nullable=False)db.create_all()@app.route(&apos;/&apos;)def hello_world():    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run()</code></pre><p>config 配置文件</p><pre><code># dialect+driver://username:password@host:post/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;mysqldb&apos;USERNAME = &apos;root&apos;PASSWORD = &apos;root&apos;HOST = &apos;127.0.0.1&apos;POST = &apos;3306&apos;DATABASE = &apos;db_mode2&apos;SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset=utf8&apos;.format(DIALECT,                               DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>5.SQLALchemy 数据库的增删查改</p><pre><code>#数据库增加数据    article = Article(title = &apos;aaa&apos;,content = &apos;bbb&apos;)    db.session.add(article)    #事务相应（操作的开关）    db.session.commit()#数据库查找数据    #SQL： select * from article where article.title=&apos;aaa&apos;;    #query:查找   fileter：过滤    article1 = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    #返回的是一个列表 之后的操作可以根据列表的操作进行    print(&apos;title:%s&apos; % article1.title)    print(&apos;content:%s&apos; % article1.content)#数据的修改    #1.先要查找出修改的数据    article1 = Article.query.filter(Article.title==&apos;aaa&apos;)[0,1]    #2.在需要修改的地方进行修改    article1.title = &apos;new title&apos;    #3.提交事务    db.session.commit()#删除数据    #1.把需要删除的数据查找出来    article1 = Article.query.filter(Article.content == &apos;bbb&apos;)[0]     #2.删除数据    db.session.delete(article1)    #3.事务处理    db.session.commit()</code></pre><p>6.Flask-SQLALchemy 外键及其关系<br>    * 连接数据库（跟以上的操作一样）<br>    * 创建两个表（user article）</p><pre><code> #创建用户表(user) &apos;&apos;&apos; SQL语句：         create table users(         id int primary key autoincrement,         username varchar(100) not null ) &apos;&apos;&apos; class User(db.Model):     __tablename__ = &apos;user&apos;     id = db.Column(db.Integer,primary_key= True,autoincrement=True)     username = db.Column(db.String(100),nullable=True)  #创建文章表     &apos;&apos;&apos;     SQL语句：             create table article(                 id int primary key autoincrement,                 title varchar(100) not null,                 content text not null,                 author_id int,                 foreign key &apos;author_id&apos; references &apos;user_id&apos;     )             &apos;&apos;&apos;     class Article(db.Model):         __tablename__ =&apos;article&apos;         id = db.Column(db.Integer,primary_key=True,autoincrement=True)         title = db.Column(db.String(100),nullable=False)         content = db.Column(db.Text,nullable=False)         #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)         author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    * 映射到数据库中：   db.create_all()        注意： db.create_all() 它只会部署一次，如果中途在类里面去需改表的属性是没有任何用处的，只有把表格进行删除，再        重新创建一个表格才能添加其他的属性* 在用户表中添加用户     user1 = User(username = &apos;lijian&apos;)     db.session.add(user1)     db.session.commit()</code></pre><ul><li><p>在文章表中添加文章</p><pre><code>article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)db.session.add(article)db.session.commit()</code></pre><ul><li><p>实现需求：查找文章名称为aaa的作者</p><pre><code>这是需求的普通写法:没有起到简化的作用 再Flask中不会使用    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author_id)    author_id = article.author_id    user = User.query.filter(User.id == author_id)[0]    print(user.username)再Flask-SQLALchemy-Darabases中使用的方法:    * 先要在class类中就行设置;            class Article(db.Model):            __tablename__ =&apos;article&apos;            id = db.Column(db.Integer,primary_key=True,autoincrement=True)            title = db.Column(db.String(100),nullable=False)            content = db.Column(db.Text,nullable=False)            #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)            author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    #重点：db.relationship是表述关系的连接参数  db.backre是表示关系反转的参数    #正向引用（relationship）与反向引用（backref）（User表与article表）        #正向关系：是只通过article表里面的外键来与User表中的主键进行连接             然后读取相关信息                #通过文章名称找出作者名称    #反转关系：是只通过User中的主键来连接article中的外键，然后读取article中的相关信息                 #通过作者找出他写作的文章    #模块名=db.relationship(&apos;关联的类名&apos;，backref = db.backref(&apos;自定义参数&apos;))            author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))    * 实现通过文章名称查找作者：            article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]            #通过 article.author.usename 来找出文章的作者            print(article.author.username)</code></pre><ul><li><p>实现需求：通过作者名找出其作品</p><pre><code>user = User.query.filter(User.username == &apos;lijian&apos;)[0]#通过 user.articles.title 来查找作者的文章result = user.articlesfor article in result:    print(article.title)</code></pre></li></ul></li></ul></li></ul><p>实例：数据库的连接 表的制作 数据的的添加 实现通过作者找出他的所有文章 通过文章找出作者</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)#创建用户表&apos;&apos;&apos;SQL语句：        create table users(        id int primary key autoincrement,        username varchar(100) not null)&apos;&apos;&apos;class User(db.Model):    __tablename__ = &apos;user&apos;    id = db.Column(db.Integer,primary_key= True,autoincrement=True)    username = db.Column(db.String(100),nullable=True)#创建文章表&apos;&apos;&apos;SQL语句：        create table article(            id int primary key autoincrement,            title varchar(100) not null,            content text not null,            author_id int,            foreign key &apos;author_id&apos; references &apos;user_id&apos;)        &apos;&apos;&apos;class Article(db.Model):    __tablename__ =&apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    content = db.Column(db.Text,nullable=False)    #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)    author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    #正向引用（relationship）与反向引用（backref）    author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;)) #实现映射到表中db.create_all()##########@app.route(&apos;/&apos;)def hello_world():    &apos;&apos;&apos;    #在用户表中添加用户    user1 = User(username = &apos;lijian&apos;)    db.session.add(user1)    db.session.commit()    &apos;&apos;&apos;    #添加作品信息    &apos;&apos;&apos;    article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)    db.session.add(article)    db.session.commit()    &apos;&apos;&apos;    #需求：寻找标题文章为aaa的作者    &apos;&apos;&apos;    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author_id)    author_id = article.author_id    user = User.query.filter(User.id == author_id)[0]    print(user.username)    &apos;&apos;&apos;    #上述需求的简化:    #根据文章名称查找作者    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author.username)    print(&quot;*&quot;*20)    #需求 找到lijian写过的所有的文章    user = User.query.filter(User.username == &apos;lijian&apos;)[0]    result = user.articles    for article in result:        print(article.title)    &apos;&apos;&apos;    #先添加一篇文章    article = Article(title=&apos;111&apos;,content=&apos;222&apos;,author_id=1 )    db.session.add(article)    db.session.commit()    &apos;&apos;&apos;    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run(debug=True)</code></pre><p> 数据库连接的config 文件：</p><pre><code> #dialect+driver://username:password@host:post/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;mysqldb&apos;USERNAME = &apos;root&apos;PASSWORD = &apos;root&apos;HOST = &apos;127.0.0.1&apos;POST = &apos;3306&apos;DATABASE = &apos;db_demo3&apos;SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset utf8&apos;.format(DIALECT,                            DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><hr><p>7.SQLALchemy连接数据库中多对多关系<br>    * 配置相关的config 文件 与之前一样</p><pre><code>* 设置关联的语句（重点）（在class Aritcle 中进行设置）（secondary 设置中间表的连接）    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))* 需要建立三个表格 article  tag  article_tag                                            article与tag 表格的建立与之前的一样.  article_tag 表格的建立：（db.Table 进行建立）      #关联表    article_tag = db.Table(&apos;article_tag&apos;,    db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),    db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)                   )    * 数据的插入：（ article1.article.append(tag1) 这个语句是重点）    article1 = Article(title = &apos;aaa&apos;)    article2 = Article(title = &apos;bbb&apos;)    tag1 = Tag(name = &apos;111&apos;)    tag2 = Tag(name = &apos;222&apos;)    #article1下有哪些标签  一个article1有多个标签（重点）    article1.article.append(tag1)    article1.article.append(tag2)    # article2下有哪些标签  一个article2有多个标签（重点）    article2.article.append(tag1)    article2.article.append(tag2)    db.session.add(article1)    db.session.add(article2)    db.session.add(tag1)    db.session.add(tag2)    db.session.commit()</code></pre><p>案例：连接数据库 创建表格包含中间表 插入数据 关联数据 实现通过文章找Tag(免去config文件)</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db= SQLAlchemy(app)&quot;&quot;&quot;SQL语句：    创建article表    create table article(        id int primary key autoincrement        title varachar(100) not null    )    创建tag表    create table tag(        id int primary key autioncrement        name varachar(50) not null    )    创建中间表    create table article_tag(        article_id int        tag_id int        primay key (&apos;article_id&apos;,&apos;tag_id&apos;)        foreign_key &apos;article_id&apos; references &apos;article&apos;        foreign_key &apos;tag_id&apos; references &apos;tag&apos;    )&quot;&quot;&quot;#关联表article_tag = db.Table(&apos;article_tag&apos;,        db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),        db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)                       )class Article(db.Model):    __tablename__ = &apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    #这是外键的是指 以及表的关联过程  secondary    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))class Tag(db.Model):    __tablename__ = &apos;tag&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    name = db.Column(db.String(50),nullable=False)db.create_all()@app.route(&apos;/&apos;)def hello_world():    &apos;&apos;&apos;    article1 = Article(title = &apos;aaa&apos;)    article2 = Article(title = &apos;bbb&apos;)    tag1 = Tag(name = &apos;111&apos;)    tag2 = Tag(name = &apos;222&apos;)    #article1下有哪些标签  一个article1有多个标签    article1.article.append(tag1)    article1.article.append(tag2)    # article2下有哪些标签  一个article2有多个标签    article2.article.append(tag1)    article2.article.append(tag2)    db.session.add(article1)    db.session.add(article2)    db.session.add(tag1)    db.session.add(tag2)    db.session.commit()    &apos;&apos;&apos;    article1= Article.query.filter(Article.title == &apos;aaa&apos;)[0]    tags = article1.article    for tag in tags:        print(tag.name)    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run(debug=True)</code></pre><hr><p>8.在分开models中解决循环引用<br>     分开models 的目的： 是为了更好的管理代码<br>     解决循环引用的方法：  是将add文件 分割开来  可以同时被几个文件引用 不会产生循环</p><pre><code>models.sep文件：（主文件）    from flask import Flask    # 引入models中的 Ariticle    from models import Ariticle    # 引入exts中的db    from exts import db    app = Flask(__name__)    #防止循环引用 初始化app    db.init_app(app)    db.create_all()    @app.route(&apos;/&apos;)    def hello_world():        return &apos;Hello World!&apos;    if __name__ == &apos;__main__&apos;:        app.run()exts文件：    from flask_sqlalchemy import SQLAlchemy    db = SQLAlchemy()models.py 文件：    #引入exts 中的 db    from exts import db    class Ariticle(db.Model):        __table__ = &apos;article&apos;        id = db.Column(db.Integer, primary_key=True, autoincrement=True)        title = db.Column(db.String(100), nullable=False)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.MySQL-python中间件的介绍和安装&lt;br&gt;     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装&lt;br&gt;     * 在window下需要到’&lt;a href=&quot;https://www.lfd.uci.edu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask--urls和视图</title>
    <link href="http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/</id>
    <published>2020-02-02T09:32:35.000Z</published>
    <updated>2020-02-03T12:21:47.286Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.对代码的解析：#encoding UTF-8#模块的导入from flask import Flask#初始化一个Flask对象#Flask()#需要传递一个参数__name__#1. 方便flask框架去寻找资源#2. 方便flask插件 比如Flask-Sqlalchemy出现错误的时候，去寻找问题所在的位置app = Flask(__name__)# @app.route是一个装饰器# @开头，并且在函数的上面，说明是一个装饰器# 这个装饰器的作用，是做一个URL与视图函数的映射# 127.0.0.1:5000/  去请求hello_woeld 这个函数  然后将结果返回到浏览器@app.route(&apos;/&apos;)def hello_world():    return &apos;我是第一个程序&apos;# 如果当前这个文件是作为入口程序进行运行， 那么就执行app.run()if __name__ == &apos;__main__&apos;:    #app.run()    #启动一个应用服务器  来接受用户的请求    #while True    #   listen()    #设置debug模式  将错误直接显示到网页上面    app.run(debug= True)2.设置debug模式    a.在app.run()中传入一个关键字参数debug,例如：run(debug = Ture)，就设置当前项目为debug模式。    b.debug模式的两大功能：        * 当程序出现问题的时候，可以在页面中看到错误的信息和出错的位置        * 只要修改项目中的python文件，程序就会自动的加载，不需要手动的重新启动服务器。      具体的案例如下：          from flask import Flask        app = Flask(__name__)        @app.route(&apos;/&apos;)        def hello_world():            return &apos;我是第一个程序&apos;        if __name__ == &apos;__main__&apos;:            #设置debug模式  将错误直接显示到网页上面            app.run(debug= True)3.使用配置文件    * 新建一个&apos;config.py&apos;文件    * 在主要的app文件中导入这个文件，并且配置到app文件中        &apos;&apos;&apos;        import config        app.config.from_object(config)        &apos;&apos;&apos;    * 还有许多的其他参数也可以放置在文件中，比如&apos;SECRET_KEY&apos; 和 &apos;SQLALCHEMY&apos;这些配置文件    主app文件实例如下：（其实主要的作用还是和debug模式一样的作用）        from flask import Flask        #导入config文件        import config        app = Flask(__name__)        #加入config文件的配置        app.config.from_object(config)        @app.route(&apos;/&apos;)        def hello_world():            return &apos;我是第一个程序&apos;        if __name__ == &apos;__main__&apos;:            app.run()    config文件的配置：（可以加入很多的参数 注意的是需要将文件导入和对文件配置的导入使用）        DEBUG = True4.url传递参数    * 参数的作用： 可以在相同的URL，当时不指定相同的参数，来加载不同的数据。                例如：http://127.0.0.1:5000/URL/参数            * 在flask中如何使用参数：        &apos;&apos;&apos;            @app.route(&apos;/article/&lt;id&gt;&apos;)            def article(id):                return &apos;您请求的参数是 ： %S&apos; % id        &apos;&apos;&apos;           注意：参数必须放在&lt;&gt;中                    视图函数中需要放在和URL中的id相同的参数（就是函数括号里面的参数必须与id相同）    url传递参数的例子：            from flask import Flask            app = Flask(__name__)            #视图函数            @app.route(&apos;/login/&lt;id&gt;&apos;)            def login(id):                return &quot;您请求的参数是 % S&quot; % id            if __name__ == &apos;__main__&apos;:                app.run(debug=True)5.URL反转（需要一个模板：url_for）    * 什么叫做反转URL： 从视图函数到url的转换叫做反转URL      （根据视图的函数名字 可以直接切换到URL的参数）    * 反转URL的用处：        * 在页面重定向的时候，会使用url反转        * 在模板中，也会使用url反转    Url反转例子：            from flask import Flask,url_for            app = Flask(__name__)            @app.route(&apos;/&apos;)            def index():                print(url_for(&apos;my_list&apos;))                print(url_for(&apos;question&apos;),id = &quot;aaaa&quot;)                return &apos;这是首页&apos;            @app.route(&apos;/list/&apos;)            def my_list():                return &quot;这是登陆页面&quot;            @app.route(&apos;/question/&lt;id&gt;&apos;)            def question(id):                return &apos;这是发布问答的页面:%S&apos; % id            if __name__ == &apos;__main__&apos;:                app.run(debug= True)6.重定向和页面跳转：(需要两个模板： redirect  url_for)    * 用处： 在用户访问一些需要登陆的页面的时候，如果用户没有登陆用户则会跳转到用户的登陆界面    * 代码的实现：        &apos;&apos;&apos;            from flask import redirect,url_for            redirect(url_for(&apos;login&apos;))        &apos;&apos;&apos;    重定向和页面跳转的代码演示：        from flask import Flask,redirect,url_for        app = Flask(__name__)            @app.route(&apos;/&apos;)            def index():                   question_url = url_for(&apos;question&apos;,id = 1)                   return redirect(question_url)                   return &apos;这是首页&apos;            @app.route(&apos;/login/&apos;)            def login():                return &quot;这是登陆页面&quot;            @app.route(&apos;/question/&lt;id&gt;&apos;)            # 关键点   条件性代码            def question(id):                if id==&quot;1&quot;:                    return &apos;这是发布问答的页面&apos;                else:                    return redirect(url_for(&quot;login&quot;))            if __name__ == &apos;__main__&apos;:                app.run(debug=True)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1.对代码的解析：
#encoding UTF-8
#模块的导入
from flask import Flask
#初始化一个Flask对象
#Flask()
#需要传递一个参数__name__
#1. 方便flask框架去寻找资源
#2. 方便flask插
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo的基本操作</title>
    <link href="http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-01-24T05:11:04.000Z</published>
    <updated>2020-02-04T05:28:06.746Z</updated>
    
    <content type="html"><![CDATA[<p>1.创建一个新的文件：<br>                hexo new post 文件名<br>                hexo new [layout(布局)] -p 路径 文件名</p><p>2.上传到网页并且进行部署（同时出现在GitHub上面）:<br>                hexo d -g</p><p>3.注意：在文档中有渲染的语法，或则有重定向的语法就会报错<br>        Template render error<br>        则需要进行注释或者标注</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.创建一个新的文件：&lt;br&gt;                hexo new post 文件名&lt;br&gt;                hexo new [layout(布局)] -p 路径 文件名&lt;/p&gt;
&lt;p&gt;2.上传到网页并且进行部署（同时出现在GitHub上面）:&lt;
      
    
    </summary>
    
    
    
      <category term="Li jian" scheme="http://yoursite.com/tags/Li-jian/"/>
    
  </entry>
  
</feed>

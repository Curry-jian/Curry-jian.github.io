<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry-jian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-09T11:29:53.255Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>li jian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask-jinja</title>
    <link href="http://yoursite.com/2020/02/09/Flask-jinja/"/>
    <id>http://yoursite.com/2020/02/09/Flask-jinja/</id>
    <published>2020-02-09T07:48:18.000Z</published>
    <updated>2020-02-09T11:29:53.255Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.如何渲染Jinja2模板和传参：(主要是 &apos;render_template&apos;函数)* 渲染模板：    * 模板放在 templates 文件夹下面    * 从 flask 中导入 render_template 函数    * 在视图函数中，使用 render_template    #注意：在templates文件夹下面没有其他文件夹的话可以直接render_template(文件名)* 模板传参数：    * 如果只有一个或则少量参数的时候，可以直接在render_template函数中添加关键字就好         #   return render_template(&apos;index.html&apos;,&apos;user&apos; = &apos;username&apos;)    * 如果有多个参数的时候就需要把参数放入一个字典中，然后在&apos;render_template&apos;中使用**    把字典中的参数传递    &apos;&apos;&apos;            @app.route(&apos;/&apos;)            def index():                context = {                    &apos;username&apos;:&apos;李坚&apos;,                    &apos;gender&apos;:&apos;男&apos;,                    &apos;age&apos;: 18                }                return render_template(&apos;index.html&apos;,**context)    &apos;&apos;&apos;* 在模板中，如果需要使用变量，语法是&apos;{{params}}&apos;                &lt;p&gt;用户名：&apos;{{ username }}&apos;&lt;/p&gt;        * 在访问类的属性或则是字典或则是列表的时候，可以通过&apos;{{params.proper}}&apos;的形式，或则是&apos;{{params[]}}&apos;                   &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;模板的渲染和传参的实例：    from flask import Flask,render_template    app = Flask(__name__)    @app.route(&apos;/&apos;)    def index():        context = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;gender&apos;:&apos;男&apos;,            &apos;age&apos;: 18        }        return render_template(&apos;index.html&apos;,**context)    if __name__ == &apos;__main__&apos;:        app.run(debug= True)Jinja模板：        &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        这是HTML文件中的文字        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;模板的渲染和传参的实例：（含有类的例子）    from flask import Flask,render_template    app = Flask(__name__)    @app.route(&apos;/&apos;)    def index():        class Preson(object):            name = &apos;李坚&apos;            age = 20        p = Preson()        context = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;gender&apos;:&apos;男&apos;,            &apos;age&apos;: 18,            &apos;person&apos;: p        }        return render_template(&apos;index.html&apos;,**context)    if __name__ == &apos;__main__&apos;:        app.run(debug= True)Jinja模板：        &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        这是HTML文件中的文字        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;        &lt;hr&gt;        &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;        &lt;p&gt;年您：{{ person.age }}&lt;/p&gt;        &lt;/hr&gt;    &lt;/body&gt;    &lt;/html&gt;2.if判断语句* 语法格式：（Jinja模板中）    {% if xxx %}{% else %}{% endif %}if判断语句的具体实例（根据id的不同显示不同的页面）from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&lt;id&gt;/&apos;)def index(id):    if id == &apos;1&apos;:        user = {            &apos;username&apos;:&apos;李坚&apos;,            &apos;age&apos; : 10        }    return render_template(&apos;index2.html&apos;,user=user)if __name__ == &apos;__main__&apos;:    app.run(debug= True)&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    {% if user %}        <a href="#">{{ user.username }}</a>        <a href="#">注销</a>    {% else %}        <a href="#">登陆</a>        <a href="#">注册</a>    {% endif %}&lt;/body&gt;&lt;/html&gt;3.for循环遍历列表和字典：* 字典的遍历和语法与&apos;python&apos;一样，可以使用&apos;item()&apos; &apos;keys()&apos; &apos;values()&apos;等函数    {% for k,v in user.item() %}<p>{{ k }}:{{ v }}</p>{% endfor %}* 列表的遍历：    {% for webisit in webisits %}<p>{{ webisit }}</p>{% endfor %}for循环的案例：（四大名著的表格排序）from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    books=[        {            &apos;name&apos;:&apos;西游记&apos;,            &apos;author&apos;:&apos;吴承恩&apos;,            &apos;price&apos;:&apos;100&apos;        },        {            &apos;name&apos;:&apos;红楼梦&apos;,            &apos;author&apos;:&apos;曹雪芹&apos;,            &apos;price&apos;:&apos;50&apos;        },        {            &apos;name&apos;:&apos;三国演义&apos;,            &apos;author&apos;:&apos;罗贯中&apos;,            &apos;price&apos;:&apos;150&apos;        },        {            &quot;name&quot;:&apos;水浒传&apos;,            &quot;author&quot;:&apos;施耐庵&apos;,            &quot;price&quot;:200        }    ]    return render_template(&apos;index2.html&apos;,books=books)if __name__ == &apos;__main__&apos;:    app.run(debug= True)Jinja模板&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;th&gt;书名&lt;/th&gt;            &lt;th&gt;作者&lt;/th&gt;            &lt;th&gt;价格&lt;/th&gt;        &lt;/thead&gt;        &lt;tbody&gt;        {% for book in books %}            <tr>                <td>{{book.name}}</td>                <td>{{book.author}}</td>                <td>{{book.price}}</td>            </tr>        {% endfor %}        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;4.过滤器：    * 介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来（就是设置一个默认的，然后再用户没有设置的时候就可以直接过滤 输出默认的值）* 语法：     {{ avater(用户输入的值的名字) | default（过滤器）('xxx')}}* default（过滤器）:如果当前变量不存在的时候，这个时候就可以指定默认值* length: 求列表或则字符串或则字典 元组的长度过滤器的例子：（将图片的参数进行传递 ）    from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    return render_template(&apos;index2.html&apos;,family=&apos;https://avatars2.githubusercontent.com/u/60211293?s=40&amp;v=4&apos;)if __name__ == &apos;__main__&apos;:    app.run(debug= True)Jinja模板：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;过滤器的例子：（关于评论的显示 ）Jinja模板：    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;Title&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;    &lt;hr&gt;    &lt;p&gt;评论数:({{comments|length}})&lt;/p&gt;    &lt;ul&gt;        {% for comment in comments %}        <li>            <a href="#">{{comment.user}}</a>            <p>{{ comment.content }}</p>        </li>    {% endfor %}    &lt;/ul&gt;    &lt;/body&gt;    &lt;/html&gt;python文件：from flask import Flask,render_templateapp = Flask(__name__)@app.route(&apos;/&apos;)def index():    comments = [        {            &apos;user&apos;: &apos;李建安&apos;,            &apos;content&apos;:&apos;xxx&apos;        },        {            &apos;user&apos;: &apos;李坚&apos;,            &apos;content&apos;:&apos;xxx&apos;        }    ]    return render_template(&apos;index2.html&apos;,comments=comments)if __name__ == &apos;__main__&apos;:    app.run(debug= True)5.继承和block块* 作用：可以把一些公共的代码放在父模板中（base.HTML）文件* 语法：#    {% extend 'base.html'%}block 实现：    * 作用：可以让子模版实现自己的需求，父模板需要提前定义好    * 注意：子模板中的代码必须放在block块中，不然没有效果    具体的block语法例子：{% block 模块名 %}{% endblock %}继承和block的具体实例：py文件：from flask import Flask,render_templateapp = Flask(__name__)@app.route('/')def index():    return render_template('index.html')@app.route('/login/')def login():    return render_template('login.html')if __name__ == '__main__':    app.run(debug= True)base.html 文件： <!DOCTYPE html>   <html lang="en"><head>    <meta charset="UTF-8">    <title>{% block title %}{% endblock %}&lt;/title&gt;            &lt;style&gt;            .nav{                background: #3a3a3a;                height: 65px;            }            ul{                overflow: hidden;            }            ul li{                float: left;                list-style: none;                padding: 0 10px;                line-height: 65px;            }            ul li a{                color: white;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;nav&quot;&gt;        &lt;ul&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发布问答&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    {% block main %}{% endblock %}</body></html>login.html:{% extends 'base.html' %}{% block title %}    登陆页面{% endblock %}        {% block main %}    <p>这是登陆页面</p>{% endblock %}    index.html:        {% extends 'base.html' %}        {% block title %}    首页{% endblock %}        {% block main %}    <p>这是首页面</p>{% endblock %}6.URL链接和加载静态文件    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径    * 可以加载css文件，js文件 image文件    image文件：    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;    js文件：     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;    css文件：    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;*url链接：使用url_for(视图函数名)，从而反转url 跳转页面        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;url链接和加载静态文件的例子：    Py文件：        from flask import Flask,render_template        app = Flask(__name__)        @app.route(&apos;/&apos;)        def index():            return render_template(&apos;index.html&apos;)        @app.route(&apos;/login/&apos;)        def login():            return render_template(&apos;login.html&apos;)        if __name__ == &apos;__main__&apos;:            app.run(debug=True)    index.html文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;        &lt;/body&gt;        &lt;/html&gt;    index.js文件：        /**         * Created by 栩森 on 2020/2/4.         */        alert(&apos;我是李坚&apos;)    index.css文件：           a{                background: red;            }    login.html 文件：        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;Title&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;h1&gt;这是登陆页面&lt;/h1&gt;        &lt;/body&gt;        &lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1.如何渲染Jinja2模板和传参：(主要是 &amp;apos;render_template&amp;apos;函数)

* 渲染模板：
    * 模板放在 templates 文件夹下面
    * 从 flask 中导入 render_template 函数
  
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端学习随笔记录</title>
    <link href="http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-09T02:55:00.000Z</published>
    <updated>2020-02-09T07:45:13.671Z</updated>
    
    <content type="html"><![CDATA[<p>1.css样式中：<br>    * id选择器： #id<br>    * class选择器： .class<br>    * 普通选择器： <h><br>    * 注意：如果想优先使用一个样式：在样式后面加入 ！important<br>    * 浮动： float left 左浮动  是将两行的东西放到同一行<br>            float right 右浮动  是将两行的东西放到同一行</p><hr><p>2.盒子模型：<br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>    Border(边框) - 围绕在内边距和内容外的边框。<br>    Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>    Content(内容) - 盒子的内容，显示文本和图像。</p><hr><p>3.css选择器<br>    * 分组选择器: h1,p1,h2<br>    * 后代选择器：.class p        .class div p<br>    * 相邻选择器 ： div+p<br>    * 普通兄弟选择器： div~p<br>    * 包含title属性对象选择器： [title],[id]<br>    * 伪类选择器： 标签名：自己定义的名字（使有相同的标签名的css精细化）</p><hr><p>4.javascript：具有动态交互的时，需要使用的语言<br>    * 在函数中定义参数的时候 有var时就是局部变量  没有的是的就是全局变量<br>        function func01(){<br>            var func01 = a<br>    }</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.css样式中：&lt;br&gt;    * id选择器： #id&lt;br&gt;    * class选择器： .class&lt;br&gt;    * 普通选择器： &lt;h&gt;&lt;br&gt;    * 注意：如果想优先使用一个样式：在样式后面加入 ！important&lt;br&gt;    * 浮动： float
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask-Migrate</title>
    <link href="http://yoursite.com/2020/02/08/Flask-Migrate/"/>
    <id>http://yoursite.com/2020/02/08/Flask-Migrate/</id>
    <published>2020-02-08T12:03:10.000Z</published>
    <updated>2020-02-08T12:25:28.437Z</updated>
    
    <content type="html"><![CDATA[<p>1.Flask-Migrate的作用：（代码在models_Migrate文件中）<br>    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，<br>    如果需要修改就必须要先删除表格。<br>    Flask-migrate就是为了解决不能在表格中添加或者修改内容的作用，可以解决在修改模型后<br>    直接映射到表中。</p><p>2.下载安装Flask-Migrate ： pip install flask-migrate</p><p>3.flask-migrate必须要借助 flask-script ，这个包中MigrateCommand 中的关于数据库的命令</p><p>4.flask-migrate 相关的命令：<br>    * python manage.py db init : 初始化迁移脚本的环境 只需要执行一次<br>    * python manage.py db migrate 生成迁移文件，每次修改都要执行<br>    * pythin manage.py db upgrade 将迁移的文件映射到数据中 每次需改都需要运行一次</p><p>5.要将数据库中的模型 madols.py 导入到manage文件中，这样才会找到相关的模块</p><p>6.各个文件的代码：<br>    config.py （同之前的一样）</p><pre><code>models_Migrate.py文件 ：    from flask import Flask    # 引入exts中的db    from exts import db    import config    from models import Aritcle    app = Flask(__name__)    app.config.from_object(config)    #防止循环引用 初始化app    db.init_app(app)    &apos;&apos;&apos;    #手动将app推到服务器的栈里面（重点）    with app.app_context():        #这里通过db 将 models文件放入其中了（重点）        db.create_all()    &apos;&apos;&apos;    @app.route(&apos;/&apos;)    def hello_world():        return &apos;Hello World!&apos;    if __name__ == &apos;__main__&apos;:        app.run(debug=True)manage.py文件（重点）    from flask_script import Manager    from models_Migrate import app    from flask_migrate import Migrate,MigrateCommand    from exts import db    from models import Aritcle    manage = Manager(app)    #1.要使用flasj_migrate 必须绑定app和db    migrate = Migrate(app,db)    #2. 把MigrateCommand 命令添加到 manager中    manage.add_command(&apos;db&apos;,MigrateCommand)    if __name__ == &apos;__main__&apos;:        manage.run()exts.py文件：（是为了防止循环应用app）    from flask_sqlalchemy import SQLAlchemy    db = SQLAlchemy()models.py 文件：    #引入exts 中的 db    from exts import db    class Aritcle(db.Model):        id = db.Column(db.Integer,primary_key=True,autoincrement=True)        title = db.Column(db.String(100),nullable=False)        content = db.Column(db.Text,nullable=False)        tags = db.Column(db.String(100),nullable=False)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.Flask-Migrate的作用：（代码在models_Migrate文件中）&lt;br&gt;    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，&lt;br&gt;    如果需要修改就必须要先删除表格。&lt;br&gt;    Flask-m
      
    
    </summary>
    
    
    
      <category term="代码在models_Migrate文件中" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>Flask-Script</title>
    <link href="http://yoursite.com/2020/02/07/Flask-Script/"/>
    <id>http://yoursite.com/2020/02/07/Flask-Script/</id>
    <published>2020-02-07T11:50:40.000Z</published>
    <updated>2020-02-07T13:57:36.128Z</updated>
    
    <content type="html"><![CDATA[<p>Flask-Script的用处：<br>    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的<br>    服务器，设置数据库，定时任务等<br>Flask-Script的安装 ：     pip install flask-script  操作命令进行安装    </p><p>flask-Script :在创建好flask项目后 要在创建一个主文件manage.py<br>        manage.py的文件内容：</p><pre><code>#导入script的 Manager文件from flask_script import Manager#导入flask_scripr_demo文件中 appfrom flask_script_demo import app#初始化managemanage = Manager(app)#在命令行中可以执行的命令 装饰器@manage.commanddef runserver():    print(&quot;服务器启动&quot;)#因为是作为主app文件  则需要一下代码if __name__== &apos;__main__&apos;:    manage.run()</code></pre><p>在cmd运行命令的方法（必须在项目的目录下）<br>        python manage.py runserver<br>            显示：服务器启动</p><p>flask_script中有一集中控制数据库命令的文件db_script</p><pre><code>manage.py 中的内容：    #导入script的 Manager文件    from flask_script import Manager    #导入flask_scripr_demo文件中 app    from flask_script_demo import app    #导入文件db_script 文件中的DBmanager对象    from db_script import DBmanager    #初始化manage    manage = Manager(app)    #在命令行中可以执行的命令 装饰器    @manage.command    def runserver():        print(&quot;服务器启动&quot;)    #将db_script.py中的命令放到主app中来    manage.add_command(&apos;db&apos;,DBmanager)    #因为是作为主app文件  则需要一下代码    if __name__== &apos;__main__&apos;:        manage.run()db_script中的内容：    #导入flask_script文件 中的manager    from flask_script import Manager    #初始化    DBmanager = Manager()    #设置命令    @DBmanager.command    def init():        print(&quot;初始化服务器&quot;)    @DBmanager.command    def migrate():        print(&quot;迁移成功&quot;)</code></pre><p>在cmd中运行的语句： python manage.py db init<br>                     显示结果：初始化服务器成功</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flask-Script的用处：&lt;br&gt;    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的&lt;br&gt;    服务器，设置数据库，定时任务等&lt;br&gt;Flask-Script的安装 ：     pip install fla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python做题时发现的问题</title>
    <link href="http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-06T02:40:56.000Z</published>
    <updated>2020-02-10T14:04:41.584Z</updated>
    
    <content type="html"><![CDATA[<hr><p>1.枚举函数的使用：enumerate()<br>    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)<br>    具体用用法实例:</p><pre><code>类型一：    tmplist = [1234, 5677, 8899]    for index,app_id in enumerate(tmplist):        print index, app_id    输出：     0 1234     1 5677     2 8899类型二：（从下标1开始取值）    tmplist = [1234, 5677, 8899]    for index,app_id in enumerate(tmplist, 1):        print index, app_id    输出：     1 1234     2 5677     3 8899类型三：使用range()或xrange()         tmplist = [1234, 5677, 8899]            for i in range(len(tmplist)):                  print i,tmplist[i]        输出：         0 1234         1 5677         2 8899</code></pre><hr><p>2.关于def add(x, y) -&gt; int:中符号-&gt;的意思：<br>-&gt;常常出现在python函数定义的函数名后面，为函数添加元数据,描述函数的返回类型，从而方便开发人员使用<br>    简而言之就是这个函数返回的类型会是 int 类型，如果不是可以强制性进行转换为int类型</p><ul><li>-&gt;  _Attr则表明函数返回的是一个外部可访问的类的私有变量</li></ul><hr><p>3.进制转化器：<br>    bin:二进制   cot:八进制   int:十进制  hex:十六进制</p><hr><p>4.Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数   decimal(小数)<br>     * 从浮点数据转换为Decimal类型<br>        #导入模块<br>        from decimal import getcontext,Decimal,Context<br>        mydec = Decimal.from_float(12.222)<br>        print(mydec)<br>        #结果为  12.222153432115212315……..精准的数字<br>    *  从字符串转化为Decimal类型<br>        mydec = Decimal(‘3.14’)<br>        print(mydec)<br>    * raw  将转义字符原样输出  r”hello\tworld”</p><hr><p>5.字符串（列表）里面的切片操作和下标取值操作（重点：包含开始 不包含结束）（切片没有下标越界）<br>    * 语法：[start:stop:step]  start:开始字符  stop:结束字符  step:步长  （其值可以省略）<br>    * step &gt; 0，从左往右切片       step &lt;0，从右往左切片<br>    * 左[0,1,2,3,……]   右[…….,-4-3,-2,-1]<br>    *  my_str=”mystr”<br>       print(my_str.count(‘m’))  查看字符串里面右几个m  也可以指定字符串的长度进行查看<br>       print(my_str.count(‘m’，1，3))     </p><hr><p> 6.判断字符是否为纯数字组成  str.isdigit()<br>   判断字符串是否为大写    str.isupper()<br>   判断字符串是否只包含字母： str.isalpha()<br>   判断字符串里的单词是否开头大写其他地方小写： str.istitle()<br>   判断字符串是否只只包含字母或者数字： str.isalnum()</p><p>   将字符串转换为大写： str.upper()<br>   将字符串转换为小写： str.lower()<br>   将字符中的单词第一字母大写其他字母小写 ：str.title()<br>   指定sep作为分割符号 将字符串切割成列表，分隔符可以任意设置（默认为空格）：<br>                           str.spilt(‘sep’)<br>       将列表用str拼接成一个大的字符串： ‘str’.join(list)(用str来拼接字符串)<br>       去除字符串中首尾的字符串，不带参数默认去除空格： str.strip([string])<br>       将字符串里的一个字符进行替代： str.replace(‘old’’new’[替换的个数])<br>       将字符中间对齐: str.center(witdth,’填充符号’)<br>       将字符左对齐:str.ljust(witdth,’填充符号’)<br>       将字符右对齐:str.rjust(witdth,’填充符号’)</p><pre><code>end 是可以表示最后字符串末尾的方式    end=&apos;&apos; 表示用空字符来连接字符</code></pre><hr><p>7.字符串格式化：<br>    {变量：[填充字符][对齐方式&lt;^&gt;][宽度][格式]}.format()</p><hr><p>8.math 模块 : import math<br>              math.方法<br>  getpass 模块： import getpass   隐藏密码的模块<br>                  getpass.getpass(“输入密码”)<br>  random模块： 随机生成一个范围内的数字<br>                  random.randint(0,100)  随机取0~100中的一个数字</p><hr><p>9.分支语句（if的三元运算）<br>    reslut = 条件成立的结果 if 条件 else 条件不成立的结果</p><hr><p>10.while语句：<br>    是符合该条件的情况下才会执行(注意 是需要一个结束的语句) 下面相关的内容<br>    while 条件：<br>        do sth<br>        break<br>    continue: 是指跳到循环的开头<br>    break: 表示退出循环</p><hr><p>11.for循环语句：<br>    for item in rang(3):<br>        do sth<br>    表循环几次  指定循环的次数</p><hr><ol start="12"><li>自增长问题：<br>a+=i : a = a+1<br>a-=1 : a = a-1<br>自有在for循环语句中遍历出数字来 才能实现自增长的作用</li></ol><hr><p>13.find()函数的用法：<br>    find()方法检测字符串S中是否包含子字符串sub，如果指定start（开始）和end（结束）范围，<br>    则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值(如果包含多个字串，只返回最左边出现的索引值)，查找失败返回-1。<br>    以本题为例：<br>    s=”abcd1234”<br>    s.find(“cd”)，在字符串s中查找字串”cd”第一次出现时s中的索引值，因为索引从0开始，所以结果为2，注意s中出现多次cd的情况，例如：<br>    s=”abcd1234cd”<br>    s.find(“cd”)的结果依然是2，找不到时返回-1，比如：<br>    s=”1234”<br>    s.find(“cd”)的结果为-1</p><hr><p>14.zip()函数的用法：<br>    该函数配合 for循环语句进行使用  for i in zip(* 列表)<br>    具体的用法例子演示：</p><pre><code>&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; a = [&quot;abc&quot;, &quot;abd&quot;, &quot;bbb&quot;]&gt;&gt;&gt; b = zip(a)&gt;&gt;&gt; for each in b:...     print(each)...(&apos;abc&apos;,)(&apos;abd&apos;,)(&apos;bbb&apos;,)如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表&gt;&gt;&gt; b = zip(*a)&gt;&gt;&gt; for each in b:...     print(each)...(&apos;a&apos;, &apos;a&apos;, &apos;b&apos;)(&apos;b&apos;, &apos;b&apos;, &apos;b&apos;)(&apos;c&apos;, &apos;d&apos;, &apos;b&apos;)</code></pre><hr><p>15.set函数的使用（目前使用到的是他的去重的作用）<br>    x = set(‘worlld’)<br>    print(x):{‘r’,’o’,’l’,’w’,’d’}(形成了一个集合 并且去除了重复的项)<br>    还可以使用add和update对集合进行修改和添加</p><hr><p>16.python中随机生成一个数的函数：<br>    import random<br>    print(random.random())<br>    输出结果：0.9437475481805455</p><hr><p>17.python中format函数 ：<br>    一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能：</p><pre><code>print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))# 通过字典设置参数site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}print(&quot;网站名：{name}, 地址 {url}&quot;.format(**site))网站名：菜鸟教程, 地址 www.runoob.com# 通过列表索引设置参数my_list = [&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;]print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))  # &quot;0&quot; 是必须的网站名：菜鸟教程, 地址 www.runoob.com</code></pre><hr><p>18.pack和unpack<br>    星号具有打包的功能 a,*b = (1,2,3,4,5) =&gt; a = 1  b = [2,3,4,5]</p><hr><p>19.匿名函数： 不需要命名的函数 只能有一个表达式 不用写return（一次性使用）<br>    lambda arg1(参数1) ，arg2(参数2):表达式（要返回的数据）</p><hr><p>20.sorted(iterable,key,reverse) 函数 ： 起到排序的作用<br>    key -&gt; 是指定一个排序的方式(可以放入函数)   iterable -&gt;是变量名  reverse -&gt; 是否逆序<br>            .join的作用是排列方式用 ‘’来隔开<br>     例子： mystr = “aaAbmcDikLNog”<br>           print(‘’.join(sorted(mtstr,key=str.upper)))</p><hr><ol start="21"><li>在字符串中的replace函数：<br>replace()方法语法：str.replace(old, new,[max])<br>参数:<pre><code>old -- 将被替换的子字符串。new -- 新字符串，用于替换old子字符串。max -- 可选字符串, 替换不超过 max 次</code></pre>例子：<pre><code>str = &quot;this is string example....wow!!! this is really string&quot;;print str.replace(&quot;is&quot;, &quot;was&quot;）结果-&gt;thwas was string example....wow!!! thwas was really string</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;1.枚举函数的使用：enumerate()&lt;br&gt;    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)&lt;br&gt;    具体用用法实例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;类型一：
    tmplist
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask-SQLAlchemy-DateBase</title>
    <link href="http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/"/>
    <id>http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/</id>
    <published>2020-02-04T07:21:13.000Z</published>
    <updated>2020-02-08T12:02:08.428Z</updated>
    
    <content type="html"><![CDATA[<p>1.MySQL-python中间件的介绍和安装<br>     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装<br>     * 在window下需要到’<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;</a><br>      这个网址下载对应的python版本的中间件<br>          对应的命令： pip install mysqlclient-1.4.6-cp38-cp38-win_amd64.whl<br>     * 注意：如果与python的版本不符合就会出现报错的现象</p><p>2.ORM与Flask-SQLALchemy的安装和介绍<br>    * ORM: Objct Relationship Mapping (模型关系映射)<br>    * flask-aqlalchemy是一套ORM框架<br>    * ORM的好处：可以不适用sql语句进行对数据的修改 ，可以直接使用类的语句就好.一个表<br>        就是一个类，一条数据就是一个对象<br>    * 安装Flask-SQLALchemy： pip install flask-sqlalchemy</p><pre><code>例子： class Ariticle(Moble):        id = int()        title = String()        content = Text()       #实例化           article = Article(id = 1,title = &apos;aaa&apos;,content = &apos;bbb&apos;)       #加入表格或者说类中            add(article)       #修改数据内容             article.title = &apos;ccc&apos;             update(article)       #删除内容             delete(article)</code></pre><p>3.SQLALchemy连接数据库<br>    SQLALchemy :SQLAlchemy采用简单的Python语言，为高效和高性能的数据库访问设计<br>                是访问和操作数据库的开源脚本<br>    * 在实际操作过程中遇到的问题：<br>        * 在Mysql workbeath 中修改连接密码：右键出现Edit connections 进行点击 进入后点击store in Vault 就可以进行修改<br>        * 如何进入Mysql 命令行的形式：找到Mysql sever 下的bin目录 再就如命令行输入<br>            ./mysql -u root -p<br>        * 创建一个新的数据库 命令     creat datebase  数据库名  charset  utf8<br>    使用flask_sqlalchemy中的SQLALchemy进行初始化：</p><pre><code>    #调用函数    from flask_sqlalchemy import SQLAlchemy    app = Flask(__name__)    #初始化一个对象    db = SQLAlchemy(app)设置配置文件&apos;config.py&apos;文件中添加一下配置#dialect+driver://username:password@host:post/database    DIALECT = &apos;mysql&apos;    DRIVER = &quot;mysqldb&quot;    USERNAME = &apos;root&apos;    PASSWORD = &apos;root&apos;    HOST = &apos;127.0.0.1&apos;    PORT = &apos;3306&apos;    DATABASE = &apos;db_demo1&apos;    SQLALCHEMY_DATABASE_URI = &quot;{}+{}://{}:{}@{}:{}/{}?charset=utf8&quot;.format(DIALECT,                                                   DRIVER,USERNAME,                                                   PASSWORD,HOST,PORT,                                                   DATABASE)    #去除警告信息    SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>   在app文件中，添加配置文件，并且进行测试</p><pre><code>from flask import Flask   #调用函数from flask_sqlalchemy import SQLAlchemy#引入config文件import configapp = Flask(__name__)#重点（不明白）app.config.from_object(config)#初始化一个对象db = SQLAlchemy(app)#进行测试db.create_all()</code></pre><p>4.SQLALchemy模型与表映射<br>    * 创建的这个表可以称作为一个类，这个类必须要继承自’db.Model’，然后映射到表中的时候<br>       必须写成’db.Column’的数据类型<br>    * 数据类型：<br>        * ‘db.Integer’代表的是整型（int）<br>        * ‘db.String’ 代表的是’varcher’,需要指定最长的长度<br>        * ‘db.Text’代表的是 ‘text’<br>    * 参数类型：<br>        * ‘primary_key’:代表的是将字段是否设置为主键<br>        * ‘autoincrement’: 代表的是这个主键是否为自增长的<br>        * ‘nullable’ : 表示该字段是否可以为空，数据库默认是能为空<br>    * 最后需要用’db.create_all’来将模型真正的创建到数据库中</p><p>   在实践过程中遇到的问题：</p><ul><li><p>对数据库的连接不熟练，以及配置文件的编写</p><pre><code>from flask import Flask</code></pre><p>   from flask_sqlalchemy import SQLAlchemy<br>   import config<br>   app = Flask(<strong>name</strong>)<br>   app.config.from_object(config)<br>   #初始化对象<br>   db = SQLAlchemy(app)</p><p>配置文件的编写：</p><h1 id="dialect-driver-username-password-host-post-database"><a href="#dialect-driver-username-password-host-post-database" class="headerlink" title="dialect+driver://username:password@host:post/database"></a>dialect+driver://username:password@host:post/database</h1><p>   DIALECT = ‘mysql’<br>   DRIVER = ‘mysqldb’<br>   USERNAME = ‘root’<br>   PASSWORD = ‘root’<br>   HOST = ‘127.0.0.1’<br>   POST = ‘3306’<br>   DATABASE = ‘db_mode2’<br>   SQLALCHEMY_DATABASE_URI = ‘{}+{}://{}:{}@{}:{}/{}?charset=utf8’.format(DIALECT,</p><pre><code>DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)</code></pre><p>   SQLALCHEMY_TRACK_MODIFICATIONS = False</p></li><li><p>在数据库中需要使用的语句：</p><pre><code>创建数据库： create database 数据库名 charset utf8查看数据库中的表 ： show tables 查看表的内容： desc 表名使用那个数据库： use 数据库名展现创建的表格： show create table 表名删除表格： drop table 表名</code></pre><ul><li><p>将SQL语句转化为py文件中类的语句<br>  ‘’’<br>SQL语句中创建表格<br>   create table article(</p><pre><code>id int primary key autoincrement,title varchar(100) not null,content text not null,</code></pre><p>   )<br>‘’’</p><p>class Article(db.Model):<br>   <strong>tablename</strong> =’article’<br>   id = db.Column(db.Integer,primary_key=True,autoincrement=True)<br>   title = db.Column(db.String(100),nullable=False)<br>   content = db.Column(db.Text,nullable=False)</p></li></ul></li></ul><p>创建一个表的例子：</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)#初始化对象db = SQLAlchemy(app)&apos;&apos;&apos;SQL语句中创建表格    create table article(        id int primary key autoincrement,        title varchar(100) not null,        content text not null,    )&apos;&apos;&apos;class Article(db.Model):    __tablename__ =&apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    content = db.Column(db.Text,nullable=False)db.create_all()@app.route(&apos;/&apos;)def hello_world():    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run()</code></pre><p>config 配置文件</p><pre><code># dialect+driver://username:password@host:post/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;mysqldb&apos;USERNAME = &apos;root&apos;PASSWORD = &apos;root&apos;HOST = &apos;127.0.0.1&apos;POST = &apos;3306&apos;DATABASE = &apos;db_mode2&apos;SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset=utf8&apos;.format(DIALECT,                               DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>5.SQLALchemy 数据库的增删查改</p><pre><code>#数据库增加数据    article = Article(title = &apos;aaa&apos;,content = &apos;bbb&apos;)    db.session.add(article)    #事务相应（操作的开关）    db.session.commit()#数据库查找数据    #SQL： select * from article where article.title=&apos;aaa&apos;;    #query:查找   fileter：过滤    article1 = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    #返回的是一个列表 之后的操作可以根据列表的操作进行    print(&apos;title:%s&apos; % article1.title)    print(&apos;content:%s&apos; % article1.content)#数据的修改    #1.先要查找出修改的数据    article1 = Article.query.filter(Article.title==&apos;aaa&apos;)[0,1]    #2.在需要修改的地方进行修改    article1.title = &apos;new title&apos;    #3.提交事务    db.session.commit()#删除数据    #1.把需要删除的数据查找出来    article1 = Article.query.filter(Article.content == &apos;bbb&apos;)[0]     #2.删除数据    db.session.delete(article1)    #3.事务处理    db.session.commit()</code></pre><p>6.Flask-SQLALchemy 外键及其关系<br>    * 连接数据库（跟以上的操作一样）<br>    * 创建两个表（user article）</p><pre><code> #创建用户表(user) &apos;&apos;&apos; SQL语句：         create table users(         id int primary key autoincrement,         username varchar(100) not null ) &apos;&apos;&apos; class User(db.Model):     __tablename__ = &apos;user&apos;     id = db.Column(db.Integer,primary_key= True,autoincrement=True)     username = db.Column(db.String(100),nullable=True)  #创建文章表     &apos;&apos;&apos;     SQL语句：             create table article(                 id int primary key autoincrement,                 title varchar(100) not null,                 content text not null,                 author_id int,                 foreign key &apos;author_id&apos; references &apos;user_id&apos;     )             &apos;&apos;&apos;     class Article(db.Model):         __tablename__ =&apos;article&apos;         id = db.Column(db.Integer,primary_key=True,autoincrement=True)         title = db.Column(db.String(100),nullable=False)         content = db.Column(db.Text,nullable=False)         #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)         author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    * 映射到数据库中：   db.create_all()        注意： db.create_all() 它只会部署一次，如果中途在类里面去需改表的属性是没有任何用处的，只有把表格进行删除，再        重新创建一个表格才能添加其他的属性* 在用户表中添加用户     user1 = User(username = &apos;lijian&apos;)     db.session.add(user1)     db.session.commit()</code></pre><ul><li><p>在文章表中添加文章</p><pre><code>article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)db.session.add(article)db.session.commit()</code></pre><ul><li><p>实现需求：查找文章名称为aaa的作者</p><pre><code>这是需求的普通写法:没有起到简化的作用 再Flask中不会使用    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author_id)    author_id = article.author_id    user = User.query.filter(User.id == author_id)[0]    print(user.username)再Flask-SQLALchemy-Darabases中使用的方法:    * 先要在class类中就行设置;            class Article(db.Model):            __tablename__ =&apos;article&apos;            id = db.Column(db.Integer,primary_key=True,autoincrement=True)            title = db.Column(db.String(100),nullable=False)            content = db.Column(db.Text,nullable=False)            #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)            author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    #重点：db.relationship是表述关系的连接参数  db.backre是表示关系反转的参数    #正向引用（relationship）与反向引用（backref）（User表与article表）        #正向关系：是只通过article表里面的外键来与User表中的主键进行连接             然后读取相关信息                #通过文章名称找出作者名称    #反转关系：是只通过User中的主键来连接article中的外键，然后读取article中的相关信息                 #通过作者找出他写作的文章    #模块名=db.relationship(&apos;关联的类名&apos;，backref = db.backref(&apos;自定义参数&apos;))            author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))    * 实现通过文章名称查找作者：            article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]            #通过 article.author.usename 来找出文章的作者            print(article.author.username)</code></pre><ul><li><p>实现需求：通过作者名找出其作品</p><pre><code>user = User.query.filter(User.username == &apos;lijian&apos;)[0]#通过 user.articles.title 来查找作者的文章result = user.articlesfor article in result:    print(article.title)</code></pre></li></ul></li></ul></li></ul><p>实例：数据库的连接 表的制作 数据的的添加 实现通过作者找出他的所有文章 通过文章找出作者</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)#创建用户表&apos;&apos;&apos;SQL语句：        create table users(        id int primary key autoincrement,        username varchar(100) not null)&apos;&apos;&apos;class User(db.Model):    __tablename__ = &apos;user&apos;    id = db.Column(db.Integer,primary_key= True,autoincrement=True)    username = db.Column(db.String(100),nullable=True)#创建文章表&apos;&apos;&apos;SQL语句：        create table article(            id int primary key autoincrement,            title varchar(100) not null,            content text not null,            author_id int,            foreign key &apos;author_id&apos; references &apos;user_id&apos;)        &apos;&apos;&apos;class Article(db.Model):    __tablename__ =&apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    content = db.Column(db.Text,nullable=False)    #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)    author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))    #正向引用（relationship）与反向引用（backref）    author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;)) #实现映射到表中db.create_all()##########@app.route(&apos;/&apos;)def hello_world():    &apos;&apos;&apos;    #在用户表中添加用户    user1 = User(username = &apos;lijian&apos;)    db.session.add(user1)    db.session.commit()    &apos;&apos;&apos;    #添加作品信息    &apos;&apos;&apos;    article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)    db.session.add(article)    db.session.commit()    &apos;&apos;&apos;    #需求：寻找标题文章为aaa的作者    &apos;&apos;&apos;    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author_id)    author_id = article.author_id    user = User.query.filter(User.id == author_id)[0]    print(user.username)    &apos;&apos;&apos;    #上述需求的简化:    #根据文章名称查找作者    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]    print(article.author.username)    print(&quot;*&quot;*20)    #需求 找到lijian写过的所有的文章    user = User.query.filter(User.username == &apos;lijian&apos;)[0]    result = user.articles    for article in result:        print(article.title)    &apos;&apos;&apos;    #先添加一篇文章    article = Article(title=&apos;111&apos;,content=&apos;222&apos;,author_id=1 )    db.session.add(article)    db.session.commit()    &apos;&apos;&apos;    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run(debug=True)</code></pre><p> 数据库连接的config 文件：</p><pre><code> #dialect+driver://username:password@host:post/databaseDIALECT = &apos;mysql&apos;DRIVER = &apos;mysqldb&apos;USERNAME = &apos;root&apos;PASSWORD = &apos;root&apos;HOST = &apos;127.0.0.1&apos;POST = &apos;3306&apos;DATABASE = &apos;db_demo3&apos;SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset utf8&apos;.format(DIALECT,                            DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><hr><p>7.SQLALchemy连接数据库中多对多关系<br>    * 配置相关的config 文件 与之前一样</p><pre><code>* 设置关联的语句（重点）（在class Aritcle 中进行设置）（secondary 设置中间表的连接）    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))* 需要建立三个表格 article  tag  article_tag                                            article与tag 表格的建立与之前的一样.  article_tag 表格的建立：（db.Table 进行建立）      #关联表    article_tag = db.Table(&apos;article_tag&apos;,    db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),    db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)                   )    * 数据的插入：（ article1.article.append(tag1) 这个语句是重点）    article1 = Article(title = &apos;aaa&apos;)    article2 = Article(title = &apos;bbb&apos;)    tag1 = Tag(name = &apos;111&apos;)    tag2 = Tag(name = &apos;222&apos;)    #article1下有哪些标签  一个article1有多个标签（重点）    article1.article.append(tag1)    article1.article.append(tag2)    # article2下有哪些标签  一个article2有多个标签（重点）    article2.article.append(tag1)    article2.article.append(tag2)    db.session.add(article1)    db.session.add(article2)    db.session.add(tag1)    db.session.add(tag2)    db.session.commit()</code></pre><p>案例：连接数据库 创建表格包含中间表 插入数据 关联数据 实现通过文章找Tag(免去config文件)</p><pre><code>from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configapp = Flask(__name__)app.config.from_object(config)db= SQLAlchemy(app)&quot;&quot;&quot;SQL语句：    创建article表    create table article(        id int primary key autoincrement        title varachar(100) not null    )    创建tag表    create table tag(        id int primary key autioncrement        name varachar(50) not null    )    创建中间表    create table article_tag(        article_id int        tag_id int        primay key (&apos;article_id&apos;,&apos;tag_id&apos;)        foreign_key &apos;article_id&apos; references &apos;article&apos;        foreign_key &apos;tag_id&apos; references &apos;tag&apos;    )&quot;&quot;&quot;#关联表article_tag = db.Table(&apos;article_tag&apos;,        db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),        db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)                       )class Article(db.Model):    __tablename__ = &apos;article&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    title = db.Column(db.String(100),nullable=False)    #这是外键的是指 以及表的关联过程  secondary    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))class Tag(db.Model):    __tablename__ = &apos;tag&apos;    id = db.Column(db.Integer,primary_key=True,autoincrement=True)    name = db.Column(db.String(50),nullable=False)db.create_all()@app.route(&apos;/&apos;)def hello_world():    &apos;&apos;&apos;    article1 = Article(title = &apos;aaa&apos;)    article2 = Article(title = &apos;bbb&apos;)    tag1 = Tag(name = &apos;111&apos;)    tag2 = Tag(name = &apos;222&apos;)    #article1下有哪些标签  一个article1有多个标签    article1.article.append(tag1)    article1.article.append(tag2)    # article2下有哪些标签  一个article2有多个标签    article2.article.append(tag1)    article2.article.append(tag2)    db.session.add(article1)    db.session.add(article2)    db.session.add(tag1)    db.session.add(tag2)    db.session.commit()    &apos;&apos;&apos;    article1= Article.query.filter(Article.title == &apos;aaa&apos;)[0]    tags = article1.article    for tag in tags:        print(tag.name)    return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;:    app.run(debug=True)</code></pre><hr><p>8.在分开models中解决循环引用<br>     分开models 的目的： 是为了更好的管理代码<br>     解决循环引用的方法：  是将add文件 分割开来  可以同时被几个文件引用 不会产生循环</p><pre><code>models.sep文件：（主文件）    from flask import Flask    # 引入models中的 Ariticle    from models import Ariticle    # 引入exts中的db    from exts import db    app = Flask(__name__)    #防止循环引用 初始化app    db.init_app(app)    db.create_all()    @app.route(&apos;/&apos;)    def hello_world():        return &apos;Hello World!&apos;    if __name__ == &apos;__main__&apos;:        app.run()exts文件：    from flask_sqlalchemy import SQLAlchemy    db = SQLAlchemy()models.py 文件：    #引入exts 中的 db    from exts import db    class Ariticle(db.Model):        __table__ = &apos;article&apos;        id = db.Column(db.Integer, primary_key=True, autoincrement=True)        title = db.Column(db.String(100), nullable=False)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.MySQL-python中间件的介绍和安装&lt;br&gt;     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装&lt;br&gt;     * 在window下需要到’&lt;a href=&quot;https://www.lfd.uci.edu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flask--urls和视图</title>
    <link href="http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/</id>
    <published>2020-02-02T09:32:35.000Z</published>
    <updated>2020-02-03T12:21:47.286Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.对代码的解析：#encoding UTF-8#模块的导入from flask import Flask#初始化一个Flask对象#Flask()#需要传递一个参数__name__#1. 方便flask框架去寻找资源#2. 方便flask插件 比如Flask-Sqlalchemy出现错误的时候，去寻找问题所在的位置app = Flask(__name__)# @app.route是一个装饰器# @开头，并且在函数的上面，说明是一个装饰器# 这个装饰器的作用，是做一个URL与视图函数的映射# 127.0.0.1:5000/  去请求hello_woeld 这个函数  然后将结果返回到浏览器@app.route(&apos;/&apos;)def hello_world():    return &apos;我是第一个程序&apos;# 如果当前这个文件是作为入口程序进行运行， 那么就执行app.run()if __name__ == &apos;__main__&apos;:    #app.run()    #启动一个应用服务器  来接受用户的请求    #while True    #   listen()    #设置debug模式  将错误直接显示到网页上面    app.run(debug= True)2.设置debug模式    a.在app.run()中传入一个关键字参数debug,例如：run(debug = Ture)，就设置当前项目为debug模式。    b.debug模式的两大功能：        * 当程序出现问题的时候，可以在页面中看到错误的信息和出错的位置        * 只要修改项目中的python文件，程序就会自动的加载，不需要手动的重新启动服务器。      具体的案例如下：          from flask import Flask        app = Flask(__name__)        @app.route(&apos;/&apos;)        def hello_world():            return &apos;我是第一个程序&apos;        if __name__ == &apos;__main__&apos;:            #设置debug模式  将错误直接显示到网页上面            app.run(debug= True)3.使用配置文件    * 新建一个&apos;config.py&apos;文件    * 在主要的app文件中导入这个文件，并且配置到app文件中        &apos;&apos;&apos;        import config        app.config.from_object(config)        &apos;&apos;&apos;    * 还有许多的其他参数也可以放置在文件中，比如&apos;SECRET_KEY&apos; 和 &apos;SQLALCHEMY&apos;这些配置文件    主app文件实例如下：（其实主要的作用还是和debug模式一样的作用）        from flask import Flask        #导入config文件        import config        app = Flask(__name__)        #加入config文件的配置        app.config.from_object(config)        @app.route(&apos;/&apos;)        def hello_world():            return &apos;我是第一个程序&apos;        if __name__ == &apos;__main__&apos;:            app.run()    config文件的配置：（可以加入很多的参数 注意的是需要将文件导入和对文件配置的导入使用）        DEBUG = True4.url传递参数    * 参数的作用： 可以在相同的URL，当时不指定相同的参数，来加载不同的数据。                例如：http://127.0.0.1:5000/URL/参数            * 在flask中如何使用参数：        &apos;&apos;&apos;            @app.route(&apos;/article/&lt;id&gt;&apos;)            def article(id):                return &apos;您请求的参数是 ： %S&apos; % id        &apos;&apos;&apos;           注意：参数必须放在&lt;&gt;中                    视图函数中需要放在和URL中的id相同的参数（就是函数括号里面的参数必须与id相同）    url传递参数的例子：            from flask import Flask            app = Flask(__name__)            #视图函数            @app.route(&apos;/login/&lt;id&gt;&apos;)            def login(id):                return &quot;您请求的参数是 % S&quot; % id            if __name__ == &apos;__main__&apos;:                app.run(debug=True)5.URL反转（需要一个模板：url_for）    * 什么叫做反转URL： 从视图函数到url的转换叫做反转URL      （根据视图的函数名字 可以直接切换到URL的参数）    * 反转URL的用处：        * 在页面重定向的时候，会使用url反转        * 在模板中，也会使用url反转    Url反转例子：            from flask import Flask,url_for            app = Flask(__name__)            @app.route(&apos;/&apos;)            def index():                print(url_for(&apos;my_list&apos;))                print(url_for(&apos;question&apos;),id = &quot;aaaa&quot;)                return &apos;这是首页&apos;            @app.route(&apos;/list/&apos;)            def my_list():                return &quot;这是登陆页面&quot;            @app.route(&apos;/question/&lt;id&gt;&apos;)            def question(id):                return &apos;这是发布问答的页面:%S&apos; % id            if __name__ == &apos;__main__&apos;:                app.run(debug= True)6.重定向和页面跳转：(需要两个模板： redirect  url_for)    * 用处： 在用户访问一些需要登陆的页面的时候，如果用户没有登陆用户则会跳转到用户的登陆界面    * 代码的实现：        &apos;&apos;&apos;            from flask import redirect,url_for            redirect(url_for(&apos;login&apos;))        &apos;&apos;&apos;    重定向和页面跳转的代码演示：        from flask import Flask,redirect,url_for        app = Flask(__name__)            @app.route(&apos;/&apos;)            def index():                   question_url = url_for(&apos;question&apos;,id = 1)                   return redirect(question_url)                   return &apos;这是首页&apos;            @app.route(&apos;/login/&apos;)            def login():                return &quot;这是登陆页面&quot;            @app.route(&apos;/question/&lt;id&gt;&apos;)            # 关键点   条件性代码            def question(id):                if id==&quot;1&quot;:                    return &apos;这是发布问答的页面&apos;                else:                    return redirect(url_for(&quot;login&quot;))            if __name__ == &apos;__main__&apos;:                app.run(debug=True)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1.对代码的解析：
#encoding UTF-8
#模块的导入
from flask import Flask
#初始化一个Flask对象
#Flask()
#需要传递一个参数__name__
#1. 方便flask框架去寻找资源
#2. 方便flask插
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>hexo的基本操作</title>
    <link href="http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-01-24T05:11:04.000Z</published>
    <updated>2020-02-04T05:28:06.746Z</updated>
    
    <content type="html"><![CDATA[<p>1.创建一个新的文件：<br>                hexo new post 文件名<br>                hexo new [layout(布局)] -p 路径 文件名</p><p>2.上传到网页并且进行部署（同时出现在GitHub上面）:<br>                hexo d -g</p><p>3.注意：在文档中有渲染的语法，或则有重定向的语法就会报错<br>        Template render error<br>        则需要进行注释或者标注</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.创建一个新的文件：&lt;br&gt;                hexo new post 文件名&lt;br&gt;                hexo new [layout(布局)] -p 路径 文件名&lt;/p&gt;
&lt;p&gt;2.上传到网页并且进行部署（同时出现在GitHub上面）:&lt;
      
    
    </summary>
    
    
    
      <category term="Li jian" scheme="http://yoursite.com/tags/Li-jian/"/>
    
  </entry>
  
</feed>

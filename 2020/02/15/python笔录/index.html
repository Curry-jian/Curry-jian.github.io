<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>python笔录 | Curry-jian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: python笔录date: 2020-02-15 16:54:55tags:  1.做列表类的题目心得：(踩过好多坑)    len() 函数的用法： 例子  num1 &#x3D; [1,2,3]                            print(len(num1))  &#x3D;&gt;  3    对于range()函数循环取值后：(包前不包后)">
<meta property="og:type" content="article">
<meta property="og:title" content="python笔录">
<meta property="og:url" content="http://yoursite.com/2020/02/15/python%E7%AC%94%E5%BD%95/index.html">
<meta property="og:site_name" content="Curry-jian">
<meta property="og:description" content="title: python笔录date: 2020-02-15 16:54:55tags:  1.做列表类的题目心得：(踩过好多坑)    len() 函数的用法： 例子  num1 &#x3D; [1,2,3]                            print(len(num1))  &#x3D;&gt;  3    对于range()函数循环取值后：(包前不包后)">
<meta property="article:published_time" content="2020-02-15T08:54:55.732Z">
<meta property="article:modified_time" content="2020-02-26T14:56:47.635Z">
<meta property="article:author" content="li jian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Curry-jian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Curry-jian</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-python笔录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/python%E7%AC%94%E5%BD%95/" class="article-date">
  <time datetime="2020-02-15T08:54:55.732Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      python笔录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: python笔录<br>date: 2020-02-15 16:54:55<br>tags:</p>
<hr>
<p>1.做列表类的题目心得：(踩过好多坑)<br>    len() 函数的用法： 例子  num1 = [1,2,3]<br>                            print(len(num1))  =&gt;  3<br>    对于range()函数循环取值后：(包前不包后)<br>                            for i in range(len(num1)):<br>                                print(i)  =&gt;    0,1,2<br>    可迭代对象是指 可以使用for语句进行循环取值的对象：<br>            list tuple dict set  str    可迭代对象之间是可以相互转化的  list(str)</p>
<hr>
<p>2.列表推导式：推导式 就是把  list  dict set  之间进行转换  没有元组推导式<br>基本格式：variable = [‘out_exp_res’ for out_exp in input list if ‘out_exp == 2]<br>        out_exp_res: 列表生成元素表达式  或则反回值<br>        for put_exp in input_list  迭代input_list 将out_exp 传入 out_exp_res<br>        if out_exp == 2            根据条件过滤哪些值<br>    例子： 将字符串变成列表  条件 只将大写输出：<br>            mystr = ‘abcABC’<br>            mylist = [item for item in mystr if item.isupper()]<br>            print(mylist)                                       =&gt;[‘A’, ‘B’, ‘C’]<br>3.字典推导式：（集合推导式  就只需要需要key）<br>基本格式：variable = {out_key:out_value for out_key,out_value in input if out_exp==2}</p>
<hr>
<p>4.可迭代对象的判断：<br>    from collections.abc import Iterable<br>         isinstance(a,Iterable) =&gt; Ture<br>    或者取dir 查看这个对象是否具有 <strong>iter</strong>这个对象</p>
<hr>
<ol start="5">
<li>迭代器：<br> 迭代器是有状态的，可以被next()调用，函数调用并不断返回下一个值的对象=&gt;迭代器<br> x = [1,2,3]<br> y = iter(x)   =&gt;   y = x.<strong>iter</strong>() 可以在可迭代对象中相互转换<br> print(next(y)) =&gt; 1      next表示一次取出迭代器里面的元素一次取一个元素<pre><code>当取完了就不能再取了  就会报错StopIteration</code></pre>for 后面要接可迭代对象的原因： 可迭代对象 =&gt; 生成一个迭代器 =&gt; 里面有Next方法 依次取值<br>迭代器的特点：  迭代器是有next方法的<pre><code>迭代器的数据不是立即生成的  当用户显示或隐式方法调用__next__()才会才会成数据 迭代器中只存放了下一个数据的计算方法</code></pre>迭代器的使用情景： 1. 数据量很大  2. 按顺序取值</li>
</ol>
<hr>
<ol start="6">
<li><p>迭代器生成一个无限序列：</p>
<pre><code>from itertools import count
#生成一个无限大的序列，从start开始
counter = count(start = 10)
print(counter, type(counter))
print(next(counter))  =&gt; 无限取值</code></pre><p>迭代器从一个有限序列中生成一个无限序列：</p>
<pre><code>   from itertools import cycle
import  time
week = cycle([1,2,3,4,5,6,7,8,9])
for i in week:
    print(i)
    time.sleep(1)</code></pre></li>
</ol>
<hr>
<p>7.可迭代对象与迭代器的区别：</p>
<h1 id="取值：-index-key-随机取值-只能通过next方法进行向下取值"><a href="#取值：-index-key-随机取值-只能通过next方法进行向下取值" class="headerlink" title="取值：  index/key 随机取值                    只能通过next方法进行向下取值"></a>取值：  index/key 随机取值                    只能通过next方法进行向下取值</h1><h1 id="存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）"><a href="#存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）" class="headerlink" title="存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）"></a>存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）</h1><h1 id="迭代器的好处：-在瞬时间-占用的内存少-计算量小"><a href="#迭代器的好处：-在瞬时间-占用的内存少-计算量小" class="headerlink" title="迭代器的好处：  在瞬时间 占用的内存少  计算量小"></a>迭代器的好处：  在瞬时间 占用的内存少  计算量小</h1><hr>
<p>8.生成器：<br>    生成器是一种特殊的迭代器，它不需要手动编写<strong>iter</strong>() 和 <strong>next</strong>()方法，只需要一个<br>    yiled 关键字     （生成器一定是迭代器，反之不成立）<br>  生成器表达式：<br>       1.使用()生成generator(生成器) 将两表推到式的[]改为()即可得到生成器<br>           a = (x for x in range(10 ** 9))<br>       2.yield： 包含yield表达式的函数是特殊的函数，叫做生成器函数<br>                 被调用时将返回一个迭代器，调用时用next 或者 send(msg)<br>                 ~ 一个生成器中可以有多个yield<br>                 ~ 一旦遇到yield 就会保存当前状态 然后返回yield后面的值<br>                 例子： def max1(i)<br>                             yield i       yield执行后就会保存状态，下次从yield开始执行<br>                           print(manx(1))  =&gt;  生成一个生成器<br>                           print(next(max1))  =&gt;  依次取值<br>       3.send数据：<br>           用户可以使用send 来跟生成器进行交互  send的数据会输入到生成器yield的位置<br>       4.yield from:<br>           当我们想从一个生成器取到内部的数据的时候<br>  ~生成器的好处：<br>          可以用更少的中间变量写流式代码<br>          相比其他容器对象他能节省内存<br>          可以减少代码的使用</p>
<hr>
<p>9.关于查看程序执行时间的方法  时间戳<br>    import time<br>    #时间戳   从1970.1.1 0点0时0秒<br>    start = time.time()<br>    a = [x for x in range(10*9)]<br>    print(time.time()-start)</p>
<hr>
<ol start="10">
<li>常见的编程范式：<ul>
<li>面向过程编程：根据操作数据的语句块来实现功能</li>
<li>面向对象编程：把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法</li>
<li>函数式编程： 如果一个函数可以接受函数作为参数，并且返回一个结果，这个函数为函数式编程</li>
</ul>
</li>
</ol>
<hr>
<ol start="11">
<li>高阶函数： 一个函数中把另一个函数作为参数传入，这个参数为函数的函数为高阶函数</li>
</ol>
<ul>
<li><p>map函数：  map( 函数名[方法] , 可迭代对象 )   一一映射进行处理 返回值为迭代器<br>  例子：   def f(x):                        ret = map(lambda x:x*x,range(10))</p>
<pre><code>    return x*x
ret = map(f,range(10))
print(list(ret))</code></pre></li>
<li><p>filter函数(过滤)： filter( 函数名[方法] , 可迭代对象 )  返回值为迭代器    </p>
<pre><code>filter把传入的函数依次作用于每个元素，然后根据返回值式Ture还是False决定保留还是丢弃 保留True</code></pre><p>  例子：    num1 = [1,2,3,4]</p>
<pre><code># 0=&gt;Fales   1=&gt;Ture
ret = filter(lambda x:x%2,num1)
print(list(ret))</code></pre></li>
<li><p>sorted函数(排序)：  sort(可迭代对象，函数名[方法])<br>  例子： sorted([2,3,4,-1],key = abs)    返回值为list</p>
</li>
<li><p>reduce函数():把结果继续和序列的下一个元素做累加计算</p>
<pre><code>reduce(函数，可迭代对象)</code></pre><p>  例子：from functools import reduce</p>
<pre><code>reduce(lambda x,y:x*10+y,[1,3,7,5,9])    =&gt;13759</code></pre></li>
</ul>
<hr>
<ol start="12">
<li><p>类(class):类里面的变量称为类属性(每个实例都可以使用)   类中函数里面的变量称为实例属性 </p>
<pre><code>      每个类中都有一个__init__ 方法(自动调用) 作用是来初始化类的 调用的时候直接：
      solution = 类名(类对象)
例子： class Soultion(object):
        def __init__(self,age,name,sex):
            self.age = age
            self.name = name
            self.sex = sex 
    solution = Soultion(age=10,name=&apos;lijian&apos;,sex=&apos;男&apos;)
    print(solution.name)
    print(solution.age)
    print(solution.sex)</code></pre><p><strong>new</strong> 方法：  开始创建实例  def <strong>new</strong> (cls,* args, ** kwargs):</p>
<pre><code>                return object.__new__(cls)
这样就会创建一个实例 后面的__init__方法就会初始化创建出来的实例</code></pre><p>注意： object 中包含了<strong>new</strong> <strong>init</strong> 这两个方法 一般不需要自行写入</p>
<pre><code>类和方法是可以动态添加属性和方法的    
bus317.color = green  这样就给实例添加了一个属性
Bus317.color = blue   这样就给类添加了一个属性
一个实例有自己的属性的时候 先使用自己的 再使用公共的</code></pre></li>
</ol>
<hr>
<p>13.用类创建迭代器：<br>    利用菲不拉契数列例子：<br>        class Fib(object):<br>    def <strong>init</strong>(self):<br>        self.prev = 0<br>        self.current = 1</p>
<pre><code>def __next__(self):
    self.prev,self.current = self.current,self.prev + self.current
    return self.prev
# 创建迭代器  只需要放回他自己就好
def __iter__(self):
    return self

fib = Fib()
print(fib.__next__())</code></pre><hr>
<h2 id="14-类-self-表示调用该方法的实例本身"><a href="#14-类-self-表示调用该方法的实例本身" class="headerlink" title="14.类-self: 表示调用该方法的实例本身"></a>14.类-self: 表示调用该方法的实例本身</h2><p>15.类的继承：<br>    在一个继承类中，如果父类有一个方法而子类也有一个相同的方法，在执行的时候子类会先用自己的方法，符合就近原则。但是子类没有该方法 就会自动的去查找父类和object中是否有该方法。如果<br>    都没有的话就会出现AttributeError这样的错误</p>
<pre><code>super().sports()      在子类于父类有同样的方法的时候，要求子类在调用该方法的时候先去父类调用该方法</code></pre><hr>
<p>16.装饰器(类方法)  @classmethod  在一个类里面定义只作用于这个类的方法<br>    @classmethod<br>    def add(cls):      cls是出现在那个类里面就表示哪个类<br>        cls.count += 1    </p>
<hr>
<p>17 定义一个异常类;  异常类都继承于 Exception<br>     #异常类的定义<br>    class ListLenghtError(Exception):<br>        pass</p>
<pre><code>li = list(range(8))
if len(li) &gt;= 10:
    raise ListLenghtError
else:
    print(&quot;列表正确&quot;)</code></pre><hr>
<p>18.类的继承中的多态<br>    多态：多种状态，在面向对象语言中，接口的多种不同的实现方式<br>    python是一种多态语言，裳称鸭子类型</p>
<pre><code>def talk_with(self,obj):      obj:是子类中的某个类
    obj.talk()               
有了这个多态 就可以用现在处在的这个类直接调用别的类中的talk方法    
父类名.某个子类中的方法()   就可实现调用</code></pre><hr>
<p>19.经典类与新式类：<br>    python2： 经典类是按照深度优先来继承的   新式类是按照C3算法来继承的<br>    python3： 同意按照C3算法来继承<br>            MRO: 方法解析顺序  解决当定义了多个同名的方法/属性的时候让用户找到正确的对象所实现的一种算法<br>            C3算法： * 子类会先于父类被检查<br>                     * 多个父类会根据他们在列表中的顺序被检查<br>                     * 如果对下一个类存在两个合法的选择，选择第一个父类<br>                     mro() :  可以直接退出C3 算法 </p>
<hr>
<p>20  * 实例方法： def <strong>init</strong>():    这个方法是给实例用的 一定要传递一个实例或者调用<br>    * 静态方法： @staticmethod<br>    * 类方法： @classmethod  cls表示类本身   在哪个类里面就表示哪个类  </p>
<pre><code>在方法中，没有使用实例信息，也没有使用类信息     @staticmethod 静态方法
在方法中，没有使用实例信息，使用到了类信息       @classmathod  类方法
在方法中，用到实例信息，没有使用到类信息         普通实例方法
在方法中，用到实例信息和类信息                  实例方法+类方法

例子：

    class Tst(object):
    #类属性(静态属性)
    class_attribute = &apos;A&apos;

    def __init__(self):
        #实例属性
        self.instance_attrubute = &apos;B&apos;
    #实例方法
    def instance_method(self):
        print(&apos;这是一个实例方法&apos;)
        print(self.instance_attrubute)
        print(self.class_attribute)

    # 类方法    =》 装饰器
    #把classmethod下面的方法变为类方法
    @classmethod
    def class_method(cls):
        print(&apos;这是个类方法&apos;)
        #类方法只能调用类属性
        print(cls.class_attribute)

    #静态方法
    @staticmethod
    def static_method():
        print(&apos;这是个静态方法&apos;)
        print(Tst.class_attribute)

    #用实例来调用实例方法
    tst = Tst()
    tst.instance_method()

    #用类来调用类方法
    Tst.class_method()
    #用实例来调用方法
    tst.class_method()

    #用实例来调用静态方法
    tst.static_method()
    #用类来调用静态方法
    Tst.static_method()</code></pre><hr>
<p>21.属性包装 ：@ property   将方法转化为属性来使用<br>        当生成一个包装后 python会自动生成 @类名.setter  @类名.delete 等包装<br>    例子：</p>
<pre><code>    class Person(object):
def __init__(self,name,age):
    self.name = name
    self._age = age

@property
def age(self):
    print(&apos;property_age&apos;)
    return self._age

# 这是用做修改的功能
@age.setter
def age(self,value):
      if 0&lt;value&lt;100:
        self._age = value
    else:
        raise ValueError(&apos;超出范围&apos;)

# 这是删除的功能
@age.deleter
def age(self):
    del self._age

p1 =  Person(&apos;cali&apos;,19)
#当作属性可以直接访问
print(p1.age)
p1.age = 10
print(p1.age)</code></pre><hr>
<p>22.类中的下划线：   _age 表示是私有的     <strong>age 表示是强制不能使用的<br>                                       强行访问的方式  obj._classname</strong>foo<br>                                       obj 实例名   classname 类名</p>
<hr>
<ol start="23">
<li>魔术方法：<ul>
<li><strong>new</strong> 创建实例:<br>  def <strong>new</strong>(cls,* args, ** kwargs):<pre><code>return upper().__new__(cls)</code></pre></li>
<li><strong>init</strong> 初始化实例：<br>  def <strong>init</strong>(self):<pre><code>return 初始化实例</code></pre></li>
<li><strong>del</strong> 删除方法：<br>  def <strong>del</strong>(self):<pre><code>return 删除方法   自动调用    </code></pre></li>
<li><strong>getitem</strong> 获取数据</li>
<li><strong>setitem</strong> 设置数据</li>
<li><strong>iter</strong>    可迭代</li>
<li><strong>eq</strong>(self,other)     符号 ==<pre><code>tst1.__eq__(txt2)    self.tst1 == other.tst2</code></pre></li>
<li><strong>ne</strong> (self,other)    !=</li>
<li><strong>it</strong> (self,other)    &lt;</li>
<li><strong>gt</strong> (self,other)    &lt;=</li>
<li><strong>add</strong>(self,other)    +</li>
<li><strong>mul</strong>(self,other)    *</li>
<li><strong>len</strong> (self)  长度</li>
<li><strong>str</strong> (self)  友好的输出实例信息=&gt;非正式</li>
<li><strong>repr</strong>(self)  友好的输出实例信息=&gt;正式  结果放在列表中</li>
<li><strong>dict</strong>(self)  类的属性</li>
<li><strong>doc</strong> (self)  类的文档</li>
<li><strong>name</strong>(self)  类名</li>
<li><strong>module</strong>(self)  类定义所在的模块</li>
<li><strong>bases</strong> (self)  类所有父类构成元素</li>
</ul>
</li>
</ol>
<hr>
<p>24.自省: 检查某些事务以确定他是什么 他是干什么的能做什么<br>         类似于：dir()    typle()<br>    自省的方法：<br>        * getattr(obj,’name’):获取成员<br>            getattr(实例名，属性值)<br>        * hasattr(obj,’name’):检查是否含有成员<br>            hasattr(实例名，属性值)<br>        * setattr(obj,’age’,value): 设置成员<br>            getattr(实例名，属性值,修改值)<br>        * delattr(obj,’name’):删除成员<br>            delattr(实例名，属性值)</p>
<hr>
<p>25.python元类：  元类就是用来创建类的类   类是由type创建的  type是默认的一个元类<br>    type创建类    type(类名，(object),{方法:函数})<br>        第一个参数： 是写出类名<br>        第二个参数： 继承自谁<br>        第三个参数： ‘方法名’:函数(方法)</p>
<hr>
<p>26.抽象基类：  from abc import ABCmeta,abstractmethod        metaclass = ABCMeta<br>            @abstractmethod  下面的函数可以在子类中出现了该方法就可以直接调用</p>
<hr>
<p>27.闭包：在函数中可以(嵌套)<br>    定义另外一个函数，如果内部函数引用了外部的函数变量，则可能产生闭包<br>    闭包可以用来在一个函数于一组“私有”变量之间创建关联关系<br>    在给定函数被多次调用的过程中，这些私有变量能够保持其持久性<br>闭包形成的条件：<br>    * 有一个内嵌的函数<br>    * 内部函数必须要引用外部函数的变量<br>    * 外部函数返回内部函数(函数名)<br>闭包的特点：闭合范围内的变量是有状态的 随着调用 会不断的更新     </p>
<p>例子：<br>    def func01():<br>    a = 1<br>    def func02():<br>        # 表示使用上一层函数的变量<br>        nonlocal a<br>        #从右往左计算 那么a就没有值<br>        a = a+1<br>        print(a)<br>    return func02()</p>
<hr>
<p>28.编写装饰器;（作用：给函数添加功能）<br>    编写装饰器的固定模板：</p>
<pre><code>import functools
def 装饰器名(func):
    @functools.wraps(实例函数)
    def _dec(*args,**kwargs)
        你想添加的功能
        result = func(*args,**kwargs)
        你想添加的功能
        return result
return _dec

带参数的装饰器的模板：
def permission_required(user):
    def dec(func):
        def _dec(*args,**kwargs):
            # 你想添加的功能
            result = func(*args,**kwargs)
            # 你想添加的功能
            return result
        return _dec
    return dec


例子：import functools
    def login_required(func):
        @functools.wraps(func)   =》 是可以提示哪个函数被调用
        def _dec(a,b,*args,** kwargs):
            if name == &apos;root&apos;:
                print(f&quot;{func.__name__}被调用&quot;)
                return func(a,b,*args,** kwargs) =&gt; 
                                可变长参数   不用管函数传入的参数什么样子
            else:
                print(&apos;有问题&apos;)
                return False
        return _dec
    @login_required
    def add(a,b,*args,** kwargs):
        print(a+b)
        return a+b
    add(1,2,&apos;root&apos;)</code></pre><hr>
<p>29.用类来实现装饰器<br>    <strong>init</strong> 初始化类         <strong>call</strong>  传入参数的时候使用</p>
<p>例子：</p>
<pre><code>class logging(object):
def __init__(self,func):
    self.func = func

# 当函数中有参数的时候  会调用__call__ 方法
def __call__(self, *args, **kwargs):
    reslut  =  self.func(*args,**kwargs)
    print(f&apos;{self.func.__name__}被调用&apos;)
    return reslut</code></pre><p>@logging<br>def add(a,b):<br>    return a+b<br>print(add(1,2))</p>
<hr>
<p> 30.上下文管理器： 上下文管理器是一个包装任意代码块的对象<br>     进入上下文管理器时，每次代码执行的一致性<br>     当退出上下文管理器时，相关的资源会被正确回收 即使内部代码出错，退出步骤也会执行<br>     上下文管理器用的最多的就是  作为确保资源正确清理的一种方式<br>     重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性</p>
<p> with语句： 仅仅能对上下文管理协议的对象使用<br>             with语句的作用是返回一个遵循特定协议的的对象，具体来说就是必须要定义一个<br>             <strong>enter</strong>方法和<strong>exit</strong>方法</p>
<p>with的工作原理：<br>    with open() as f:            with context_expras cm:<br>        # obj.<strong>enter</strong>()                dosomething<br>        f.read()<br>        # obj.<strong>exit</strong>()</p>
<ul>
<li>在进入代码块之前会执行obj.<strong>enter</strong>()语句（自动调用）</li>
<li>在退出代码块之前会执行obj.<strong>exit</strong>()语句（自动调用）</li>
</ul>
<p>编写上下文管理器：   重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性<br>例子：<br>    class A(object):<br>        def <strong>init</strong>(self):                                  =&gt;第一步<br>        pass<br>        def <strong>enter</strong>(self):                                =&gt;第二步<br>        pass<br>        def <strong>exit</strong>(self, exc_type, exc_val, exc_tb):        =&gt;第四步<br>        pass<br>    with A() as a:<br>        print(‘xxx’)                                        =&gt;第三步</p>
<hr>
<p>31.上下文自动管理模块： contextlib 可以用简单的方法创建上下文管理器(没弄懂)<br>    @cotextlib.contextmanage  这是一个上下文管理的装饰器</p>
<hr>
<h2 id="32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出"><a href="#32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出" class="headerlink" title="32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出"></a>32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出</h2><p>33.logging日志的记录:</p>
<pre><code>import logging
#配置loging
#level 记录等级比自己高的日志
logging.basicConfig(level=logging.INFO,format=&apos;%(asctime)s-%(name)s-%(message)s&apos;)
#创建日子记录器
logger= logging.getLogger(&apos;cali_game&apos;)
#记日志
logging.debug(&quot;这是一个debug&quot;)
logging.info(&quot;这是一个info&quot;)
logging.warning(&quot;这是一个warning&quot;)
logging.error(&quot;这是一个error&quot;)
logging.critical(&quot;这是一个critical&quot;)
try:
    raise ValueError(&apos;value error&apos;)
except Exception as ex:
    logging.exception(ex)
print(&quot;finished&quot;)</code></pre><p>将日志放入log文件中</p>
<pre><code>import logging
#创建日志记录器
logger = logging.getLogger(__name__)
#为logger做日志配置
logger.setLevel(level=logging.INFO)
#把内容输出到文件中去
filehander = logging.FileHandler(&apos;log.txt&apos;)
filehander.setLevel(level=logging.DEBUG)
formatter = logging.Formatter(&apos;%(asctime)s -%(name)s:[%(levelname)s]:%(message)s&apos;)
filehander.setFormatter(formatter)
#给日志记录器添加存储位置
logger.addHandler(filehander)

logging.debug(&quot;这是一个debug&quot;)
logging.info(&quot;这是一个info&quot;) 
logging.warning(&quot;这是一个warning&quot;)
logging.error(&quot;这是一个error&quot;)
logging.critical(&quot;这是一个critical&quot;)</code></pre><hr>
<p>34.调试方式：asset断言<br>    assert expression ,(arguments)<br>    assert 表达式 参数                 直接报错退出</p>
<p>例子：<br>    score = input(“输入”)<br>    assert score.isdigit(),”输入的有问题”</p>
<hr>
<p>35.pdb 调试器<br>    可以直接使用启动调试器<br>        python -m pdb mypdb_base.py<br>    pdb 指令<br>        下一条语句  n next<br>        打印变量信息： p 变量名<br>        打印脚本信息： l<br>        退出pdb  q<br>        查看帮助  h</p>
<hr>
<p>36.列表中的数 自由排列  排列数列  从4个里面选出3个 排列<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>37.列表中的数自由组合<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>38.排列组合  生成密码<br>    import itertools<br>    mylist = list(itertools.product([1,2,3,4],repeat=3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>39.正则表达式：<br>    re模块使python有了正则的功能 就是根据一种模式 来提取某些地方的数据</p>
<p>re.match函数：  match(pattern,string,flags = 0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>match.group: 返回匹配的字符串<br>match.start: 返回的是匹配的开始的位置<br>match.end:   返回的是匹配的结束的位置<br>match.groups:返回分组的全部内容 （””,””,,””）</p>
<p>功能：尝试从字符串的起始位置开始匹配的一个模式，如果不是起始位置匹配成功的话，返回None<br>例子：   import re<br>        print(re.match(‘www’,’wwW.baidu.com’,flags=re.I))  re.I :表示忽略大小写</p>
<!-- 结果：    <re.Match object; span=(0, 3), match='wwW'> -->

<p>re.search函数：  search(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串，会现显示前面的那段<br>      如果匹配不成功的话会返回None<br>例子：   import re<br>        print(re.search(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p>
<!-- 结果：<re.Match object; span=(7, 10), match='wwW'> -->

<p>re.findall函数：findall(pattern,string,flags=0)    <!-- (\)记得转义 --><br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个列表，<br>    如果没有则会返回None<br>例子：  import re<br>        print(re.findall(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p>
<!-- 结果：    ['wwW', 'wwW'] -->

<!-- ret = re.finditer(r'[a-c\-]at', message) -->  \的重要性  有特殊意义的都是需要转义
<p>re.finditer函数： finditer(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>                 ?:i   是表示内联的标记<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个迭代器<br>    如果没有则会返回None<br>例子：   import re<br>        print(re.finditer(‘(lijian)’,’lijian a good man,lijian a handsome man’))<br>    <!-- 结果：<callable_iterator object at 0x0000024A9EC8ED30> --></p>
<hr>
<p>40.正则表达式：匹配单个字符和数字<br> .  匹配除换行符以外的任意字符<br>        例子：   import re<br>                print(re.search(‘.’,’lijian is a good man’))<br>        <!-- 结果：   <re.Match object; span=(0, 1), match='l'> --></p>
<p> [] 字符集合，表示匹配方括号中所包含的任意一个字符<br>    [a-z]: 匹配任意小写字母</p>
<!--      [A-Z]: 匹配任意大写字母
         [0-9]: 匹配任意数字
         [0-9a-zA-Z] : 匹配任意数字于字母
         [^lijian]:匹配出了lijian这几个字符意外的所有字符  -->
<pre><code> ^: 脱字符 表示不匹配集合中的字符 取反
 \d: 匹配所有的数字 效果同[0-9]
 \D:    匹配所有的非数字 效果同[^\d]
 \w: 匹配所有的数字 字母 下划线
 \W: 匹配非数字 字母 下划线
 \s: 匹配任意的空白符（空格，换行，回车，换页，制表）效果同：[ \f\n\r\t]
 \S: 匹配任非任意的空白符 [^ \f\n\r\t]

 例子：  import re
       print(re.search(&apos;[0-9]&apos;,&apos;lijian is a good man 2&apos;))
&lt;!-- 结果：&lt;re.Match object; span=(21, 22), match=&apos;2&apos;&gt; --</code></pre><hr>
<p>41.正则表达式：匹配锚字符（边界字符）<br>  ^  行首匹配  筛选某个字符串开头的方式   每行的开头<br>                   import re<br>               print(re.search(‘^lijian’,’lijian is a good man 2’))<br>        <!-- 结果：<re.Match object; span=(0, 6), match='lijian'> --><br>  $  行尾匹配  筛选某个字符串结尾的方式    每行的结尾<br>                  import re<br>               print(re.search(‘2&amp;’,’lijian is a good man 2’))<br>         <!-- 结果：<re.Match object; span=(21, 22), match='2'> --><br>  \A  匹配字符串的开始     换行后的第一字符串也不行  就是整个字符串的开头<br>          re.M(换行模式)模式下不会匹配他的行首<br>                  import re<br>                print(re.findall(‘\Alijian’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘lijian’]<br>  \Z   匹配字符串的结束     换行后的最后一个字符串也不行  就是整个字符串的结尾<br>          re.M(换行模式)模式下不会匹配他的行尾<br>                  import re<br>                print(re.findall(‘manb\Z’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘manb’]<br>  \b   匹配以什么结尾的单词<br>                  import re<br>                  print(re.search(r’er\B’,’nerve’))  记得raw<br>              <!-- 结果： <re.Match object; span=(1, 3), match='er'> --><br>  \B   匹配中间含有什么的单词<br>                  import re<br>                  print(re.search(r’er\b’,’never’))   记得raw<br>              <!-- 结果：<re.Match object; span=(3, 5), match='er'> --></p>
<hr>
<p>42.正则表达式：匹配多个字符<br>    (x,y,x)   匹配括号里的xyz (把xyz看成一个整体)<br>                import re<br>                print(re.findall(‘(laugh)’,’never not to laugh myself’))<br>            <!-- 结果：<re.Match object; span=(13, 18), match='laugh'> --><br>    x？        匹配0个或者1个x  (就是将匹配的x一个一个显示出来)非贪婪匹配 尽可能少的匹配<br>                import re<br>                print(re.findall(‘x?’,’xxx’))<br>            <!-- 结果：['x', 'x', 'x', ''] --><br>    x*         匹配多个x   (就是将相邻的x合成一个字符串输出) 贪婪匹配 尽可能多的匹配<br>                import re<br>                print(re.findall (‘x*’, ‘xxx’))<br>            <!-- 结果：['xxx', ''] --><br>    x+         匹配至少一个x  (就是在有x的情况下 将相邻的x合成一个字符串输出)<br>                贪婪匹配 尽可能多的匹配</p>
<pre><code>            import re
            print(re.findall(&apos;x+&apos;,&apos;xxxbxxxx&apos;))
        &lt;!-- 结果：[&apos;xxx&apos;, &apos;xxxx&apos;] --&gt;
x{n}        匹配确定含有n个x的字符串（n 是一个非负整数） 贪婪匹配 将相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4}&apos;,&apos;xxxbxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxx&apos;] --&gt;
x{n,}        匹配至少含有n个x的字符串 （n 是一个非负整数）贪婪匹配 将相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4,}&apos;,&apos;xxxbxxxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;
x{n,m}   匹配至少含有n个最多m个x的字符串（n，m是一个非负整数）
            贪婪匹配 将符合要求的相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4,6}&apos;,&apos;xxxbxxxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;
x|y      匹配含有x或者y的字符串   
            import re
            print(re.findall(&apos;((x|y)aaa)&apos;,&apos;xaaa-yaaa&apos;))
        &lt;!-- 结果：[(&apos;xaaa&apos;, &apos;x&apos;), (&apos;yaaa&apos;, &apos;y&apos;)] --&gt;</code></pre><hr>
<p>43.正则表达式-特殊匹配<br>    * ？    + ？    x ？<br>    最小匹配，通长是尽可能多的匹配，可以使用这种解决贪婪匹配</p>
<h2 id="x-类似-xyz-但是不表示一个组-？p-分组命名"><a href="#x-类似-xyz-但是不表示一个组-？p-分组命名" class="headerlink" title="   (?:x)  类似(xyz)  但是不表示一个组      ？p  分组命名"></a>   (?:x)  类似(xyz)  但是不表示一个组      ？p<name>  分组命名</h2><p>44.正则表达式-字符串的替换和修改<br> sub(pattern,repl,string,count=0,flags=0) =&gt; 打印的类型  str<br> subn(pattern,repl,sttring,count=0,flags=0) =&gt; 打印的类型 tuple<br> 例子：   sub<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.sub(‘good’,’nice’,str1))<br> <!--  结果：lijian a nice nice man --><br> 例子：   subn<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.subn(‘good’,’nice’,str1))<br> <!--  结果：('lijian a nice nice man', 2) --><br> pattern:正则表达式（规则）<br> repl : 指定的用来替换的字符串<br> string： 目标字符串<br> count：最多替换次数<br>功能：在目标字符串中按照匹配规则进行匹配字符串，然后在将字符串替换成指定的字符串，count可以指定替换的次数</p>
<hr>
<p>45.正则表达式-分组<br>    正则表达式除了简单的判断是否匹配之外，正则表达式还有提取子串的功能<br>    用（）表示的就是提取分组<br>    提取数据：  m.group(0)   最外层<br>               m.group(1)    依次往里取组</p>
<hr>
<p>46.正则表达式-编译   将正则表达式变成一个对象 对用户友好<br>    当我们使用正则表达式的时候 re模块<br>    1.编译正则表达式，如果正则表达式不和法，会报错<br>    2.用编译后的正则表达式去匹配对象<br>    compile(pattern,flags=0)<br>功能：将正则表达式进行封装 到时候去匹配的时候 如果是按照正则表示的规则来的就会输出 否则就会输出None   (最常用)</p>
<p>例子：<br>    import re<br>    re_QQ = re.compile(r’[1-9]\d{5,9}$’)<br>    print(re_QQ.search(‘1234568789’))</p>
<!-- 结果：<re.Match object; span=(0, 10), match='1234568789'> -->
<hr>
<p>47.踩坑记录：<br>    message = “a.jpg, a.gif, a.css, b.gif, b.css”<br>    ret = re.findall(r’[a-zA-Z0-9].(?:jpg|gif)’, message)   =》 ?: 表示不是一个组<br>    print(ret)   </p>
<hr>
<p>49.练习：<br>长度为8-10的用户名（以字母、下划线开头，由字母、数字、下划线组成）<br>    content = “””<br>    a<br>    1aaaaaaaa<br>    <em>a<br>    <em>1<br>    asdfasddf<br>    11<br>    ad_a<br>    asd+s<br>    abcdefghi<br>    1aaaaaa<em>a<br>    1aaaaaaa a<br>    aaa</em>aaa_aa<br>    1234562452<br>    a_______</em></em><br>    <strong><strong><strong>_____</strong></strong></strong><br>    “””<br>    # ^ 表示以什么开头    $ 表示以什么结尾  [字母或者下划线]   \w 字母 数字 下划线   {7,9}长度<br>    ret = re.findall(r”^[a-zA-Z_]\w{7,9}$”,content,re.M)<br>    print(ret)</p>
<p>电子邮箱验证(<!-- xxx1@xxx2.xxx3 -->，xxx1、xxx2由字母数字下划线组成，xxx1长度为6-18)</p>
<!--     mystr = """
    a@163.com
    aaaasdf@16.com
    aaaasdf@16.net
    asd*wwf@sdf.com
    """ -->
<!-- ^ 表示以什么开头  \w字母 数字 下划线   +一个以上  \. 将点转义  (?:com|net)？:是不将括号看为分组 |或
ret = re.findall(r"^\w{6,18}@\w+\.[a-z]+$",mystr,re.M)
ret = re.findall(r"^\w{6,18}@\w+\.(?:com|net)$",mystr,re.M)
print(mystr) -->


<!-- #  URL地址验证(http[s]://www.baidu.com[/?a=111&b=111], -->
<p>mystr = “””</p>
<!-- http://www.baidu.com
http://baidu.com
https://www.baidu.com
https://t.cn
https://www.baidu.com/?a=111&b=111 -->
<!-- """
ret = re.findall(r"^http[s]?://\w+\.\w+\.(?:com|cn)",mystr,re.M)
print(ret) -->


<!-- msg = """
Feng Tel: 18392013983
Feng Tel: 183 9201 3983
Feng Tel: 183-9201-3983
Feng Tel: (+86) 183 9201 3983
Feng Tel: (+86) 18392013983
Feng Tel: (+01)18392013983"""

# (?:\(\+\d{2}\))? 一个整体是否存在(+86)   [ -]?空格和-中的一个  \d{3} 三个数字
ret = re.findall(r"(?:\(\+\d{2}\)[ -]?)?\d{3}[ -]?\d{4}[ -]?\d{4}",msg,re.M)
print(ret) -->

<hr>
<p>50.爬虫爬取网站照片：<br>    ### 总结 =&gt;<br>    ### 需求 =&gt; <a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a> =&gt; 图片保存当前目录的imgs目录下<br>    # 获取网页的内容<br>    import requests<br>    import os</p>
<pre><code>headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&quot;}

response = requests.get(&quot;https://movie.douban.com/&quot;,
                    headers=headers)
# 添加headers的user-agent的目的是告诉douban，我不是一个脚本，我是Firefox浏览器
html = response.text
# 从html页面中获取所有的图片链接
# &lt;img src=&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2581067467.jpg&quot;
all_imgs_link = re.findall(r&apos;src=&quot;(.*?\.(jpg|png|gif|bmp|webp))&quot;&apos;, html)
# 路径 。扩展名
# print(all_imgs_link)
# 将这些图片保存到当前目录的imgs目录下
output_dir = &apos;./imgs&apos;
if not os.path.exists(output_dir):
    os.mkdir(output_dir)

for i,pic_url in enumerate(all_imgs_link):
    # 把图片存在本地 =&gt; 二进制文件 =&gt; content
    #                            =&gt; text =&gt; content转化成str
    img = requests.get(pic_url[0], headers=headers).content
    # filepath = output_dir/i.pic_url[1]
    filepath = f&quot;{output_dir}/{i}.{pic_url[1]}&quot;
    print(filepath)
    with open(filepath, &apos;wb&apos;) as f:
        f.write(img)</code></pre><hr>
<p>51.断言：（存在问题）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/15/python%E7%AC%94%E5%BD%95/" data-id="ck6nd82820000wcv396cp687q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/02/13/flask-jinja2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">flask_jinja2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Li-jian/" style="font-size: 10px;">Li jian</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" style="font-size: 10px;">代码在models_Migrate文件中</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/15/python%E7%AC%94%E5%BD%95/">python笔录</a>
          </li>
        
          <li>
            <a href="/2020/02/13/flask-jinja2/">flask_jinja2</a>
          </li>
        
          <li>
            <a href="/2020/02/09/Flask-jinja/">Flask-jinja</a>
          </li>
        
          <li>
            <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
          </li>
        
          <li>
            <a href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 li jian<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Curry-jian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Curry-jian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Curry-jian">
<meta property="article:author" content="li jian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Curry-jian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Curry-jian</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-flask-jinja2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/13/flask-jinja2/" class="article-date">
  <time datetime="2020-02-13T14:29:13.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/13/flask-jinja2/">flask_jinja2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>base.html 文件：

 &lt;!DOCTYPE html&gt;
   &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;{% block title %}{% endblock %}</title>
			        <style>
			        .nav{
			            background: #3a3a3a;
			            height: 65px;
			        }
			        ul{
			            overflow: hidden;
			        }
			        ul li{
			            float: left;
			            list-style: none;
			            padding: 0 10px;
			            line-height: 65px;
			        }
			        ul li a{
			            color: white;
			        }
			    </style>
			</head>
			<body>
			    <div class="nav">
			    <ul>
			        <li><a href="#">首页</a></li>
			        <li><a href="#">发布问答</a></li>
			    </ul>
			</div>
			{% block main %}{% endblock %}
        &lt;/body&gt;
        &lt;/html&gt;

    login.html:
        {% extends 'base.html' %}
        {% block title %}
			    登陆页面
			{% endblock %}
        {% block main %}
			    <p>这是登陆页面</p>
			{% endblock %}

    index.html:
        {% extends 'base.html' %}
        {% block title %}
			    首页
			{% endblock %}
        {% block main %}
			    <p>这是首页面</p>
			{% endblock %}

6.URL链接和加载静态文件
    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;
    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径
    * 可以加载css文件，js文件 image文件
    image文件：
    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;

    js文件：
     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;

    css文件：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;

*url链接：使用url_for(视图函数名)，从而反转url 跳转页面
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;

url链接和加载静态文件的例子：
    Py文件：
        from flask import Flask,render_template

        app = Flask(__name__)


        @app.route(&apos;/&apos;)
        def index():
            return render_template(&apos;index.html&apos;)

        @app.route(&apos;/login/&apos;)
        def login():
            return render_template(&apos;login.html&apos;)

        if __name__ == &apos;__main__&apos;:
            app.run(debug=True)

    index.html文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;
            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;
        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    index.js文件：
        /**
         * Created by 栩森 on 2020/2/4.
         */

        alert(&apos;我是李坚&apos;)

    index.css文件：
           a{
                background: red;
            }

    login.html 文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;这是登陆页面&lt;/h1&gt;
        &lt;/body&gt;
        &lt;/html&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/13/flask-jinja2/" data-id="ck6kub5740000bgv3c91zdoff" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-jinja" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/09/Flask-jinja/" class="article-date">
  <time datetime="2020-02-09T07:48:18.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/Flask-jinja/">Flask-jinja</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>1.如何渲染Jinja2模板和传参：(主要是 &apos;render_template&apos;函数)

* 渲染模板：
    * 模板放在 templates 文件夹下面
    * 从 flask 中导入 render_template 函数
    * 在视图函数中，使用 render_template
    #注意：在templates文件夹下面没有其他文件夹的话可以直接render_template(文件名)

* 模板传参数：
    * 如果只有一个或则少量参数的时候，可以直接在render_template函数中添加关键字就好
         #   return render_template(&apos;index.html&apos;,&apos;user&apos; = &apos;username&apos;)
    * 如果有多个参数的时候就需要把参数放入一个字典中，然后在&apos;render_template&apos;中使用**
    把字典中的参数传递
    &apos;&apos;&apos;
            @app.route(&apos;/&apos;)
            def index():
                context = {
                    &apos;username&apos;:&apos;李坚&apos;,
                    &apos;gender&apos;:&apos;男&apos;,
                    &apos;age&apos;: 18
                }
                return render_template(&apos;index.html&apos;,**context)
    &apos;&apos;&apos;
* 在模板中，如果需要使用变量，语法是&apos;{{params}}&apos;
                &lt;p&gt;用户名：&apos;{{ username }}&apos;&lt;/p&gt;
        * 在访问类的属性或则是字典或则是列表的时候，可以通过&apos;{{params.proper}}&apos;的形式，或则是&apos;{{params[]}}&apos;
                   &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;

模板的渲染和传参的实例：

    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18
        }
        return render_template(&apos;index.html&apos;,**context)

    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;


模板的渲染和传参的实例：（含有类的例子）
    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        class Preson(object):
            name = &apos;李坚&apos;
            age = 20
        p = Preson()
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18,
            &apos;person&apos;: p
        }
        return render_template(&apos;index.html&apos;,**context)
    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;

        &lt;hr&gt;
        &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;
        &lt;p&gt;年您：{{ person.age }}&lt;/p&gt;
        &lt;/hr&gt;
    &lt;/body&gt;
    &lt;/html&gt;


2.if判断语句

* 语法格式：（Jinja模板中）
    {% if xxx %}
		{% else %}
		{% endif %}
if判断语句的具体实例（根据id的不同显示不同的页面）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&lt;id&gt;/&apos;)
def index(id):
    if id == &apos;1&apos;:
        user = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;age&apos; : 10
        }
    return render_template(&apos;index2.html&apos;,user=user)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)




&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% if user %}
	        <a href="#">{{ user.username }}</a>
	        <a href="#">注销</a>
	    {% else %}
	        <a href="#">登陆</a>
	        <a href="#">注册</a>
	    {% endif %}
&lt;/body&gt;
&lt;/html&gt;


3.for循环遍历列表和字典：

* 字典的遍历和语法与&apos;python&apos;一样，可以使用&apos;item()&apos; &apos;keys()&apos; &apos;values()&apos;等函数
    {% for k,v in user.item() %}
			<p>{{ k }}:{{ v }}</p>
		{% endfor %}
* 列表的遍历：
    {% for webisit in webisits %}
			<p>{{ webisit }}</p>
		{% endfor %}

for循环的案例：（四大名著的表格排序）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    books=[
        {
            &apos;name&apos;:&apos;西游记&apos;,
            &apos;author&apos;:&apos;吴承恩&apos;,
            &apos;price&apos;:&apos;100&apos;
        },
        {
            &apos;name&apos;:&apos;红楼梦&apos;,
            &apos;author&apos;:&apos;曹雪芹&apos;,
            &apos;price&apos;:&apos;50&apos;
        },
        {
            &apos;name&apos;:&apos;三国演义&apos;,
            &apos;author&apos;:&apos;罗贯中&apos;,
            &apos;price&apos;:&apos;150&apos;
        },
        {
            &quot;name&quot;:&apos;水浒传&apos;,
            &quot;author&quot;:&apos;施耐庵&apos;,
            &quot;price&quot;:200
        }
    ]
    return render_template(&apos;index2.html&apos;,books=books)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;th&gt;书名&lt;/th&gt;
            &lt;th&gt;作者&lt;/th&gt;
            &lt;th&gt;价格&lt;/th&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for book in books %}
	            <tr>
	                <td>{{book.name}}</td>
	                <td>{{book.author}}</td>
	                <td>{{book.price}}</td>
	            </tr>
	        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;


4.过滤器：
    * 介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来（就是设置一个默认的，
然后再用户没有设置的时候就可以直接过滤 输出默认的值）
* 语法： 
    {{ avater(用户输入的值的名字) | default（过滤器）('xxx')}}
* default（过滤器）:如果当前变量不存在的时候，这个时候就可以指定默认值
* length: 求列表或则字符串或则字典 元组的长度

过滤器的例子：（将图片的参数进行传递 ）    
from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    return render_template(&apos;index2.html&apos;,family=&apos;https://avatars2.githubusercontent.com/u/60211293?s=40&amp;v=4&apos;)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板：

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

过滤器的例子：（关于评论的显示 ）
Jinja模板：
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
    &lt;hr&gt;
    &lt;p&gt;评论数:({{comments|length}})&lt;/p&gt;
    &lt;ul&gt;
        {% for comment in comments %}
		        <li>
		            <a href="#">{{comment.user}}</a>
		            <p>{{ comment.content }}</p>
		        </li>
		    {% endfor %}
    &lt;/ul&gt;
    &lt;/body&gt;
    &lt;/html&gt;


python文件：

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    comments = [
        {
            &apos;user&apos;: &apos;李建安&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        },
        {
            &apos;user&apos;: &apos;李坚&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        }
    ]
    return render_template(&apos;index2.html&apos;,comments=comments)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

5.继承和block块
* 作用：可以把一些公共的代码放在父模板中（base.HTML）文件
* 语法：
#    {% extend 'base.html'%}
block 实现：
    * 作用：可以让子模版实现自己的需求，父模板需要提前定义好
    * 注意：子模板中的代码必须放在block块中，不然没有效果
    具体的block语法例子：{% block 模块名 %}{% endblock %}

	继承和block的具体实例：
	py文件：
	from flask import Flask,render_template

	app = Flask(__name__)

	@app.route('/')
	def index():
	    return render_template('index.html')

	@app.route('/login/')
	def login():
	    return render_template('login.html')
	if __name__ == '__main__':
	    app.run(debug= True)


	base.html 文件：

 	<!DOCTYPE html>
   <html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>{% block title %}{% endblock %}&lt;/title&gt;
            &lt;style&gt;
            .nav{
                background: #3a3a3a;
                height: 65px;
            }
            ul{
                overflow: hidden;
            }
            ul li{
                float: left;
                list-style: none;
                padding: 0 10px;
                line-height: 65px;
            }
            ul li a{
                color: white;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发布问答&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    {% block main %}{% endblock %}
		</body>
		</html>

		login.html:
			{% extends 'base.html' %}
			{% block title %}
			    登陆页面
			{% endblock %}
        {% block main %}
			    <p>这是登陆页面</p>
			{% endblock %}

    index.html:
        {% extends 'base.html' %}
        {% block title %}
			    首页
			{% endblock %}
        {% block main %}
			    <p>这是首页面</p>
			{% endblock %}

6.URL链接和加载静态文件
    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;
    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径
    * 可以加载css文件，js文件 image文件
    image文件：
    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;

    js文件：
     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;

    css文件：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;

*url链接：使用url_for(视图函数名)，从而反转url 跳转页面
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;

url链接和加载静态文件的例子：
    Py文件：
        from flask import Flask,render_template

        app = Flask(__name__)


        @app.route(&apos;/&apos;)
        def index():
            return render_template(&apos;index.html&apos;)

        @app.route(&apos;/login/&apos;)
        def login():
            return render_template(&apos;login.html&apos;)

        if __name__ == &apos;__main__&apos;:
            app.run(debug=True)

    index.html文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;
            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;
        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    index.js文件：
        /**
         * Created by 栩森 on 2020/2/4.
         */

        alert(&apos;我是李坚&apos;)

    index.css文件：
           a{
                background: red;
            }

    login.html 文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;这是登陆页面&lt;/h1&gt;
        &lt;/body&gt;
        &lt;/html&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/09/Flask-jinja/" data-id="ck6eq92ul0000s0v345fzgnda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端学习随笔记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-02-09T02:55:00.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.css样式中：<br>    * id选择器： #id<br>    * class选择器： .class<br>    * 普通选择器： <h><br>    * 注意：如果想优先使用一个样式：在样式后面加入 ！important<br>    * 浮动： float left 左浮动  是将两行的东西放到同一行<br>            float right 右浮动  是将两行的东西放到同一行</p>
<hr>
<p>2.盒子模型：<br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>    Border(边框) - 围绕在内边距和内容外的边框。<br>    Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>    Content(内容) - 盒子的内容，显示文本和图像。</p>
<hr>
<p>3.css选择器<br>    * 分组选择器: h1,p1,h2<br>    * 后代选择器：.class p        .class div p<br>    * 相邻选择器 ： div+p<br>    * 普通兄弟选择器： div~p<br>    * 包含title属性对象选择器： [title],[id]<br>    * 伪类选择器： 标签名：自己定义的名字（使有相同的标签名的css精细化）</p>
<hr>
<p>4.javascript：具有动态交互的时，需要使用的语言<br>    * 在函数中定义参数的时候 有var时就是局部变量  没有的是的就是全局变量<br>        function func01(){<br>            var func01 = a<br>    }</p>
<hr>
<p>5.js运算符中 三元运算符的格式   ？xx1:xx2<br>    voteable = (age&lt;18)?’年龄太小’：’年龄达到’</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" data-id="ck6ehi3zs0000okv32y4ocldu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Migrate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/08/Flask-Migrate/" class="article-date">
  <time datetime="2020-02-08T12:03:10.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Flask-Migrate的作用：（代码在models_Migrate文件中）<br>    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，<br>    如果需要修改就必须要先删除表格。<br>    Flask-migrate就是为了解决不能在表格中添加或者修改内容的作用，可以解决在修改模型后<br>    直接映射到表中。</p>
<p>2.下载安装Flask-Migrate ： pip install flask-migrate</p>
<p>3.flask-migrate必须要借助 flask-script ，这个包中MigrateCommand 中的关于数据库的命令</p>
<p>4.flask-migrate 相关的命令：<br>    * python manage.py db init : 初始化迁移脚本的环境 只需要执行一次<br>    * python manage.py db migrate 生成迁移文件，每次修改都要执行<br>    * pythin manage.py db upgrade 将迁移的文件映射到数据中 每次需改都需要运行一次</p>
<p>5.要将数据库中的模型 madols.py 导入到manage文件中，这样才会找到相关的模块</p>
<p>6.各个文件的代码：<br>    config.py （同之前的一样）</p>
<pre><code>models_Migrate.py文件 ：

    from flask import Flask
    # 引入exts中的db
    from exts import db
    import config
    from models import Aritcle

    app = Flask(__name__)
    app.config.from_object(config)
    #防止循环引用 初始化app
    db.init_app(app)

    &apos;&apos;&apos;
    #手动将app推到服务器的栈里面（重点）
    with app.app_context():
        #这里通过db 将 models文件放入其中了（重点）
        db.create_all()
    &apos;&apos;&apos;

    @app.route(&apos;/&apos;)
    def hello_world():
        return &apos;Hello World!&apos;


    if __name__ == &apos;__main__&apos;:
        app.run(debug=True)

manage.py文件（重点）

    from flask_script import Manager
    from models_Migrate import app
    from flask_migrate import Migrate,MigrateCommand
    from exts import db
    from models import Aritcle

    manage = Manager(app)
    #1.要使用flasj_migrate 必须绑定app和db
    migrate = Migrate(app,db)

    #2. 把MigrateCommand 命令添加到 manager中
    manage.add_command(&apos;db&apos;,MigrateCommand)

    if __name__ == &apos;__main__&apos;:
        manage.run()

exts.py文件：（是为了防止循环应用app）
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()

models.py 文件：
    #引入exts 中的 db
    from exts import db
    class Aritcle(db.Model):
        id = db.Column(db.Integer,primary_key=True,autoincrement=True)
        title = db.Column(db.String(100),nullable=False)
        content = db.Column(db.Text,nullable=False)
        tags = db.Column(db.String(100),nullable=False)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/08/Flask-Migrate/" data-id="ck6dlbr88000018v36z2w2nw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/07/Flask-Script/" class="article-date">
  <time datetime="2020-02-07T11:50:40.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/07/Flask-Script/">Flask-Script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flask-Script的用处：<br>    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的<br>    服务器，设置数据库，定时任务等<br>Flask-Script的安装 ：     pip install flask-script  操作命令进行安装    </p>
<p>flask-Script :在创建好flask项目后 要在创建一个主文件manage.py<br>        manage.py的文件内容：</p>
<pre><code>#导入script的 Manager文件
from flask_script import Manager
#导入flask_scripr_demo文件中 app
from flask_script_demo import app

#初始化manage
manage = Manager(app)

#在命令行中可以执行的命令 装饰器
@manage.command
def runserver():
    print(&quot;服务器启动&quot;)

#因为是作为主app文件  则需要一下代码
if __name__== &apos;__main__&apos;:
    manage.run()</code></pre><p>在cmd运行命令的方法（必须在项目的目录下）<br>        python manage.py runserver<br>            显示：服务器启动</p>
<p>flask_script中有一集中控制数据库命令的文件db_script</p>
<pre><code>manage.py 中的内容：
    #导入script的 Manager文件
    from flask_script import Manager
    #导入flask_scripr_demo文件中 app
    from flask_script_demo import app
    #导入文件db_script 文件中的DBmanager对象
    from db_script import DBmanager

    #初始化manage
    manage = Manager(app)

    #在命令行中可以执行的命令 装饰器
    @manage.command
    def runserver():
        print(&quot;服务器启动&quot;)

    #将db_script.py中的命令放到主app中来
    manage.add_command(&apos;db&apos;,DBmanager)

    #因为是作为主app文件  则需要一下代码
    if __name__== &apos;__main__&apos;:
        manage.run()

db_script中的内容：
    #导入flask_script文件 中的manager
    from flask_script import Manager

    #初始化
    DBmanager = Manager()

    #设置命令
    @DBmanager.command
    def init():
        print(&quot;初始化服务器&quot;)

    @DBmanager.command
    def migrate():
        print(&quot;迁移成功&quot;)</code></pre><p>在cmd中运行的语句： python manage.py db init<br>                     显示结果：初始化服务器成功</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/07/Flask-Script/" data-id="ck6c8iu690000lcv3599ocweg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python做题时发现的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-02-06T02:40:56.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Python做题时发现的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>1.枚举函数的使用：enumerate()<br>    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)<br>    具体用用法实例:</p>
<pre><code>类型一：
    tmplist = [1234, 5677, 8899]
    for index,app_id in enumerate(tmplist):
        print index, app_id

    输出： 
    0 1234 
    1 5677 
    2 8899

类型二：（从下标1开始取值）
    tmplist = [1234, 5677, 8899]
    for index,app_id in enumerate(tmplist, 1):
        print index, app_id

    输出： 
    1 1234 
    2 5677 
    3 8899

类型三：使用range()或xrange()
         tmplist = [1234, 5677, 8899]
            for i in range(len(tmplist)):
                  print i,tmplist[i]

        输出： 
        0 1234 
        1 5677 
        2 8899</code></pre><hr>
<p>2.关于def add(x, y) -&gt; int:中符号-&gt;的意思：<br>-&gt;常常出现在python函数定义的函数名后面，为函数添加元数据,描述函数的返回类型，从而方便开发人员使用<br>    简而言之就是这个函数返回的类型会是 int 类型，如果不是可以强制性进行转换为int类型</p>
<ul>
<li>-&gt;  _Attr则表明函数返回的是一个外部可访问的类的私有变量</li>
</ul>
<hr>
<p>3.进制转化器：<br>    bin:二进制   cot:八进制   int:十进制  hex:十六进制</p>
<hr>
<p>4.Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数   decimal(小数)<br>     * 从浮点数据转换为Decimal类型<br>        #导入模块<br>        from decimal import getcontext,Decimal,Context<br>        mydec = Decimal.from_float(12.222)<br>        print(mydec)<br>        #结果为  12.222153432115212315……..精准的数字<br>    *  从字符串转化为Decimal类型<br>        mydec = Decimal(‘3.14’)<br>        print(mydec)<br>    * raw  将转义字符原样输出  r”hello\tworld”</p>
<hr>
<p>5.字符串（列表）里面的切片操作和下标取值操作（重点：包含开始 不包含结束）（切片没有下标越界）<br>    * 语法：[start:stop:step]  start:开始字符  stop:结束字符  step:步长  （其值可以省略）<br>    * step &gt; 0，从左往右切片       step &lt;0，从右往左切片<br>    * 左[0,1,2,3,……]   右[…….,-4-3,-2,-1]<br>    *  my_str=”mystr”<br>       print(my_str.count(‘m’))  查看字符串里面右几个m  也可以指定字符串的长度进行查看<br>       print(my_str.count(‘m’，1，3))     </p>
<hr>
<p> 6.判断字符是否为纯数字组成  str.isdigit()<br>   判断字符串是否为大写    str.isupper()<br>   判断字符串是否只包含字母： str.isalpha()<br>   判断字符串里的单词是否开头大写其他地方小写： str.istitle()<br>   判断字符串是否只只包含字母或者数字： str.isalnum()</p>
<p>   将字符串转换为大写： str.upper()<br>   将字符串转换为小写： str.lower()<br>   将字符中的单词第一字母大写其他字母小写 ：str.title()<br>   指定sep作为分割符号 将字符串切割成列表，分隔符可以任意设置（默认为空格）：<br>                           str.spilt(‘sep’)<br>       将列表用str拼接成一个大的字符串： ‘str’.join(list)(用str来拼接字符串)<br>       去除字符串中首尾的字符串，不带参数默认去除空格： str.strip([string])<br>       将字符串里的一个字符进行替代： str.replace(‘old’’new’[替换的个数])<br>       将字符中间对齐: str.center(witdth,’填充符号’)<br>       将字符左对齐:str.ljust(witdth,’填充符号’)<br>       将字符右对齐:str.rjust(witdth,’填充符号’)</p>
<pre><code>end 是可以表示最后字符串末尾的方式    end=&apos;&apos; 表示用空字符来连接字符
index函数的作用：可以查看两个字符串是否有相同的部分并且返回相同部分的下标（最开始部分）
    haystack.index(needle)  haystack 与 needle 是两个字符串
    返回的值为一个下标（int）</code></pre><hr>
<p>7.字符串格式化：<br>    {变量：[填充字符][对齐方式&lt;^&gt;][宽度][格式]}.format()</p>
<hr>
<p>8.math 模块 : import math<br>              math.方法<br>  getpass 模块： import getpass   隐藏密码的模块<br>                  getpass.getpass(“输入密码”)<br>  random模块： 随机生成一个范围内的数字<br>                  random.randint(0,100)  随机取0~100中的一个数字</p>
<hr>
<p>9.分支语句（if的三元运算）<br>    reslut = 条件成立的结果 if 条件 else 条件不成立的结果</p>
<hr>
<p>10.while语句：<br>    是符合该条件的情况下才会执行(注意 是需要一个结束的语句) 下面相关的内容<br>    while 条件：<br>        do sth<br>        break<br>    continue: 是指跳到循环的开头<br>    break: 表示退出循环</p>
<hr>
<p>11.for循环语句：<br>    for item in rang(3):<br>        do sth<br>    表循环几次  指定循环的次数</p>
<hr>
<ol start="12">
<li>自增长问题：<br>a+=i : a = a+1<br>a-=1 : a = a-1<br>自有在for循环语句中遍历出数字来 才能实现自增长的作用</li>
</ol>
<hr>
<p>13.find()函数的用法：<br>    find()方法检测字符串S中是否包含子字符串sub，如果指定start（开始）和end（结束）范围，<br>    则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值(如果包含多个字串，只返回最左边出现的索引值)，查找失败返回-1。<br>    以本题为例：<br>    s=”abcd1234”<br>    s.find(“cd”)，在字符串s中查找字串”cd”第一次出现时s中的索引值，因为索引从0开始，所以结果为2，注意s中出现多次cd的情况，例如：<br>    s=”abcd1234cd”<br>    s.find(“cd”)的结果依然是2，找不到时返回-1，比如：<br>    s=”1234”<br>    s.find(“cd”)的结果为-1</p>
<hr>
<p>14.zip()函数的用法：<br>    该函数配合 for循环语句进行使用  for i in zip(* 列表)<br>    具体的用法例子演示：</p>
<pre><code>&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]

&gt;&gt;&gt; a = [&quot;abc&quot;, &quot;abd&quot;, &quot;bbb&quot;]
&gt;&gt;&gt; b = zip(a)
&gt;&gt;&gt; for each in b:
...     print(each)
...
(&apos;abc&apos;,)
(&apos;abd&apos;,)
(&apos;bbb&apos;,)
如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表
&gt;&gt;&gt; b = zip(*a)
&gt;&gt;&gt; for each in b:
...     print(each)
...
(&apos;a&apos;, &apos;a&apos;, &apos;b&apos;)
(&apos;b&apos;, &apos;b&apos;, &apos;b&apos;)
(&apos;c&apos;, &apos;d&apos;, &apos;b&apos;)</code></pre><hr>
<p>15.set函数的使用（目前使用到的是他的去重的作用）<br>    x = set(‘worlld’)<br>    print(x):{‘r’,’o’,’l’,’w’,’d’}(形成了一个集合 并且去除了重复的项)<br>    还可以使用add和update对集合进行修改和添加</p>
<hr>
<p>16.python中随机生成一个数的函数：<br>    import random<br>    print(random.random())<br>    输出结果：0.9437475481805455</p>
<hr>
<p>17.python中format函数 ：<br>    一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能：</p>
<pre><code>print(&quot;网站名：{name}, 地址 {url}&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;))
# 通过字典设置参数
site = {&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;}
print(&quot;网站名：{name}, 地址 {url}&quot;.format(**site))
网站名：菜鸟教程, 地址 www.runoob.com

# 通过列表索引设置参数
my_list = [&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;]
print(&quot;网站名：{0[0]}, 地址 {0[1]}&quot;.format(my_list))  # &quot;0&quot; 是必须的
网站名：菜鸟教程, 地址 www.runoob.com</code></pre><hr>
<p>18.pack和unpack<br>    星号具有打包的功能 a,*b = (1,2,3,4,5) =&gt; a = 1  b = [2,3,4,5]</p>
<hr>
<p>19.匿名函数： 不需要命名的函数 只能有一个表达式 不用写return（一次性使用）<br>    lambda arg1(参数1) ，arg2(参数2):表达式（要返回的数据）</p>
<hr>
<p>20.sorted(iterable,key,reverse) 函数 ： 起到排序的作用<br>    key -&gt; 是指定一个排序的方式(可以放入函数)   iterable -&gt;是变量名  reverse -&gt; 是否逆序<br>            .join的作用是排列方式用 ‘’来隔开<br>     例子： mystr = “aaAbmcDikLNog”<br>           print(‘’.join(sorted(mtstr,key=str.upper)))</p>
<hr>
<ol start="21">
<li>在字符串中的replace函数：<br>replace()方法语法：str.replace(old, new,[max])<br>参数:<pre><code>old -- 将被替换的子字符串。
new -- 新字符串，用于替换old子字符串。
max -- 可选字符串, 替换不超过 max 次</code></pre>例子：<pre><code>str = &quot;this is string example....wow!!! this is really string&quot;;
print str.replace(&quot;is&quot;, &quot;was&quot;）
结果-&gt;thwas was string example....wow!!! thwas was really string</code></pre></li>
<li>if语句用一行的形式进行展示：<pre><code>c = a if a&gt;b else b</code></pre></li>
<li>get方法：<pre><code>Python 字典(Dictionary) get() 函数返回指定键的值，如果值不在字典中返回默认值。
dict.get(key, default=None)  如果没有key值 就会返回一个None</code></pre> pop方法：<pre><code>pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
list.pop([index=-1]) 默认移除列表中最后一个值</code></pre></li>
</ol>
<hr>
<h2 id="24-global是表示全局变量-咳可以在局部变量里面设置global就会变成全局变量"><a href="#24-global是表示全局变量-咳可以在局部变量里面设置global就会变成全局变量" class="headerlink" title="24.global是表示全局变量  咳可以在局部变量里面设置global就会变成全局变量"></a>24.global是表示全局变量  咳可以在局部变量里面设置global就会变成全局变量</h2><p>25.val()函数的功能： 将一组字符型数据的数字部分转换成相应的数值型数据<br>            例如：   x = “12 5fdsa DA456”;<br>                    那么 val(x)应该返回125 后面的456不能返回来</p>
<pre><code>x= &apos;123 456&apos; 
那么val(x)返回的是123456</code></pre><hr>
<p>26.next()函数：将迭代器里面的函数依次的返回出来<br>    b=[1,2,3,4]<br>    a=iter(b)<br>    next(a)会依次返回1,2,3,4，StopIteration，StopIteration..</p>
<hr>
<h2 id="27-可迭代对象：str-list-dict-tuple-set"><a href="#27-可迭代对象：str-list-dict-tuple-set" class="headerlink" title="27.可迭代对象：str list dict tuple set"></a>27.可迭代对象：str list dict tuple set</h2><p>28.在字典中 .get 方法 是会判断字典中是否有查找的这个值，如果没有<br>    就会返回一个None  或者自己设定一个值： .get(‘key’,’设定值’)<br>    字典中：删除的方法： dicts.pop(key):删出指定的字典key的值<br>                       dicts.popitem():删除键值对的  默认最后一个<br>    字典合并：dict1.update(dict2) =&gt;将dict2合并到dict1中<br>            dict(dict1,** dict2) =&gt;将dict1与dict2合并到生成的一个新字典中<br>    in与not in : 比较的是字典中key的比较<br>                或则进行 dict.values() 获取values值<br>    items() : 是可以获取 key和values 值</p>
<hr>
<p>29.集合：set()<br>    集合是无序的 不重复的数据组合<br>    集合是一个只包含key的字典   （hash对象就是不可变对象）<br>    集合会自动的去重<br>    集合坐添加的操作：s.add(iteme) =&gt; 添加一项<br>                     s.update(iteme) =&gt; 添加多项   s.update([10,37,42])<br>    集合的移除： s.remove()  =&gt; 如果移除的项没有在集合中 则会报错<br>                s.discard() =&gt; 移除的项么有在集合中 也不会报错<br>    集合的并集(|)和交集(&amp;)： 并集就是将两个集合加在一起  交集就是去公共部分<br>                            union 也是表示并集的方法<br>                            intersection  表示交际的方法<br>    集合的差集(-)：返回set中s中有t中没有的元素<br>                   s.different(t)      s-t<br>    集合的对称差集： 返回没有没有同时出现在两个集合中的元素<br>                    s.symmetric_different(t)       s^t</p>
<hr>
<p>30.JSON<br>    JSON(javaScript Object Notation)是一种轻量级的数据交换格式<br>    使用的时候需要导入  import JSON<br>    可以使用bejson 进行格式化的校验<br>    dumps 是将python中的字典转化为json中的str<br>    loads 是将json 中的实例 转化为 python中的 project  需要用’’’json 字符串’’’</p>
<hr>
<p>31.文件的基本操作：<br>    文本文件：<br>        优点：输出内容友好，不需要手动转换<br>        缺点：一个字符占一个字节，文件占用的存储空间较多，访问时效率不高<br>    二进制文件：<br>        优点：占用空间少，计算机读取时不需要进行准换<br>        缺点：无法直接以字符形式输出，必须要经过一个转换<br>    decode:解码（将二进制转化为汉字）<br>    encode:编码（将汉子转化为二进制）<br>    注意：解码和编码的方式要相同</p>
<hr>
<p>32.文件操作的格式：<br>    f = open(‘file/example’,encoding = ‘utf-8’)  打开文件<br>    f.readlines()    读文件<br>    f.close() 关闭文件</p>
<hr>
<p>33.打开文件Mode<br>    r  读模式   文件存在：正常打开   文件不存在：出错<br>    w  写模式   文件存在：写入，会覆盖原文件内容   文件不存在：创建新文件<br>    x  创建新文件 写入内容   文件存在：FileExistsError  文件不存在：创建新文件 写入<br>    a  追加模式  文件存在： 在原来的内容后追加    文件不存在：创建新文件<br>    b  二进制模式  python 下网络传输 只能用bytes模式  rb  rb+<br>    t  文本模式（默认）  r w x<br>    r+  可读写 文件不存咋会报错<br>    w+  可读写 将文件原内容清空 再写<br>    a+  可读可追加  在文件后面最佳内容<br>    x+  可读写  文件存在会报错</p>
<hr>
<p>34.判断文件编码：chardet<br>    安装 pip install chardet<br>    # 查看编码方式<br>    import chardet<br>    f = open(‘file/utf8’,mode=’rb’)<br>    print(chardet.detect(f.read()))<br>    结果：{‘encoding’: ‘utf-8’, ‘confidence’: 0.938125, ‘language’: ‘’}</p>
<hr>
<p>35.无需手动关闭文件的方法：（with语句）<br>    with open(‘file/utf8’,mode=’r’,encoding=’utf8’) as f1:<br>    for line in f1:<br>        print(line) </p>
<pre><code>查看文件是否关闭： f.closed  Ture:表示关闭  Fouls：没有关闭</code></pre><hr>
<p>36.读取文件内容：<br>    f.tell                 文件光标的位置（字节位置）                  整数int<br>    f.seek(cookie,whence=0)移动光标位置cookie：偏移量 whence：相对位置  NONE<br>    例子：f.seek(3,1)   1:表示当前位置  3:向右偏移三个位置   0：开始位置  2: 末尾<br>          f.seek(偏移量，相对位置)<br>    fp                     文件对象                  可迭代对象        IOWrapper<br>    fp.readlines()         返回当前到文末的一个列表                   list<br>    f.read()               返回当前到文末（字符串），可指定读几个字符串   str<br>    f.readline()           返回当前位置到行末                          str<br>    line.startwith(‘’)        表示每一行是否为某一个字符<br>       例子： for line in f:<br>                   print(‘’ if line.startswith(“#”) else line, end=’’)</p>
<hr>
<p>37.文件的写操作：<br>    import time<br>    with open(‘file/exaple’,’w’,encoding=”utf8”) as f :<br>    f.write(“第一次测试”)<br>    time.sleep(10)   #  这样的写入方式不是实时写入</p>
<p>   要实现实时写入方式的操作：  1.   f.flush()<br>                                2.   文件close后会写入<br>                                3.   当脚本休眠时间到后会写入<br>       实时写入<br>        import time<br>      with open(‘file/exaple’,’wb’,buffering=0) as f :<br>        while True:<br>            content = input(“&gt;”)<br>            #输入的字符串为q则退出   lower(): 转化为小写    strip():将开头可结尾的字符串转化为空<br>            if content.lower().strip() == ‘q’:<br>                break<br>            f.write(content.encode(‘utf8’))</p>
<hr>
<p>38.文件对象的其他方法：<br>    f.fileno()      返回文件描述符<br>    f.readline()    判断文件是否可读<br>    f.seekable()    指针是否可以移动<br>    f.truncate()    文件头开始截取指定参数的n个字节，其他的全部删除<br>    f.writable()    文件是否可以写<br>39.京东面试题：</p>
<pre><code>import random
def create_ip_file(filename:str) -&gt; None:
    with open(filename,&apos;w&apos;,encoding=&apos;utf8&apos;) as f:
        for i in range(1200):
            f.write(f&quot;172.25.254.{random.randint(1,255)}\n&quot;)

def sort_by_id(filename,topnum = 10):
    ip_dict = {}
    with open(filename,&apos;r&apos;,encoding=&apos;utf8&apos;) as f:
       for ip in f:
           ip = ip.strip()
           if ip in ip_dict:
                ip_dict[ip] += 1
           else:
               ip_dict[ip] = 1
    return sorted(ip_dict.items(),key=lambda x:x[1],reverse=True)[:topnum]

FILENAME = &apos;file/ips.txt&apos;
create_ip_file(FILENAME)
for key,vaual in sort_by_id(FILENAME,topnum=10):
    print(key,&apos;=&gt;&apos;,vaual)</code></pre><hr>
<p>40.OS库常用操作：<br>        os.getcwd()： 得到当前工作目录<br>        os.listdir(): 返回指定目录下的所有文件和目录名<br>        os.chdir(‘path’):转换目录<br>        os.path.isfile():检验给出的路径是否是一个文件<br>        os.path.isdir():检验给出的路径是否是一个目录<br>        os.path.isabs():判断是否是绝对路径<br>        os.path.exists():检验给出的路径是否存在<br>        os.path.split():反回一个路径的目录名和文件名<br>        os.path.splitext():分离扩展名<br>        os.path dirname():获取路径名<br>        os.path.basename():获取文件名<br>        os.path.getsize(filename):获取文件大小<br>        os.mkdir():    创建单个目录<br>        os.makedirs() ：创建多级目录<br>        os.mknod(): 创建空文件<br>        os.remove(): 删除文件<br>        os.rmdir(): 只能删除空目录<br>        os.removedirs(): 删除多个目录<br>        os.rename(old,new) : 重命名，文件或目录都是使用这个命令<br>        os.chmod():修改文件权限与时间戳<br>        os.stat(file) : 获取文件属性<br>41.在一个目录下创建文件，名字随机，将名字前面都加上李坚</p>
<pre><code>import os
import random
import string

def creat_files(path,filenum = 10) -&gt;None:
    if not os.path.exists(path):
        os.mkdir(path)
    # 返回path路径
    os.chdir(path)
    for i in range(filenum):
        filename = &apos;&apos;.join(random.choices(string.ascii_lowercase,k=6))
        f = open(filename,encoding=&apos;utf8&apos;,mode=&apos;w&apos;)
        f.close()

def rename_files(path,prefix) -&gt; None:
    for file in os.listdir(path):
        if not file.startswith(prefix):
            os.rename(f&apos;{path}/{file}&apos;,f&apos;{path}/{prefix}{file}&apos;)
print(os.getcwd())
creat_files(&apos;test03&apos;)

os.chdir(&apos;..&apos;)
print(os.getcwd())
rename_files(&apos;test03&apos;,&apos;[李坚]-&apos;)</code></pre><hr>
<p>42.更具自己命名的模块进行导入<br>    modname = input(‘请输入模块名：’)<br>    import importlib<br>    mod = importlib.import_module(modname)<br>    print(mod)</p>
<hr>
<p>43.重命名的模块，可以用as取别名<br>    from pack01 import tree as three01</p>
<hr>
<p>44.模块的相对导入：<br>    当前执行文件所在目录不是一个包<br>    子目录及更深的目录都是包<br>模块的导入顺序：<br>    1.第一级内置模块<br>    2.第二级sys.path路径列表<br>    3.如果没有找到就会出错</p>
<hr>
<p>45.python下划线的含义：<br>    以单下划线开头的：_ foo  表示私有的， 不能用from xxx import * 导入<br>    以双下划线开头的：__ foo 表示私有的，    不能用from xxx import * 导入<br>    以双下划线开头和结尾的：__ foo __  代表python中特殊方法专用的表示符<br>在直接导入模块的后  是可以使用这些私有对象的   只是在from xxx import * 不能导入私有<br><strong>all</strong> 这个模块是规定在from xxx import * 时候会导入的那个模块   可以是私有的<br>    __ all __ = [‘<em>model’,’model’]<br>_</em> init __文件   是导入某一个包的时候就会直接导入 __ init __.py ..  </p>
<hr>
<p>46.<strong>name</strong>  ：  当只是当作自身来执行的时候  print(<strong>name</strong>)  =&gt; <strong>main</strong><br>                 当模块导入的时候   from xxx import x =&gt;会显示<strong>name</strong>在那个包和文件中<br>   <strong>file</strong> : 打印模块路径<br>   <strong>doc</strong>: 打印当前文档的注释信息    </p>
<hr>
<ol start="47">
<li>if <strong>name</strong> == ‘<strong>main</strong>‘：<pre><code>func()</code></pre>表示：当执行文件自身的时候就会调用函数， 否则就不会调用函数（导入的时候不需要调用）</li>
</ol>
<hr>
<p>48.断言：  assert     一般在做测试的时候使用<br>        assert 1+2==5,’出错了’  =&gt;  显示：AssertionError：出错了</p>
<hr>
<p>49.异常处理<br>    try:<br>        执行的代码<br>    except 错误类型 as 接收错误详细的变量:（指定接受的错误类型）  except:(所有的错误类型)<br>        处理的内容<br>    except 错误类型 as 接收错误详细的变量(ex):（指定接受的错误类型）<br>        处理的内容                                                        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ck6a8svyf0000u8v3h9b4554g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-SQLAlchemy-DateBase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/04/Flask-SQLAlchemy-DateBase/" class="article-date">
  <time datetime="2020-02-04T07:21:13.000Z" itemprop="datePublished">2020-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/04/Flask-SQLAlchemy-DateBase/">Flask-SQLAlchemy-DateBase</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.MySQL-python中间件的介绍和安装<br>     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装<br>     * 在window下需要到’<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;</a><br>      这个网址下载对应的python版本的中间件<br>          对应的命令： pip install mysqlclient-1.4.6-cp38-cp38-win_amd64.whl<br>     * 注意：如果与python的版本不符合就会出现报错的现象</p>
<p>2.ORM与Flask-SQLALchemy的安装和介绍<br>    * ORM: Objct Relationship Mapping (模型关系映射)<br>    * flask-aqlalchemy是一套ORM框架<br>    * ORM的好处：可以不适用sql语句进行对数据的修改 ，可以直接使用类的语句就好.一个表<br>        就是一个类，一条数据就是一个对象<br>    * 安装Flask-SQLALchemy： pip install flask-sqlalchemy</p>
<pre><code>例子： class Ariticle(Moble):
        id = int()
        title = String()
        content = Text()
       #实例化
           article = Article(id = 1,title = &apos;aaa&apos;,content = &apos;bbb&apos;)
       #加入表格或者说类中
            add(article)
       #修改数据内容
             article.title = &apos;ccc&apos;
             update(article)
       #删除内容
             delete(article)</code></pre><p>3.SQLALchemy连接数据库<br>    SQLALchemy :SQLAlchemy采用简单的Python语言，为高效和高性能的数据库访问设计<br>                是访问和操作数据库的开源脚本<br>    * 在实际操作过程中遇到的问题：<br>        * 在Mysql workbeath 中修改连接密码：右键出现Edit connections 进行点击 进入后点击store in Vault 就可以进行修改<br>        * 如何进入Mysql 命令行的形式：找到Mysql sever 下的bin目录 再就如命令行输入<br>            ./mysql -u root -p<br>        * 创建一个新的数据库 命令     creat datebase  数据库名  charset  utf8<br>    使用flask_sqlalchemy中的SQLALchemy进行初始化：</p>
<pre><code>    #调用函数
    from flask_sqlalchemy import SQLAlchemy
    app = Flask(__name__)
    #初始化一个对象
    db = SQLAlchemy(app)

设置配置文件&apos;config.py&apos;文件中添加一下配置
#dialect+driver://username:password@host:post/database


    DIALECT = &apos;mysql&apos;
    DRIVER = &quot;mysqldb&quot;
    USERNAME = &apos;root&apos;
    PASSWORD = &apos;root&apos;
    HOST = &apos;127.0.0.1&apos;
    PORT = &apos;3306&apos;
    DATABASE = &apos;db_demo1&apos;
    SQLALCHEMY_DATABASE_URI = &quot;{}+{}://{}:{}@{}:{}/{}?charset=utf8&quot;.format(DIALECT,
                                                   DRIVER,USERNAME,
                                                   PASSWORD,HOST,PORT,
                                                   DATABASE)
    #去除警告信息
    SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>   在app文件中，添加配置文件，并且进行测试</p>
<pre><code>from flask import Flask
   #调用函数
from flask_sqlalchemy import SQLAlchemy
#引入config文件
import config
app = Flask(__name__)
#重点（不明白）
app.config.from_object(config)
#初始化一个对象
db = SQLAlchemy(app)
#进行测试
db.create_all()</code></pre><p>4.SQLALchemy模型与表映射<br>    * 创建的这个表可以称作为一个类，这个类必须要继承自’db.Model’，然后映射到表中的时候<br>       必须写成’db.Column’的数据类型<br>    * 数据类型：<br>        * ‘db.Integer’代表的是整型（int）<br>        * ‘db.String’ 代表的是’varcher’,需要指定最长的长度<br>        * ‘db.Text’代表的是 ‘text’<br>    * 参数类型：<br>        * ‘primary_key’:代表的是将字段是否设置为主键<br>        * ‘autoincrement’: 代表的是这个主键是否为自增长的<br>        * ‘nullable’ : 表示该字段是否可以为空，数据库默认是能为空<br>    * 最后需要用’db.create_all’来将模型真正的创建到数据库中</p>
<p>   在实践过程中遇到的问题：</p>
<ul>
<li><p>对数据库的连接不熟练，以及配置文件的编写</p>
<pre><code>from flask import Flask</code></pre><p>   from flask_sqlalchemy import SQLAlchemy<br>   import config<br>   app = Flask(<strong>name</strong>)<br>   app.config.from_object(config)<br>   #初始化对象<br>   db = SQLAlchemy(app)</p>
<p>配置文件的编写：</p>
<h1 id="dialect-driver-username-password-host-post-database"><a href="#dialect-driver-username-password-host-post-database" class="headerlink" title="dialect+driver://username:password@host:post/database"></a>dialect+driver://username:password@host:post/database</h1><p>   DIALECT = ‘mysql’<br>   DRIVER = ‘mysqldb’<br>   USERNAME = ‘root’<br>   PASSWORD = ‘root’<br>   HOST = ‘127.0.0.1’<br>   POST = ‘3306’<br>   DATABASE = ‘db_mode2’<br>   SQLALCHEMY_DATABASE_URI = ‘{}+{}://{}:{}@{}:{}/{}?charset=utf8’.format(DIALECT,</p>
<pre><code>DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)</code></pre><p>   SQLALCHEMY_TRACK_MODIFICATIONS = False</p>
</li>
<li><p>在数据库中需要使用的语句：</p>
<pre><code>创建数据库： create database 数据库名 charset utf8
查看数据库中的表 ： show tables 
查看表的内容： desc 表名
使用那个数据库： use 数据库名
展现创建的表格： show create table 表名
删除表格： drop table 表名</code></pre><ul>
<li><p>将SQL语句转化为py文件中类的语句<br>  ‘’’<br>SQL语句中创建表格<br>   create table article(</p>
<pre><code>id int primary key autoincrement,
title varchar(100) not null,
content text not null,</code></pre><p>   )<br>‘’’</p>
<p>class Article(db.Model):<br>   <strong>tablename</strong> =’article’<br>   id = db.Column(db.Integer,primary_key=True,autoincrement=True)<br>   title = db.Column(db.String(100),nullable=False)<br>   content = db.Column(db.Text,nullable=False)</p>
</li>
</ul>
</li>
</ul>
<p>创建一个表的例子：</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config
app = Flask(__name__)
app.config.from_object(config)
#初始化对象
db = SQLAlchemy(app)
&apos;&apos;&apos;
SQL语句中创建表格
    create table article(
        id int primary key autoincrement,
        title varchar(100) not null,
        content text not null,
    )
&apos;&apos;&apos;
class Article(db.Model):
    __tablename__ =&apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    content = db.Column(db.Text,nullable=False)
db.create_all()
@app.route(&apos;/&apos;)
def hello_world():
    return &apos;Hello World!&apos;
if __name__ == &apos;__main__&apos;:
    app.run()</code></pre><p>config 配置文件</p>
<pre><code># dialect+driver://username:password@host:post/database
DIALECT = &apos;mysql&apos;
DRIVER = &apos;mysqldb&apos;
USERNAME = &apos;root&apos;
PASSWORD = &apos;root&apos;
HOST = &apos;127.0.0.1&apos;
POST = &apos;3306&apos;
DATABASE = &apos;db_mode2&apos;
SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset=utf8&apos;.format(DIALECT,
                               DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)
SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>5.SQLALchemy 数据库的增删查改</p>
<pre><code>#数据库增加数据
    article = Article(title = &apos;aaa&apos;,content = &apos;bbb&apos;)
    db.session.add(article)
    #事务相应（操作的开关）
    db.session.commit()

#数据库查找数据
    #SQL： select * from article where article.title=&apos;aaa&apos;;
    #query:查找   fileter：过滤
    article1 = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    #返回的是一个列表 之后的操作可以根据列表的操作进行
    print(&apos;title:%s&apos; % article1.title)
    print(&apos;content:%s&apos; % article1.content)

#数据的修改
    #1.先要查找出修改的数据
    article1 = Article.query.filter(Article.title==&apos;aaa&apos;)[0,1]
    #2.在需要修改的地方进行修改
    article1.title = &apos;new title&apos;
    #3.提交事务
    db.session.commit()

#删除数据
    #1.把需要删除的数据查找出来
    article1 = Article.query.filter(Article.content == &apos;bbb&apos;)[0]
     #2.删除数据
    db.session.delete(article1)
    #3.事务处理
    db.session.commit()</code></pre><p>6.Flask-SQLALchemy 外键及其关系<br>    * 连接数据库（跟以上的操作一样）<br>    * 创建两个表（user article）</p>
<pre><code> #创建用户表(user)
 &apos;&apos;&apos;
 SQL语句：
         create table users(
         id int primary key autoincrement,
         username varchar(100) not null
 )
 &apos;&apos;&apos;
 class User(db.Model):
     __tablename__ = &apos;user&apos;
     id = db.Column(db.Integer,primary_key= True,autoincrement=True)
     username = db.Column(db.String(100),nullable=True)

  #创建文章表
     &apos;&apos;&apos;
     SQL语句：
             create table article(
                 id int primary key autoincrement,
                 title varchar(100) not null,
                 content text not null,
                 author_id int,
                 foreign key &apos;author_id&apos; references &apos;user_id&apos;
     )        
     &apos;&apos;&apos;
     class Article(db.Model):
         __tablename__ =&apos;article&apos;
         id = db.Column(db.Integer,primary_key=True,autoincrement=True)
         title = db.Column(db.String(100),nullable=False)
         content = db.Column(db.Text,nullable=False)
         #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
         author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))

    * 映射到数据库中：   db.create_all()
        注意： db.create_all() 它只会部署一次，如果中途在类里面去需改表的属性是没有任何用处的，只有把表格进行删除，再
        重新创建一个表格才能添加其他的属性

* 在用户表中添加用户
     user1 = User(username = &apos;lijian&apos;)
     db.session.add(user1)
     db.session.commit()</code></pre><ul>
<li><p>在文章表中添加文章</p>
<pre><code>article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)
db.session.add(article)
db.session.commit()</code></pre><ul>
<li><p>实现需求：查找文章名称为aaa的作者</p>
<pre><code>这是需求的普通写法:没有起到简化的作用 再Flask中不会使用
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author_id)
    author_id = article.author_id
    user = User.query.filter(User.id == author_id)[0]
    print(user.username)

再Flask-SQLALchemy-Darabases中使用的方法:
    * 先要在class类中就行设置;

            class Article(db.Model):
            __tablename__ =&apos;article&apos;
            id = db.Column(db.Integer,primary_key=True,autoincrement=True)
            title = db.Column(db.String(100),nullable=False)
            content = db.Column(db.Text,nullable=False)
            #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
            author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))
    #重点：db.relationship是表述关系的连接参数  db.backre是表示关系反转的参数
    #正向引用（relationship）与反向引用（backref）（User表与article表）        #正向关系：是只通过article表里面的外键来与User表中的主键进行连接             然后读取相关信息            
    #通过文章名称找出作者名称
    #反转关系：是只通过User中的主键来连接article中的外键，然后读取article中的相关信息             
    #通过作者找出他写作的文章
    #模块名=db.relationship(&apos;关联的类名&apos;，backref = db.backref(&apos;自定义参数&apos;))
            author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))
    * 实现通过文章名称查找作者：

            article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
            #通过 article.author.usename 来找出文章的作者
            print(article.author.username)</code></pre><ul>
<li><p>实现需求：通过作者名找出其作品</p>
<pre><code>user = User.query.filter(User.username == &apos;lijian&apos;)[0]
#通过 user.articles.title 来查找作者的文章
result = user.articles
for article in result:
    print(article.title)</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实例：数据库的连接 表的制作 数据的的添加 实现通过作者找出他的所有文章 通过文章找出作者</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config

app = Flask(__name__)
app.config.from_object(config)
db = SQLAlchemy(app)
#创建用户表
&apos;&apos;&apos;
SQL语句：
        create table users(
        id int primary key autoincrement,
        username varchar(100) not null
)
&apos;&apos;&apos;
class User(db.Model):
    __tablename__ = &apos;user&apos;
    id = db.Column(db.Integer,primary_key= True,autoincrement=True)
    username = db.Column(db.String(100),nullable=True)
#创建文章表
&apos;&apos;&apos;
SQL语句：
        create table article(
            id int primary key autoincrement,
            title varchar(100) not null,
            content text not null,
            author_id int,
            foreign key &apos;author_id&apos; references &apos;user_id&apos;
)        
&apos;&apos;&apos;
class Article(db.Model):
    __tablename__ =&apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    content = db.Column(db.Text,nullable=False)
    #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
    author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))
    #正向引用（relationship）与反向引用（backref）
    author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))
 #实现映射到表中
db.create_all()
##########
@app.route(&apos;/&apos;)
def hello_world():
    &apos;&apos;&apos;
    #在用户表中添加用户
    user1 = User(username = &apos;lijian&apos;)
    db.session.add(user1)
    db.session.commit()
    &apos;&apos;&apos;

    #添加作品信息
    &apos;&apos;&apos;
    article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)
    db.session.add(article)
    db.session.commit()
    &apos;&apos;&apos;
    #需求：寻找标题文章为aaa的作者
    &apos;&apos;&apos;
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author_id)
    author_id = article.author_id
    user = User.query.filter(User.id == author_id)[0]
    print(user.username)
    &apos;&apos;&apos;
    #上述需求的简化:
    #根据文章名称查找作者
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author.username)
    print(&quot;*&quot;*20)

    #需求 找到lijian写过的所有的文章
    user = User.query.filter(User.username == &apos;lijian&apos;)[0]
    result = user.articles
    for article in result:
        print(article.title)
    &apos;&apos;&apos;
    #先添加一篇文章
    article = Article(title=&apos;111&apos;,content=&apos;222&apos;,author_id=1 )
    db.session.add(article)
    db.session.commit()
    &apos;&apos;&apos;
    return &apos;Hello World!&apos;
if __name__ == &apos;__main__&apos;:
    app.run(debug=True)</code></pre><p> 数据库连接的config 文件：</p>
<pre><code> #dialect+driver://username:password@host:post/database
DIALECT = &apos;mysql&apos;
DRIVER = &apos;mysqldb&apos;
USERNAME = &apos;root&apos;
PASSWORD = &apos;root&apos;
HOST = &apos;127.0.0.1&apos;
POST = &apos;3306&apos;
DATABASE = &apos;db_demo3&apos;
SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset utf8&apos;.format(DIALECT,
                            DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)
SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><hr>
<p>7.SQLALchemy连接数据库中多对多关系<br>    * 配置相关的config 文件 与之前一样</p>
<pre><code>* 设置关联的语句（重点）（在class Aritcle 中进行设置）（secondary 设置中间表的连接）
    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))

* 需要建立三个表格 article  tag  article_tag
                                            article与tag 表格的建立与之前的一样.
  article_tag 表格的建立：（db.Table 进行建立）
      #关联表
    article_tag = db.Table(&apos;article_tag&apos;,
    db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),
    db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)
                   )

    * 数据的插入：（ article1.article.append(tag1) 这个语句是重点）
    article1 = Article(title = &apos;aaa&apos;)
    article2 = Article(title = &apos;bbb&apos;)
    tag1 = Tag(name = &apos;111&apos;)
    tag2 = Tag(name = &apos;222&apos;)
    #article1下有哪些标签  一个article1有多个标签（重点）
    article1.article.append(tag1)
    article1.article.append(tag2)
    # article2下有哪些标签  一个article2有多个标签（重点）
    article2.article.append(tag1)
    article2.article.append(tag2)
    db.session.add(article1)
    db.session.add(article2)
    db.session.add(tag1)
    db.session.add(tag2)
    db.session.commit()</code></pre><p>案例：连接数据库 创建表格包含中间表 插入数据 关联数据 实现通过文章找Tag(免去config文件)</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config

app = Flask(__name__)
app.config.from_object(config)
db= SQLAlchemy(app)

&quot;&quot;&quot;
SQL语句：
    创建article表
    create table article(
        id int primary key autoincrement
        title varachar(100) not null
    )
    创建tag表
    create table tag(
        id int primary key autioncrement
        name varachar(50) not null
    )
    创建中间表
    create table article_tag(
        article_id int
        tag_id int
        primay key (&apos;article_id&apos;,&apos;tag_id&apos;)
        foreign_key &apos;article_id&apos; references &apos;article&apos;
        foreign_key &apos;tag_id&apos; references &apos;tag&apos;
    )

&quot;&quot;&quot;
#关联表
article_tag = db.Table(&apos;article_tag&apos;,
        db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),
        db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)
                       )

class Article(db.Model):
    __tablename__ = &apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    #这是外键的是指 以及表的关联过程  secondary
    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))

class Tag(db.Model):
    __tablename__ = &apos;tag&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    name = db.Column(db.String(50),nullable=False)

db.create_all()

@app.route(&apos;/&apos;)
def hello_world():
    &apos;&apos;&apos;
    article1 = Article(title = &apos;aaa&apos;)
    article2 = Article(title = &apos;bbb&apos;)
    tag1 = Tag(name = &apos;111&apos;)
    tag2 = Tag(name = &apos;222&apos;)
    #article1下有哪些标签  一个article1有多个标签
    article1.article.append(tag1)
    article1.article.append(tag2)
    # article2下有哪些标签  一个article2有多个标签
    article2.article.append(tag1)
    article2.article.append(tag2)
    db.session.add(article1)
    db.session.add(article2)
    db.session.add(tag1)
    db.session.add(tag2)
    db.session.commit()
    &apos;&apos;&apos;
    article1= Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    tags = article1.article
    for tag in tags:
        print(tag.name)

    return &apos;Hello World!&apos;

if __name__ == &apos;__main__&apos;:
    app.run(debug=True)</code></pre><hr>
<p>8.在分开models中解决循环引用<br>     分开models 的目的： 是为了更好的管理代码<br>     解决循环引用的方法：  是将add文件 分割开来  可以同时被几个文件引用 不会产生循环</p>
<pre><code>models.sep文件：（主文件）
    from flask import Flask
    # 引入models中的 Ariticle
    from models import Ariticle
    # 引入exts中的db
    from exts import db

    app = Flask(__name__)
    #防止循环引用 初始化app
    db.init_app(app)

    db.create_all()

    @app.route(&apos;/&apos;)
    def hello_world():
        return &apos;Hello World!&apos;

    if __name__ == &apos;__main__&apos;:
        app.run()

exts文件：
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()

models.py 文件：
    #引入exts 中的 db
    from exts import db
    class Ariticle(db.Model):
        __table__ = &apos;article&apos;
        id = db.Column(db.Integer, primary_key=True, autoincrement=True)
        title = db.Column(db.String(100), nullable=False)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/" data-id="ck67xvsxx0000a8v3e3e4ga4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask--urls和视图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/" class="article-date">
  <time datetime="2020-02-02T09:32:35.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/">Flask--urls和视图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>1.对代码的解析：
#encoding UTF-8
#模块的导入
from flask import Flask
#初始化一个Flask对象
#Flask()
#需要传递一个参数__name__
#1. 方便flask框架去寻找资源
#2. 方便flask插件 比如Flask-Sqlalchemy出现错误的时候，去寻找问题所在的位置
app = Flask(__name__)

# @app.route是一个装饰器
# @开头，并且在函数的上面，说明是一个装饰器
# 这个装饰器的作用，是做一个URL与视图函数的映射
# 127.0.0.1:5000/  去请求hello_woeld 这个函数  然后将结果返回到浏览器
@app.route(&apos;/&apos;)
def hello_world():
    return &apos;我是第一个程序&apos;

# 如果当前这个文件是作为入口程序进行运行， 那么就执行app.run()
if __name__ == &apos;__main__&apos;:
    #app.run()
    #启动一个应用服务器  来接受用户的请求
    #while True
    #   listen()
    #设置debug模式  将错误直接显示到网页上面
    app.run(debug= True)

2.设置debug模式
    a.在app.run()中传入一个关键字参数debug,例如：run(debug = Ture)，就设置当前项目为debug模式。

    b.debug模式的两大功能：
        * 当程序出现问题的时候，可以在页面中看到错误的信息和出错的位置
        * 只要修改项目中的python文件，程序就会自动的加载，不需要手动的重新启动服务器。
      具体的案例如下：
          from flask import Flask

        app = Flask(__name__)

        @app.route(&apos;/&apos;)
        def hello_world():
            return &apos;我是第一个程序&apos;

        if __name__ == &apos;__main__&apos;:
            #设置debug模式  将错误直接显示到网页上面
            app.run(debug= True)

3.使用配置文件
    * 新建一个&apos;config.py&apos;文件
    * 在主要的app文件中导入这个文件，并且配置到app文件中
        &apos;&apos;&apos;
        import config
        app.config.from_object(config)
        &apos;&apos;&apos;
    * 还有许多的其他参数也可以放置在文件中，比如&apos;SECRET_KEY&apos; 和 &apos;SQLALCHEMY&apos;这些配置文件

    主app文件实例如下：（其实主要的作用还是和debug模式一样的作用）
        from flask import Flask
        #导入config文件
        import config

        app = Flask(__name__)
        #加入config文件的配置
        app.config.from_object(config)

        @app.route(&apos;/&apos;)
        def hello_world():
            return &apos;我是第一个程序&apos;

        if __name__ == &apos;__main__&apos;:

            app.run()

    config文件的配置：（可以加入很多的参数 注意的是需要将文件导入和对文件配置的导入使用）
        DEBUG = True


4.url传递参数
    * 参数的作用： 可以在相同的URL，当时不指定相同的参数，来加载不同的数据。
                例如：http://127.0.0.1:5000/URL/参数        
    * 在flask中如何使用参数：
        &apos;&apos;&apos;
            @app.route(&apos;/article/&lt;id&gt;&apos;)
            def article(id):
                return &apos;您请求的参数是 ： %S&apos; % id
        &apos;&apos;&apos;
           注意：参数必须放在&lt;&gt;中    
                视图函数中需要放在和URL中的id相同的参数（就是函数括号里面的参数必须与id相同）

    url传递参数的例子：
            from flask import Flask
            app = Flask(__name__)
            #视图函数
            @app.route(&apos;/login/&lt;id&gt;&apos;)
            def login(id):
                return &quot;您请求的参数是 % S&quot; % id

            if __name__ == &apos;__main__&apos;:
                app.run(debug=True)


5.URL反转（需要一个模板：url_for）
    * 什么叫做反转URL： 从视图函数到url的转换叫做反转URL
      （根据视图的函数名字 可以直接切换到URL的参数）
    * 反转URL的用处：
        * 在页面重定向的时候，会使用url反转
        * 在模板中，也会使用url反转

    Url反转例子：
            from flask import Flask,url_for

            app = Flask(__name__)

            @app.route(&apos;/&apos;)
            def index():
                print(url_for(&apos;my_list&apos;))
                print(url_for(&apos;question&apos;),id = &quot;aaaa&quot;)
                return &apos;这是首页&apos;

            @app.route(&apos;/list/&apos;)
            def my_list():
                return &quot;这是登陆页面&quot;

            @app.route(&apos;/question/&lt;id&gt;&apos;)
            def question(id):
                return &apos;这是发布问答的页面:%S&apos; % id

            if __name__ == &apos;__main__&apos;:
                app.run(debug= True)

6.重定向和页面跳转：(需要两个模板： redirect  url_for)
    * 用处： 在用户访问一些需要登陆的页面的时候，如果用户没有登陆用户则会跳转到用户的登陆界面
    * 代码的实现：
        &apos;&apos;&apos;
            from flask import redirect,url_for
            redirect(url_for(&apos;login&apos;))
        &apos;&apos;&apos;

    重定向和页面跳转的代码演示：
        from flask import Flask,redirect,url_for

        app = Flask(__name__)

            @app.route(&apos;/&apos;)
            def index():
                   question_url = url_for(&apos;question&apos;,id = 1)
                   return redirect(question_url)
                   return &apos;这是首页&apos;

            @app.route(&apos;/login/&apos;)
            def login():
                return &quot;这是登陆页面&quot;

            @app.route(&apos;/question/&lt;id&gt;&apos;)
            # 关键点   条件性代码
            def question(id):
                if id==&quot;1&quot;:
                    return &apos;这是发布问答的页面&apos;
                else:
                    return redirect(url_for(&quot;login&quot;))
            if __name__ == &apos;__main__&apos;:
                app.run(debug=True)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/" data-id="ck66f1y110000iov30i1r1qp6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="cost-hexo的基本操作" class="article article-type-cost" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-01-24T05:11:04.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">hexo的基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.创建一个新的文件：<br>                hexo new post 文件名<br>                hexo new [layout(布局)] -p 路径 文件名</p>
<p>2.上传到网页并且进行部署（同时出现在GitHub上面）:<br>                hexo d -g</p>
<p>3.注意：在文档中有渲染的语法，或则有重定向的语法就会报错<br>        Template render error<br>        则需要进行注释或者标注</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="ck5rrkdl300009ov3a2yyhyw7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Li-jian/" style="font-size: 10px;">Li jian</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" style="font-size: 10px;">代码在models_Migrate文件中</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/13/flask-jinja2/">flask_jinja2</a>
          </li>
        
          <li>
            <a href="/2020/02/09/Flask-jinja/">Flask-jinja</a>
          </li>
        
          <li>
            <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
          </li>
        
          <li>
            <a href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
          </li>
        
          <li>
            <a href="/2020/02/07/Flask-Script/">Flask-Script</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 li jian<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
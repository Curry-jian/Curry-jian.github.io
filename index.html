<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Curry-jian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Curry-jian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Curry-jian">
<meta property="article:author" content="li jian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Curry-jian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Curry-jian</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux基本命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-03-05T14:40:31.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">Linux基本命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.系统信息<br>    arch 显示机器的处理器架构(1)<br>    uname -m 显示机器的处理器架构(2)<br>    uname -r 显示正在使用的内核版本<br>    dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>    hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>    hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>    cat /proc/cpuinfo 显示CPU info的信息<br>    cat /proc/interrupts 显示中断<br>    cat /proc/meminfo 校验内存使用<br>    cat /proc/swaps 显示哪些swap被使用<br>    cat /proc/version 显示内核的版本<br>    cat /proc/net/dev 显示网络适配器及统计<br>    cat /proc/mounts 显示已加载的文件系统<br>    lspci -tv 罗列 PCI 设备<br>    lsusb -tv 显示 USB 设备<br>    date 显示系统日期<br>    cal 2007 显示2007年的日历表<br>    date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>    clock -w 将时间修改保存到 BIOS </p>
<p>2.关机 (系统的关机、重启以及登出 )<br>    shutdown -h now 关闭系统(1)<br>    init 0 关闭系统(2)<br>    telinit 0 关闭系统(3)<br>    shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>    shutdown -c 取消按预定时间关闭系统<br>    shutdown -r now 重启(1)<br>    reboot 重启(2)<br>    logout 注销 </p>
<p>3.文件和目录<br>    cd /home 进入 ‘/ home’ 目录’<br>    cd .. 返回上一级目录<br>    cd ../.. 返回上两级目录<br>    cd 进入个人的主目录<br>    cd ~user1 进入个人的主目录<br>    cd - 返回上次所在的目录<br>    pwd 显示工作路径<br>    ls 查看目录中的文件<br>    ls -F 查看目录中的文件<br>    ls -l 显示文件和目录的详细资料<br>    ls -a 显示隐藏文件<br>    ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>    tree 显示文件和目录由根目录开始的树形结构(1)<br>    lstree 显示文件和目录由根目录开始的树形结构(2)<br>    mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>    mkdir dir1 dir2 同时创建两个目录<br>    mkdir -p /tmp/dir1/dir2 创建一个目录树<br>    rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>    rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>    rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>    rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>    mv dir1 new_dir 重命名/移动 一个目录<br>    cp file1 file2 复制一个文件<br>    cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>    cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>    cp -a dir1 dir2 复制一个目录<br>    ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>    ln file1 lnk1 创建一个指向文件或目录的物理链接<br>    touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>    file file1 outputs the mime type of the file as text<br>    iconv -l 列出已知的编码<br>    iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>    find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p>
<p>4.文件搜索<br>     find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>    find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>    find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>    find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>    find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>    find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>    find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>    locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>    whereis halt 显示一个二进制文件、源码或man的位置<br>    which halt 显示一个二进制文件或可执行文件的完整路径 </p>
<p>5.挂载一个文件系统<br>    mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>    umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>    fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>    umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>    mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>    mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>    mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>    mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>    mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>    mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>    mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>    mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p>
<p>6.磁盘空间<br>    df -h 显示已经挂载的分区列表<br>    ls -lSr |more 以尺寸大小排列文件和目录<br>    du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>    du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>    rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>    dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p>
<p>7.用户和群组<br>    groupadd group_name 创建一个新用户组<br>    groupdel group_name 删除一个用户组<br>    groupmod -n new_group_name old_group_name 重命名一个用户组<br>    useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>    useradd user1 创建一个新用户<br>    userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>    usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>    passwd 修改口令<br>    passwd user1 修改一个用户的口令 (只允许root执行)<br>    chage -E 2005-12-31 user1 设置用户口令的失效期限<br>    pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>    grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>    newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p>
<p>8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消<br>    ls -lh 显示权限<br>    ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>    chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>    chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>    chown user1 file1 改变一个文件的所有人属性<br>    chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>    chgrp group1 file1 改变文件的群组<br>    chown user1:group1 file1 改变一个文件的所有人和群组属性<br>    find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>    chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>    chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>    chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>    chmod g-s /home/public 禁用一个目录的 SGID 位<br>    chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>    chmod o-t /home/public 禁用一个目录的 STIKY 位 </p>
<ol start="9">
<li>chattr +a file1 只允许以追加方式读写文件<br> chattr +c file1 允许这个文件能被内核自动压缩/解压<br> chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br> chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br> chattr +s file1 允许一个文件被安全地删除<br> chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br> chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br> lsattr 显示特殊的属性 </li>
</ol>
<p>10.打包和压缩文件<br>    bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>    bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>    gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>    gzip file1 压缩一个叫做 ‘file1’的文件<br>    gzip -9 file1 最大程度压缩<br>    rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>    rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>    rar x file1.rar 解压rar包<br>    unrar x file1.rar 解压rar包<br>    tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>    tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>    tar -tf archive.tar 显示一个包中的内容<br>    tar -xvf archive.tar 释放一个包<br>    tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>    tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>    tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>    tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>    tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>    zip file1.zip file1 创建一个zip格式的压缩包<br>    zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>    unzip file1.zip 解压一个zip格式压缩包 </p>
<p>11.RPM 包 - （Fedora, Redhat及类似系统）<br>     rpm -ivh package.rpm 安装一个rpm包<br>    rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>    rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>    rpm -F package.rpm 更新一个确定已经安装的rpm包<br>    rpm -e package_name.rpm 删除一个rpm包<br>    rpm -qa 显示系统中所有已经安装的rpm包<br>    rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>    rpm -qi package_name 获取一个已安装包的特殊信息<br>    rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>    rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>    rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>    rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>    rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>    rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>    rpm -q package_name –changelog 显示一个rpm包的修改历史<br>    rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>    rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>    rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>    rpm –checksig package.rpm 确认一个rpm包的完整性<br>    rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>    rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>    rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>    rpm -Vp package.rpm 确认一个rpm包还未安装<br>    rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>    rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>    rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p>
<p>12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）<br>    yum install package_name 下载并安装一个rpm包<br>    yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>    yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>    yum update package_name 更新一个rpm包<br>    yum remove package_name 删除一个rpm包<br>    yum list 列出当前系统中安装的所有包<br>    yum search package_name 在rpm仓库中搜寻软件包<br>    yum clean packages 清理rpm缓存删除下载的包<br>    yum clean headers 删除所有头文件<br>    yum clean all 删除所有缓存的包和头文件 </p>
<p>13.DEB 包 (Debian, Ubuntu 以及类似系统)<br>    dpkg -i package.deb 安装/更新一个 deb 包<br>    dpkg -r package_name 从系统删除一个 deb 包<br>    dpkg -l 显示系统中所有已经安装的 deb 包<br>    dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>    dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>    dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>    dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>    dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p>
<p>14.APT 软件工具 (Debian, Ubuntu 以及类似系统)<br>    apt-get install package_name 安装/更新一个 deb 包<br>    apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>    apt-get update 升级列表中的软件包<br>    apt-get upgrade 升级所有已安装的软件<br>    apt-get remove package_name 从系统删除一个deb包<br>    apt-get check 确认依赖的软件仓库正确<br>    apt-get clean 从下载的软件包中清理缓存<br>    apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p>
<p>15.查看文件内容<br>    cat file1 从第一个字节开始正向查看文件的内容<br>    tac file1 从最后一行开始反向查看一个文件的内容<br>    more file1 查看一个长文件的内容<br>    less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>    head -2 file1 查看一个文件的前两行<br>    tail -2 file1 查看一个文件的最后两行<br>    tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<p>16.文本处理<br>    cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>    cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>    cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>    grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>    grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>    grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>    grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>    sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>    sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行<br>    sed ‘/ <em>#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>    echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>    sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>    sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>    sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符<br>    sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>    sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>    sed -n ‘5p;5q’ example.txt 查看第5行<br>    sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>    cat -n file1 标示文件的行数<br>    cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>    echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>    echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>    paste file1 file2 合并两个文件或两栏的内容<br>    paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>    sort file1 file2 排序两个文件的内容<br>    sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>    sort file1 file2 | uniq -u 删除交集，留下其他的行<br>    sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>    comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>    comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>    comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<p>17.字符设置和文件格式转换<br>    dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>    unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>    recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>    recode -l | more 显示所有允许的转换格式 </p>
<p>18.文件系统分析<br>    badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>    fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>    fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>    e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>    e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>    fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>    fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>    fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>    dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<p>19.初始化一个文件系统<br>    mkfs /dev/hda1 在hda1分区创建一个文件系统<br>    mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>    mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>    mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>    fdformat -n /dev/fd0 格式化一个软盘<br>    mkswap /dev/hda3 创建一个swap文件系统 </p>
<p>20.SWAP文件系统<br>    mkswap /dev/hda3 创建一个swap文件系统<br>    swapon /dev/hda3 启用一个新的swap文件系统<br>    swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p>
<p>21.备份<br>    dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>    dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>    restore -if /tmp/home0.bak 还原一个交互式备份<br>    rsync -rogpav –delete /home /tmp 同步两边的目录<br>    rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>    rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>    rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>    dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>    dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>    tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>    ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>    ( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>    tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>    find /home/user1 -name ‘<em>.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>    find /var/log -name ‘</em>.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>    dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>    dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p>
<p>22.光盘<br>    cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>    mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>    mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>    mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>    cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>    gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>    mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>    cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>    cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>    cdrecord –scanbus 扫描总线以识别scsi通道<br>    dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p>
<p>23.网络 - （以太网和WIFI无线）<br>     ifconfig eth0 显示一个以太网卡的配置<br>    ifup eth0 启用一个 ‘eth0’ 网络设备<br>    ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>    ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>    ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>    dhclient eth0 以dhcp模式启用 ‘eth0’<br>    route -n show routing table<br>    route add -net 0/0 gw IP_Gateway configura default gateway<br>    route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’<br>    route del 0/0 gw IP_gateway remove static route<br>    echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing<br>    hostname show hostname of system<br>    host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(1)<br>    nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(2)<br>    ip link show show link status of all interfaces<br>    mii-tool eth0 show link status of ‘eth0’<br>    ethtool eth0 show statistics of network card ‘eth0’<br>    netstat -tup show all active network connections and their PID<br>    netstat -tupl show all network services listening on the system and their PID<br>    tcpdump tcp port 80 show all HTTP traffic<br>    iwlist scan show wireless networks<br>    iwconfig eth1 show configuration of a wireless network card<br>    hostname show hostname<br>    host <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>    nslookup <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup hostname to resolve name to ip address and viceversa<br>    whois <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> lookup on Whois database</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" data-id="ck7ev3v670000c0v33utfee58" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/05/linux%E9%AB%98%E7%BA%A7/" class="article-date">
  <time datetime="2020-03-05T02:28:55.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/05/linux%E9%AB%98%E7%BA%A7/">linux高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>文件管理<br> 查看文件管理的内容<br> [root@localhost ~]# df -Th<br>文件系统                类型      容量  已用  可用 已用% 挂载点<br>/dev/mapper/centos-root xfs        17G  5.3G   12G   31% /<br>devtmpfs                devtmpfs  898M     0  898M    0% /dev<br>tmpfs                   tmpfs     910M     0  910M    0% /dev/shm<br>tmpfs                   tmpfs     910M  9.6M  901M    2% /run<br>tmpfs                   tmpfs     910M     0  910M    0% /sys/fs/cgroup<br>/dev/sda1               xfs      1014M  146M  869M   15% /boot<br>tmpfs                   tmpfs     182M     0  182M    0% /run/user/0</li>
</ol>
<hr>
<ol start="2">
<li>文件=目录项+inode+数据块（block）<br>目录项： 正统的文件系统（ext2 ext3）一个文件有目录项 inode 和数据块组成<br>inode  文件索引节点，是文件基本信息存放地和数据块指针存放地<br>block 文件具体内容存放地</li>
</ol>
<hr>
<ol start="3">
<li>常用的命令<br> du : 查看文件大小<br> fdisk : 分区<br> parted : 分区<br> mkfs.xfs : 格式化<br> mkfs.ext4 : 格式化<br> df : 挂载<br> umont : 挂载<br> mount : 挂载   = &gt;   mount 挂载的目标 挂载文件<br> dd: 备份<br> cp : 备份<br> tar : 备份<br> 格式化的命令： man mkfs.ext4<br> df -Th: 查看文件管理的内容<br> touch: 创建文本文件<br> dumpe2fs /dev/sde1|more： 查看超级块的详细信息<br> mkfs.ext4 /dev/sde1  ： 查看超级块部分信息<br> ln -s 文件名 链接文件名 ：创建软链接<br> ln 文件名 链接文件名 ： 创建硬链接<br> rm -rf :删除文件<br> ll: 查看文件具体内容<br> ll -i : 查看文件的inode<br> 查看日志文件  ll /dev/<br> df  -Th : 行看文件分区<br> mv 原文件 原文档 ： mv [OPTION]… SOURCE… DIRECTORY<br> fdisk 查看磁盘信息<br> mkfs 磁盘格式化</li>
</ol>
<hr>
<p>4.Linux 支持多种文件系统<br>    ext2 ： Linux 基本文件系统<br>    ext3： ext2 增强版本，是Linux的默认文件系统<br>    ext4 : ext文件系统的第四个版本</p>
<hr>
<p>5.当磁盘上显示没有空间的时候 但是查询的时候却还有空间的原因：<br>    因为inode 消耗完了</p>
<hr>
<p>6.文件系统的重要参数：<br>    superblock (超级块)： 记录此 file system的整体信息，包括inode/block的总量 使用量<br>    剩余量 以及文件系统的格式</p>
<pre><code>inode： 记录文件的属性 一个文件占用一个incode 同时记录此文件的数据所在的block编号 258字节

block: 实际记录文件的内容 若文件太大时 会占用多个block</code></pre><hr>
<p>7.软链接与硬链接<br>    软链接: ln -s 文件名 软链接文件名<br>        把源文件删除后 链接文件不可以使用  使用不同的inode和block  但是block里面放的是目录项（文件名链接 找到 inode和block可以直接找到原文件<br>    硬链接： ln 文件名 硬链接文件名<br>        把源文件删除后 链接文件可以继续使用 创建的硬链接会指向原来的inode 和block</p>
<p>总结：  硬链接：不同的目录项，相同的inodeh和block<br>        软链接： 不同的目录项，不同的inode和block,但是软链接的block里存放的是链接的目录项<br>                可以找到原本的文件</p>
<hr>
<ol start="8">
<li>34323835 -rw-r–r–. 2 root root 20 3月   6 17:14 caiaihui.txt<br> inode号    权限     链接次数    </li>
</ol>
<hr>
<p>9.xfs和ext4那个更好<br>    xfs更加好点：#  支持大文件和大分区<br>                #  读写文件速度块<br>    ext4 特点：  # boot分区的文件本来就不大<br>                # 启动时加载文件更快</p>
<hr>
<p>10.RAID：磁盘阵列<br>    磁盘阵列是由很多块独立的磁盘，组合成一个巨大的磁盘组，利用个别磁盘提供数据所产生加成效果<br>    提升整个磁盘系统效能<br>    读写能力的提升 部分磁盘坏了不会影响使用  容错性强</p>
<p>硬件RAID  速度块 性能好 支持热插拔<br>软件RAID  使用mdadm 软件仿真磁盘阵列功能</p>
<hr>
<p>11.linux系统的分区方案：<br>    标准分区<br>    1.centos8 经典方案：<br>        /        剩下的空间全备给根分区<br>        /boot    1000M左右–》用来存放启动系统所需要的文件–》相当于windows里的c盘<br>        swap     物理内存的2倍   用来临时存放数据，当物理内存不足<br>        /home    单独的分区<br>    2.自定义方案：<br>        /     xfs   剩下的空间<br>        /boot  ext4   1G  不需要特别大的空间<br>        swap   swap   物理内存的2倍<br>        /mysql_data xfs  200G  –&gt;专门存放数据库的数据的分区<br>        /home   xfs  单独</p>
<hr>
<p>12.分区扩容的方案<br>    #  把分区里的数据移动到其他的分区<br>    #  在添加一块磁盘 移动数据到新的磁盘</p>
<hr>
<p>13.新加磁盘的完整步骤<br>    fdisk分区 -&gt; mkfs格式化 -&gt; mount挂载</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/05/linux%E9%AB%98%E7%BA%A7/" data-id="ck7ev3v7v0001c0v31ooh48u4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/linux%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-03-04T13:07:16.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/linux%E5%9F%BA%E7%A1%80/">linux基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基本命令：<br>    hostname : 查看主机名<br>    hostname 主机名： 临时修改主机名<br>    su - 用户名 ： 切换用户登陆系统<br>    useradd 用户名： 增加一个用户<br>    pwd  : 查看当前的在哪个文件夹<br>    cd : 进入文件夹<br>    ls: 查看文件夹的内容<br>        -l(long format):显示详细信息  -a(all)：显示所有的文件夹和文件包括隐藏文件<br>    mkdir: 新建文件夹<br>        mkdir .文件名  建立隐藏文件夹<br>    echo :查看某个文档或则变量<br>    man bash:查看bash命令的使用方法和手册  / 进行查找   n 查找下一个<br>    reboot： 重启系统<br>    file : 查看文件的类型</p>
<hr>
<p>1.查看虚拟机的编码：<br>    locale<br>    echo $LANG<br>2. echo：是查看后面的内容<br>    [root@localhost ~]# echo people<br>    people</p>
<hr>
<ol start="3">
<li>$ : 表示某个变量的值<br> [root@localhost ~]# shuaige=lijian<br> [root@localhost ~]# echo $shuaige<br> lijian</li>
</ol>
<hr>
<h2 id="4-pwd-查看当前在那个路径"><a href="#4-pwd-查看当前在那个路径" class="headerlink" title="4.pwd: 查看当前在那个路径"></a>4.pwd: 查看当前在那个路径</h2><p>5.快照：创建一个linux系统好的状态，一旦系统出了问题的时候，可以恢复到当时创建快照时好的系统状态<br>  挂起： 将虚拟机暂停在某个时间点</p>
<hr>
<p>6.Linux操作系统过程<br>    Linux内核  系统基本库  应用程序</p>
<hr>
<p>7.[root@localhost ~]#  ： 第一提示符PS1<br>    root : 用户   localhost ： 主机名  ~:所处的目录（主目录）<br>    /: 表示根目录   粗体代表文件夹  细体代表文件</p>
<hr>
<ol start="8">
<li>echo 与 $ 的使用   $接变量名就是引用变量的值<br> [root@li lijian]# shuaige=lijian<br> [root@li lijian]# echo $shuaige<br> lijian</li>
</ol>
<hr>
<ol start="9">
<li>修改PS1的值：<br> PS1 = ‘[\h@\u \w]$’  =&gt;  [lijian@root ~]#</li>
</ol>
<hr>
<p>10.永久性的修改主机名<br>    进入 /etc/hostname 目录  修改主机名<br>    然后reboot重新启动系统<br>    只有root用户才能改主机名</p>
<hr>
<p>11.Linux 命令的通用命令格式<br>    命令字符 [选项] [参数]<br>    选项： 段格式 -l             没有接参数的时候 就是默认当前文件夹为参数<br>           长格式 –long format     选项可以组合使用  -al</p>
<hr>
<p>12.安装使用Tab键补齐命令<br>    yum install bash-conpletion</p>
<hr>
<p>13.shell的作用：<br>    1. 识别我们输入的命令<br>    2. 帮助执行<br>    所有的可执行文件都放在 /bin 目录下</p>
<hr>
<ol start="14">
<li>基本的硬件：<br> CPU 内存 硬盘 网卡 显卡 声卡 输入输出设备</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/linux%E5%9F%BA%E7%A1%80/" data-id="ck7ev3v7x0002c0v3bbopbd3i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/27/Vue-js/" class="article-date">
  <time datetime="2020-02-27T03:16:36.000Z" itemprop="datePublished">2020-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/27/Vue-js/">Vue.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Vue的安装部署：<br>    * 直接用script进行引用(也可以直接引用一个文件 script)</p>
<pre><code>对于制作原型或学习，你可以这样使用最新版本：
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;

对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&gt;&lt;/script&gt;

如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件：
&lt;script type=&quot;module&quot;&gt;
      import Vue from &apos;https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js&apos;
&lt;/script&gt;</code></pre><p>2.第一个Vue应用：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src=&quot;./vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        {{ message }} {{name}}
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义一个变量 并且赋值
        var app = new Vue({
            // el:元素
            el:&quot;#app&quot;,
            // data:数据 将div中的变量赋值
            data:{
                message:&quot;hello Vue&quot;,
                name:&quot;lijian&quot;
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>3.数据与方法  数据的赋值 以及修改  还有watch的使用</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script src=&quot;./vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        {{a}}{{b}}
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        var data = {a:1,b:2}
        var vm = new Vue({
            el:&quot;#app&quot;,
            data:data
        });
    // 修改a的值
    data.a = &quot;text&quot;
    data.b = &quot;lijian&quot;
    // watch方法   a 变量的变化   放在变化之前  观察某一个变量的变化
    vm.$watch(&apos;a&apos;,function(newValue,oldValue){
        console.log(newValue,oldValue)
    })
    // $的使用  可以通过实例VM来修改
    vm.$data.a = &quot;lijian&quot;
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>4.生命周期</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    {{msg}}
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        msg : &quot;hi vue&quot;,
    },
    //在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。
    beforeCreate:function(){
        console.log(&apos;beforeCreate&apos;);
    },
    /* 在实例创建完成后被立即调用。
    在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。
    然而，挂载阶段还没开始，$el 属性目前不可见。 */
    created    :function(){
        console.log(&apos;created&apos;);
    },
    //在挂载开始之前被调用：相关的渲染函数首次被调用
    beforeMount : function(){
        console.log(&apos;beforeMount&apos;);
    },
    //el 被新创建的 vm.$el 替换, 挂在成功    
    mounted : function(){
        console.log(&apos;mounted&apos;);

    },
    //数据更新时调用
    beforeUpdate : function(){
        console.log(&apos;beforeUpdate&apos;);

    },
    //组件 DOM 已经更新, 组件更新完毕 
    updated : function(){
        console.log(&apos;updated&apos;);

    }
});
setTimeout(function(){
    vm.msg = &quot;change ......&quot;;
}, 3000);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>5.模板语法-插值：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    {{msg}}
    &lt;p&gt;Using mustaches: {{ rawHtml }}&lt;/p&gt;
    &lt;p v-html=&quot;rawHtml&quot;&gt;&lt;/p&gt;
    &lt;div v-bind:class=&quot;color&quot;&gt;test...&lt;/div&gt;
    &lt;p&gt;{{ number + 1 }}&lt;/p&gt;
    &lt;p&gt;{{ 1 == 1 ? 'YES' : 'NO' }}&lt;/p&gt;
    &lt;p&gt;{{ message.split('').reverse().join('') }}&lt;/p&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        msg : &quot;hi vue&quot;,
        rawHtml : &apos;&lt;span style=&quot;color:red&quot;&gt;this is should be red&lt;/span&gt;&apos;,
        color:&apos;blue&apos;,
        number : 10,
        ok : 1,
        message : &quot;vue&quot;
    }
});
vm.msg = &quot;hi....&quot;;
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
.red{color:red;}
.blue{color:blue; font-size:100px;}
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>6.模板语法-指令</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;!-- 表示为True的时候可以显示到页面上 --&gt;
    &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
    &lt;!-- 点击后跳转页面 --&gt;
    &lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;
    &lt;!-- 点击后会出现methods的函数 --&gt;
    &lt;div @click=&quot;click1&quot;&gt;
        &lt;div @click.stop=&quot;click2&quot;&gt;
            click me
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        seen : false,
        url : &quot;https://cn.vuejs.org/v2/guide/syntax.html#%E6%8C%87%E4%BB%A4&quot;
    },
    methods:{
        click1 : function () {
            console.log(&apos;click1......&apos;);
        },
        click2 : function () {
            console.log(&apos;click2......&apos;);
        }
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>7.class与style 绑定</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;div 
    class=&quot;test&quot; 
    &lt;!-- 三元运算 --&gt;
    v-bind:class=&quot;[ isActive ? &apos;active&apos; : &apos;&apos;, isGreen ? &apos;green&apos; : &apos;&apos;]&quot; 
    style=&quot;width:200px; height:200px; text-align:center; line-height:200px;&quot;&gt;
        hi vue
    &lt;/div&gt;
    &lt;div 
    :style=&quot;{color:color, fontSize:size, background: isRed ? &apos;#FF0000&apos; : &apos;&apos;}&quot;&gt;
        hi vue
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        isActive : true,
        isGreen : true,
        color : &quot;#FFFFFF&quot;,
        size : &apos;50px&apos;,
        isRed : true
    }
});
&lt;/script&gt;
&lt;style&gt;
.test{font-size:30px;}
.green{color:#00FF00;}
.active{background:#FF0000;}
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>8.条件渲染-V-if V-show</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;!-- types时什么值就会显示什么 --&gt;
    &lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;
      A
    &lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;
      B
    &lt;/div&gt;
    &lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt;
      C
    &lt;/div&gt;
    &lt;div v-else&gt;
      Not A/B/C
    &lt;/div&gt;
    &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        type : &quot;B&quot;,
        ok : true
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>9.列表渲染 V-for:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;!-- v-for  与for循环语句同样的作用 --&gt;
    &lt;ul&gt;
        &lt;!-- key=&quot;固定值&quot;  可以可以跟踪每个节点的身份 可维护性 --&gt;
        &lt;li v-for=&quot;item,index in items&quot; :key=&quot;index&quot;&gt;
        {{index}}{{ item.message }}
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;value, key in object&quot;&gt;
            {{key}} : {{ value }}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        items : [
            { message: &apos;Foo&apos; },
            { message: &apos;Bar&apos; }
        ],
        object: {
            title: &apos;How to do lists in Vue&apos;,
            author: &apos;Jane Doe&apos;,
            publishedAt: &apos;2016-04-10&apos;
        }
    }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>10.事件绑定 V-on：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;div id=&quot;example-1&quot;&gt;
        &lt;!-- 可以对click进行监听 --&gt;
        &lt;button v-on:click=&quot;counter += 1&quot;&gt; 数值 :  {{ counter }} &lt;/button&gt;&lt;br /&gt;
        &lt;!-- 可以直接接入一个函数    dblclick 事件的绑定工作--&gt;
        &lt;button v-on:dblclick=&quot;greet(&apos;abc&apos;, $event)&quot;&gt;Greet&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        counter: 0,
        name : &quot;vue&quot;
    },
    // 将函数写在这里
    methods:{
        greet : function (str, e) {
            alert(str);
            console.log(e);
        }
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>11.表单提交和绑定</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;div id=&quot;example-1&quot;&gt;
        &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
        &lt;p&gt;Message is: {{ message }}&lt;/p&gt;
        &lt;textarea v-model=&quot;message2&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;
        &lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message2 }}&lt;/p&gt;
        &lt;br /&gt;

        &lt;div style=&quot;margin-top:20px;&quot;&gt;
            &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
            &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
            &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
            &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
            &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
            &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
            &lt;br&gt;
            &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;
        &lt;/div&gt;

        &lt;div style=&quot;margin-top:20px;&quot;&gt;
            &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
            &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
            &lt;br&gt;
            &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
            &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
            &lt;br&gt;
            &lt;span&gt;Picked: {{ picked }}&lt;/span&gt;
        &lt;/div&gt;
        &lt;button type=&quot;button&quot; @click=&quot;submit&quot;&gt;提交&lt;/button&gt;
    &lt;/div&gt;

&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {
        message : &quot;test&quot;,
        message2 :&quot;hi&quot;,
        checkedNames : [&apos;Jack&apos;, &apos;John&apos;],
        picked : &quot;Two&quot;
    },
    methods: {
        submit : function () {
            console.log(this.message);

        }
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>12.基础组件-Vue-component</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;button-counter title=&quot;title1 : &quot; @clicknow=&quot;clicknow&quot;&gt;
        &lt;h2&gt;hi...h2&lt;/h2&gt;
    &lt;/button-counter&gt;
    &lt;button-counter title=&quot;title2 : &quot;&gt;&lt;/button-counter&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
Vue.component(&apos;button-counter&apos;, {
    props: [&apos;title&apos;],
    data: function () {
        return {
          count: 0
        }
    },
    template: &apos;&lt;div&gt;&lt;h1&gt;hi...&lt;/h1&gt;&lt;button v-on:click=&quot;clickfun&quot;&gt;{{title}} You clicked me {{ count }} times.&lt;/button&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&apos;,
    methods:{
        clickfun : function () {
            this.count ++;
            this.$emit(&apos;clicknow&apos;, this.count);
        }
    }
})
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {

    },
    methods:{
        clicknow : function (e) {
            console.log(e);
        }
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>13.组件的注册：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;&lt;/title&gt;
&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;button-counter&gt;&lt;/button-counter&gt;
    &lt;test&gt;&lt;/test&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
Vue.component(&apos;button-counter&apos;, {
    props: [&apos;title&apos;],
    data: function () {
        return {}
    },
    template: &apos;&lt;div&gt;&lt;h1&gt;hi...&lt;/h1&gt;&lt;/div&gt;&apos;,
    methods:{

    }
})
var vm = new Vue({
    el : &quot;#app&quot;,
    data : {

    },
    methods:{
        clicknow : function (e) {
            console.log(e);
        }
    },
    components:{
        test : {
            template:&quot;&lt;h2&gt;h2...&lt;/h2&gt;&quot;
        }
    }
});
&lt;/script&gt;
&lt;style type=&quot;text/css&quot;&gt;
&lt;/style&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>14.单文件组件：</p>
<pre><code>### 安装 `npm`
`npm` 全称为 `Node Package Manager`，是一个基于`Node.js`的包管理器，也是整个`Node.js`社区最流行、支持的第三方模块最多的包管理器。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
### 由于网络原因 安装 `cnpm`
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
### 安装 `vue-cli`
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
### 安装 `webpack`
`webpack` 是  `JavaScript` 打包器(module bundler)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g webpack</span><br></pre></td></tr></table></figure>
命令行输入  vue ui  进入创建项目
&lt;template&gt;            &lt;stript&gt;                &lt;style&gt;
&lt;!-- 模板 --&gt;           脚本                     样式
&lt;/template&gt;              &lt;/stript&gt;                &lt;/style&gt;</code></pre><hr>
<pre><code>15.es5  es6  是JavaScript的语法标准</code></pre><hr>
<pre><code>16.axios.js
Axios 是一个基于 promise 的 HTTP 库,可以用在浏览器和 Node.js 中
详细文档：    http://axios-js.com/zh-cn/docs/</code></pre><hr>
<p>17.基于axios.js来发送Ajax请求</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;!-- vue的远程资源 --&gt;
        &lt;script src=&quot;./vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;
        &lt;!-- axios的远程资源 --&gt;
        &lt;script src=&quot;https://cdn.bootcss.com/axios/0.19.2/axios.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 加载本地文件 --&gt;
        &lt;div id=&quot;box&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;加载文件&quot; @click=&quot;get_file()&quot; /&gt;&lt;br/&gt;
            &lt;input type=&quot;button&quot; value=&quot;get_url&quot; @click=&quot;get_url()&quot;/&gt;&lt;br/&gt;
            &lt;input type=&quot;button&quot; value=&quot;post_url&quot; @click=&quot;post_url()&quot;/&gt;&lt;br/&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 定义局部变量
            var data = {};
            // 实例化vuw
            var box = new Vue({
                el:&quot;#box&quot;,
                data:data,
                // 实现类函数
                methods:{
                    get_file:function(){
                        console.log(&quot;ajax-加载文件&quot;);
                        axios.get(&quot;./note.md&quot;)
                            .then(response =&gt;{
                                console.log(response.data)
                            })
                            .catch(function(error){
                                console.log(error);
                            })
                    },
                    get_url: function(){
                        console.log(&quot;get请求&quot;);
                        // axios.get(&quot;https://api.github.com/search/repositories?q=vue&amp;sort=stars&quot;)
                        //  axios.get(url [,config] ) =&gt; config -&gt; dict objcet =&gt; params传递的参数
                        // axios.get(&quot;https://api.github.com/search/repositories&quot;, {params: {&quot;q&quot;:&quot;vue&quot;, &quot;sort&quot;:&quot;stars&quot;}})
                        axios.get(&quot;http://localhost:5000/check_form?username=abcdefg&quot;)
                        // axios.get(&quot;http://localhost:5000/check_form&quot;, {params:{&quot;username&quot;:&quot;abcdefg&quot;}})
                        .then(function(response){
                            console.log(response.status);
                            console.log(response.data);
                        })
                        .catch(function(response){
                            console.log(response);
                        })
                    },
                    post_url: function(){
                        console.log(&quot;post请求&quot;);
                        axios.post(&quot;http://localhost:5000/check_form&quot;, {&quot;username&quot;:&quot;abcdefg&quot;})
                        .then(function(response){
                            console.log(response.status);
                            console.log(response.data);
                        })
                        .catch(function(response){
                            console.log(response);
                        })
                    }

                }
            })
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>18.cnpm的基本命令<br>    # 当前项目安装（安装到当前目录的node_modules目录）可以将 npm  -&gt;  cnpm<br>        npm install express<br>    #全局安装<br>        npm install express -g<br>    #查看安装信息<br>        npm list<br>    #查看某个模板的版本号<br>        npm view grunt<br>    #卸载模板<br>        npm uninstall express<br>    #更新模板<br>        npm update express<br>    #搜索模板<br>        npm search express</p>
<hr>
<p>19.vue-cli3创建项目<br>    方法- ：通过命令行的形式进行创建<br>        * 创建项目：<br>            vue create 项目名<br>        * cd到项目目录<br>        * 启动项目：<br>            npm run serve<br>    方法二：使用图形化方式就行创建项目：<br>        在指定目录下 vue ui   即可运行到创建的界面</p>
<hr>
<p>20.vue-cli3+ 项目结构<br>    node_madules =&gt; 当前项目安装的包 (import  npm install)<br>    public =&gt; 发布文件<br>    src=&gt; 所有的源文件<br>        assets =&gt; 一些静态文件<br>        components =&gt; Vue组件目录（模块化 复用）s<br>    App.vue =&gt; 根组件<br>    src/main.js =&gt;入口js文件<br>    public/index.html=&gt;如果html 文件</p>
<hr>
<p>21.vue-cli3+ 项目运行流程<br>    1.npm run serve<br>    2.vue模块进行配置<br>        node_modules/@vue/cli-service/lib/config/base.js<br>    3.根html =&gt; 跟组件 =&gt; 其他组件挂载到根组件 App.vue  HelloWorld.vue<br>      有默认的vue.config.js配置 =&gt; template:  public/index/index.html</p>
<hr>
<p>22.vue-cli2与vue-cli3+的区别<br>    vue-cli4的安装<br>        # 安装node.js   =&gt; npm node<br>        # 安装Vue - vue-cli4   npm install @vue/cli -g 全局安装<br>        # 创建vue-cli项目     vue create projectname<br>        # 让vue-cli4 兼容 vue-cli2 的功能    npm install @vue/cli-init<br>    vue-cli2的安装<br>        # 安装vue-cil2   npm install vue-cli<br>     ———————————————————————<br>     创建vue项目<br>     vue-cli2    vue init projectname<br>     vue-cli4    vue create projectname<br>     ———————————————————————<br>     运行vue项目<br>     vue-cli2    vue run dev<br>     vue-cli4    npm run serve<br>     ———————————————————————<br>     # 目录文件不一样   vue-cli4中的文件结构更加简洁</p>
<hr>
<p>23.vue-cli4 的第一组件<br>    # 创建的组件 要放到components目录下<br>        创建的过程中需要注意：<br>            # 在定义组件的时候，只能包含一个root element  即一个div<br>            # 组件的命名方式：大驼峰<br>            # data熟悉数据  在组件中必须是一个函数<br>                    data:function(){<br>                        return{count:0}<br>                    }<br>            # 添加一个事件<br>                <!-- 进行了counts值的变化  事件 --><br>                <!-- <button @click="count++">我的按钮-</button> –&gt;<br>            # 在子组件中进行添加属性 然后在父组件中给属性添加值<br>    实例如下：</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;这是我的自定义&lt;/h1&gt;
        &lt;button&gt;我的按钮&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    // 导出组件
    export default{
        name:&quot;FirstButton&quot;
    }
&lt;/script&gt;
&lt;style&gt;
&lt;/style&gt;

# 创建的组件导入主组件中 App.vue文件
实例如下：
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
    &lt;!-- &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; --&gt;
    &lt;!-- 使用自己新建的组件 --&gt;
    &lt;FirstButton&gt;&lt;/FirstButton&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
// import HelloWorld from &apos;./components/HelloWorld.vue&apos;
// 导入自己新建的组件
import FirstButton from &quot;./components/first.vue&quot;
export default {
  name: &apos;App&apos;
  components: {
      // 注册组件
    FirstButton
  }
}
&lt;/script&gt;
&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;</code></pre><hr>
<p>24.组件的编写：</p>
<pre><code># template  定义html元素   只包含一个根元素
    &lt;template&gt;
      &lt;div id=&quot;app&quot;&gt;
        &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
        &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
        &lt;!-- 使用自己新建的组件 --&gt;
        &lt;!-- 给属性赋值 --&gt;
        &lt;FirstButton title0=&quot;这是按钮的title0&quot;&gt;&lt;/FirstButton&gt;
        &lt;FirstButton titel1=&quot;这是按钮的title1&quot;&gt;&lt;/FirstButton&gt;
      &lt;/div&gt;
    &lt;/template&gt;

# script    创建一个Vue的组件     导入和使用子组件
    &lt;script&gt;
    import HelloWorld from &apos;./components/HelloWorld.vue&apos;
    // 导入自己新建的组件
    import FirstButton from &quot;./components/first.vue&quot;
    export default {
      name: &apos;App&apos;,
      components: {
        HelloWorld,
        FirstButton
      }
    }
    &lt;/script&gt; 

# style     样式
    &lt;style&gt;
    #app {
      font-family: Avenir, Helvetica, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-align: center;
      color: #2c3e50;
      margin-top: 60px;
    }
    &lt;/style&gt;</code></pre><hr>
<p>25.Vue路由管理<br>    # 首先安装bootstrap 和 jquery<br>    npm install bootstrap@3     npm install jquery@3<br>    #  安装 vue-router@3<br>    npm install router@3<br>        导入: import router from “./router”   将router加入src文件中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/27/Vue-js/" data-id="ck7hrbk7t0000tcv3663u0wdb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" rel="tag">前端框架</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python笔录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/python%E7%AC%94%E5%BD%95/" class="article-date">
  <time datetime="2020-02-15T08:54:55.732Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/python%E7%AC%94%E5%BD%95/">python笔录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: python笔录<br>date: 2020-02-15 16:54:55<br>tags:</p>
<hr>
<p>1.做列表类的题目心得：(踩过好多坑)<br>    len() 函数的用法： 例子  num1 = [1,2,3]<br>                            print(len(num1))  =&gt;  3<br>    对于range()函数循环取值后：(包前不包后)<br>                            for i in range(len(num1)):<br>                                print(i)  =&gt;    0,1,2<br>    可迭代对象是指 可以使用for语句进行循环取值的对象：<br>            list tuple dict set  str    可迭代对象之间是可以相互转化的  list(str)</p>
<hr>
<p>2.列表推导式：推导式 就是把  list  dict set  之间进行转换  没有元组推导式<br>基本格式：variable = [‘out_exp_res’ for out_exp in input list if ‘out_exp == 2]<br>        out_exp_res: 列表生成元素表达式  或则反回值<br>        for put_exp in input_list  迭代input_list 将out_exp 传入 out_exp_res<br>        if out_exp == 2            根据条件过滤哪些值<br>    例子： 将字符串变成列表  条件 只将大写输出：<br>            mystr = ‘abcABC’<br>            mylist = [item for item in mystr if item.isupper()]<br>            print(mylist)                                       =&gt;[‘A’, ‘B’, ‘C’]<br>3.字典推导式：（集合推导式  就只需要需要key）<br>基本格式：variable = {out_key:out_value for out_key,out_value in input if out_exp==2}</p>
<hr>
<p>4.可迭代对象的判断：<br>    from collections.abc import Iterable<br>         isinstance(a,Iterable) =&gt; Ture<br>    或者取dir 查看这个对象是否具有 <strong>iter</strong>这个对象</p>
<hr>
<ol start="5">
<li>迭代器：<br> 迭代器是有状态的，可以被next()调用，函数调用并不断返回下一个值的对象=&gt;迭代器<br> x = [1,2,3]<br> y = iter(x)   =&gt;   y = x.<strong>iter</strong>() 可以在可迭代对象中相互转换<br> print(next(y)) =&gt; 1      next表示一次取出迭代器里面的元素一次取一个元素<pre><code>当取完了就不能再取了  就会报错StopIteration</code></pre>for 后面要接可迭代对象的原因： 可迭代对象 =&gt; 生成一个迭代器 =&gt; 里面有Next方法 依次取值<br>迭代器的特点：  迭代器是有next方法的<pre><code>迭代器的数据不是立即生成的  当用户显示或隐式方法调用__next__()才会才会成数据 迭代器中只存放了下一个数据的计算方法</code></pre>迭代器的使用情景： 1. 数据量很大  2. 按顺序取值</li>
</ol>
<hr>
<ol start="6">
<li><p>迭代器生成一个无限序列：</p>
<pre><code>from itertools import count
#生成一个无限大的序列，从start开始
counter = count(start = 10)
print(counter, type(counter))
print(next(counter))  =&gt; 无限取值</code></pre><p>迭代器从一个有限序列中生成一个无限序列：</p>
<pre><code>   from itertools import cycle
import  time
week = cycle([1,2,3,4,5,6,7,8,9])
for i in week:
    print(i)
    time.sleep(1)</code></pre></li>
</ol>
<hr>
<p>7.可迭代对象与迭代器的区别：</p>
<h1 id="取值：-index-key-随机取值-只能通过next方法进行向下取值"><a href="#取值：-index-key-随机取值-只能通过next方法进行向下取值" class="headerlink" title="取值：  index/key 随机取值                    只能通过next方法进行向下取值"></a>取值：  index/key 随机取值                    只能通过next方法进行向下取值</h1><h1 id="存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）"><a href="#存储：-一次性占用内存-适合数据量小的时候使用-只存储下一次取值的计算方法（惰性取值）" class="headerlink" title="存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）"></a>存储：  一次性占用内存(适合数据量小的时候使用)   只存储下一次取值的计算方法（惰性取值）</h1><h1 id="迭代器的好处：-在瞬时间-占用的内存少-计算量小"><a href="#迭代器的好处：-在瞬时间-占用的内存少-计算量小" class="headerlink" title="迭代器的好处：  在瞬时间 占用的内存少  计算量小"></a>迭代器的好处：  在瞬时间 占用的内存少  计算量小</h1><hr>
<p>8.生成器：<br>    生成器是一种特殊的迭代器，它不需要手动编写<strong>iter</strong>() 和 <strong>next</strong>()方法，只需要一个<br>    yiled 关键字     （生成器一定是迭代器，反之不成立）<br>  生成器表达式：<br>       1.使用()生成generator(生成器) 将两表推到式的[]改为()即可得到生成器<br>           a = (x for x in range(10 ** 9))<br>       2.yield： 包含yield表达式的函数是特殊的函数，叫做生成器函数<br>                 被调用时将返回一个迭代器，调用时用next 或者 send(msg)<br>                 ~ 一个生成器中可以有多个yield<br>                 ~ 一旦遇到yield 就会保存当前状态 然后返回yield后面的值<br>                 例子： def max1(i)<br>                             yield i       yield执行后就会保存状态，下次从yield开始执行<br>                           print(manx(1))  =&gt;  生成一个生成器<br>                           print(next(max1))  =&gt;  依次取值<br>       3.send数据：<br>           用户可以使用send 来跟生成器进行交互  send的数据会输入到生成器yield的位置<br>       4.yield from:<br>           当我们想从一个生成器取到内部的数据的时候<br>  ~生成器的好处：<br>          可以用更少的中间变量写流式代码<br>          相比其他容器对象他能节省内存<br>          可以减少代码的使用</p>
<hr>
<p>9.关于查看程序执行时间的方法  时间戳<br>    import time<br>    #时间戳   从1970.1.1 0点0时0秒<br>    start = time.time()<br>    a = [x for x in range(10*9)]<br>    print(time.time()-start)</p>
<hr>
<ol start="10">
<li>常见的编程范式：<ul>
<li>面向过程编程：根据操作数据的语句块来实现功能</li>
<li>面向对象编程：把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法</li>
<li>函数式编程： 如果一个函数可以接受函数作为参数，并且返回一个结果，这个函数为函数式编程</li>
</ul>
</li>
</ol>
<hr>
<ol start="11">
<li>高阶函数： 一个函数中把另一个函数作为参数传入，这个参数为函数的函数为高阶函数</li>
</ol>
<ul>
<li><p>map函数：  map( 函数名[方法] , 可迭代对象 )   一一映射进行处理 返回值为迭代器<br>  例子：   def f(x):                        ret = map(lambda x:x*x,range(10))</p>
<pre><code>    return x*x
ret = map(f,range(10))
print(list(ret))</code></pre></li>
<li><p>filter函数(过滤)： filter( 函数名[方法] , 可迭代对象 )  返回值为迭代器    </p>
<pre><code>filter把传入的函数依次作用于每个元素，然后根据返回值式Ture还是False决定保留还是丢弃 保留True</code></pre><p>  例子：    num1 = [1,2,3,4]</p>
<pre><code># 0=&gt;Fales   1=&gt;Ture
ret = filter(lambda x:x%2,num1)
print(list(ret))</code></pre></li>
<li><p>sorted函数(排序)：  sort(可迭代对象，函数名[方法])<br>  例子： sorted([2,3,4,-1],key = abs)    返回值为list</p>
</li>
<li><p>reduce函数():把结果继续和序列的下一个元素做累加计算</p>
<pre><code>reduce(函数，可迭代对象)</code></pre><p>  例子：from functools import reduce</p>
<pre><code>reduce(lambda x,y:x*10+y,[1,3,7,5,9])    =&gt;13759</code></pre></li>
</ul>
<hr>
<ol start="12">
<li><p>类(class):类里面的变量称为类属性(每个实例都可以使用)   类中函数里面的变量称为实例属性 </p>
<pre><code>      每个类中都有一个__init__ 方法(自动调用) 作用是来初始化类的 调用的时候直接：
      solution = 类名(类对象)
例子： class Soultion(object):
        def __init__(self,age,name,sex):
            self.age = age
            self.name = name
            self.sex = sex 
    solution = Soultion(age=10,name=&apos;lijian&apos;,sex=&apos;男&apos;)
    print(solution.name)
    print(solution.age)
    print(solution.sex)</code></pre><p><strong>new</strong> 方法：  开始创建实例  def <strong>new</strong> (cls,* args, ** kwargs):</p>
<pre><code>                return object.__new__(cls)
这样就会创建一个实例 后面的__init__方法就会初始化创建出来的实例</code></pre><p>注意： object 中包含了<strong>new</strong> <strong>init</strong> 这两个方法 一般不需要自行写入</p>
<pre><code>类和方法是可以动态添加属性和方法的    
bus317.color = green  这样就给实例添加了一个属性
Bus317.color = blue   这样就给类添加了一个属性
一个实例有自己的属性的时候 先使用自己的 再使用公共的</code></pre></li>
</ol>
<hr>
<p>13.用类创建迭代器：<br>    利用菲不拉契数列例子：<br>        class Fib(object):<br>    def <strong>init</strong>(self):<br>        self.prev = 0<br>        self.current = 1</p>
<pre><code>def __next__(self):
    self.prev,self.current = self.current,self.prev + self.current
    return self.prev
# 创建迭代器  只需要放回他自己就好
def __iter__(self):
    return self

fib = Fib()
print(fib.__next__())</code></pre><hr>
<h2 id="14-类-self-表示调用该方法的实例本身"><a href="#14-类-self-表示调用该方法的实例本身" class="headerlink" title="14.类-self: 表示调用该方法的实例本身"></a>14.类-self: 表示调用该方法的实例本身</h2><p>15.类的继承：<br>    在一个继承类中，如果父类有一个方法而子类也有一个相同的方法，在执行的时候子类会先用自己的方法，符合就近原则。但是子类没有该方法 就会自动的去查找父类和object中是否有该方法。如果<br>    都没有的话就会出现AttributeError这样的错误</p>
<pre><code>super().sports()      在子类于父类有同样的方法的时候，要求子类在调用该方法的时候先去父类调用该方法</code></pre><hr>
<p>16.装饰器(类方法)  @classmethod  在一个类里面定义只作用于这个类的方法<br>    @classmethod<br>    def add(cls):      cls是出现在那个类里面就表示哪个类<br>        cls.count += 1    </p>
<hr>
<p>17 定义一个异常类;  异常类都继承于 Exception<br>     #异常类的定义<br>    class ListLenghtError(Exception):<br>        pass</p>
<pre><code>li = list(range(8))
if len(li) &gt;= 10:
    raise ListLenghtError
else:
    print(&quot;列表正确&quot;)</code></pre><hr>
<p>18.类的继承中的多态<br>    多态：多种状态，在面向对象语言中，接口的多种不同的实现方式<br>    python是一种多态语言，裳称鸭子类型</p>
<pre><code>def talk_with(self,obj):      obj:是子类中的某个类
    obj.talk()               
有了这个多态 就可以用现在处在的这个类直接调用别的类中的talk方法    
父类名.某个子类中的方法()   就可实现调用</code></pre><hr>
<p>19.经典类与新式类：<br>    python2： 经典类是按照深度优先来继承的   新式类是按照C3算法来继承的<br>    python3： 同意按照C3算法来继承<br>            MRO: 方法解析顺序  解决当定义了多个同名的方法/属性的时候让用户找到正确的对象所实现的一种算法<br>            C3算法： * 子类会先于父类被检查<br>                     * 多个父类会根据他们在列表中的顺序被检查<br>                     * 如果对下一个类存在两个合法的选择，选择第一个父类<br>                     mro() :  可以直接退出C3 算法 </p>
<hr>
<p>20  * 实例方法： def <strong>init</strong>():    这个方法是给实例用的 一定要传递一个实例或者调用<br>    * 静态方法： @staticmethod<br>    * 类方法： @classmethod  cls表示类本身   在哪个类里面就表示哪个类  </p>
<pre><code>在方法中，没有使用实例信息，也没有使用类信息     @staticmethod 静态方法
在方法中，没有使用实例信息，使用到了类信息       @classmathod  类方法
在方法中，用到实例信息，没有使用到类信息         普通实例方法
在方法中，用到实例信息和类信息                  实例方法+类方法

例子：

    class Tst(object):
    #类属性(静态属性)
    class_attribute = &apos;A&apos;

    def __init__(self):
        #实例属性
        self.instance_attrubute = &apos;B&apos;
    #实例方法
    def instance_method(self):
        print(&apos;这是一个实例方法&apos;)
        print(self.instance_attrubute)
        print(self.class_attribute)

    # 类方法    =》 装饰器
    #把classmethod下面的方法变为类方法
    @classmethod
    def class_method(cls):
        print(&apos;这是个类方法&apos;)
        #类方法只能调用类属性
        print(cls.class_attribute)

    #静态方法
    @staticmethod
    def static_method():
        print(&apos;这是个静态方法&apos;)
        print(Tst.class_attribute)

    #用实例来调用实例方法
    tst = Tst()
    tst.instance_method()

    #用类来调用类方法
    Tst.class_method()
    #用实例来调用方法
    tst.class_method()

    #用实例来调用静态方法
    tst.static_method()
    #用类来调用静态方法
    Tst.static_method()</code></pre><hr>
<p>21.属性包装 ：@ property   将方法转化为属性来使用<br>        当生成一个包装后 python会自动生成 @类名.setter  @类名.delete 等包装<br>    例子：</p>
<pre><code>    class Person(object):
def __init__(self,name,age):
    self.name = name
    self._age = age

@property
def age(self):
    print(&apos;property_age&apos;)
    return self._age

# 这是用做修改的功能
@age.setter
def age(self,value):
      if 0&lt;value&lt;100:
        self._age = value
    else:
        raise ValueError(&apos;超出范围&apos;)

# 这是删除的功能
@age.deleter
def age(self):
    del self._age

p1 =  Person(&apos;cali&apos;,19)
#当作属性可以直接访问
print(p1.age)
p1.age = 10
print(p1.age)</code></pre><hr>
<p>22.类中的下划线：   _age 表示是私有的     <strong>age 表示是强制不能使用的<br>                                       强行访问的方式  obj._classname</strong>foo<br>                                       obj 实例名   classname 类名</p>
<hr>
<ol start="23">
<li>魔术方法：<ul>
<li><strong>new</strong> 创建实例:<br>  def <strong>new</strong>(cls,* args, ** kwargs):<pre><code>return upper().__new__(cls)</code></pre></li>
<li><strong>init</strong> 初始化实例：<br>  def <strong>init</strong>(self):<pre><code>return 初始化实例</code></pre></li>
<li><strong>del</strong> 删除方法：<br>  def <strong>del</strong>(self):<pre><code>return 删除方法   自动调用    </code></pre></li>
<li><strong>getitem</strong> 获取数据</li>
<li><strong>setitem</strong> 设置数据</li>
<li><strong>iter</strong>    可迭代</li>
<li><strong>eq</strong>(self,other)     符号 ==<pre><code>tst1.__eq__(txt2)    self.tst1 == other.tst2</code></pre></li>
<li><strong>ne</strong> (self,other)    !=</li>
<li><strong>it</strong> (self,other)    &lt;</li>
<li><strong>gt</strong> (self,other)    &lt;=</li>
<li><strong>add</strong>(self,other)    +</li>
<li><strong>mul</strong>(self,other)    *</li>
<li><strong>len</strong> (self)  长度</li>
<li><strong>str</strong> (self)  友好的输出实例信息=&gt;非正式</li>
<li><strong>repr</strong>(self)  友好的输出实例信息=&gt;正式  结果放在列表中</li>
<li><strong>dict</strong>(self)  类的属性</li>
<li><strong>doc</strong> (self)  类的文档</li>
<li><strong>name</strong>(self)  类名</li>
<li><strong>module</strong>(self)  类定义所在的模块</li>
<li><strong>bases</strong> (self)  类所有父类构成元素</li>
</ul>
</li>
</ol>
<hr>
<p>24.自省: 检查某些事务以确定他是什么 他是干什么的能做什么<br>         类似于：dir()    typle()<br>    自省的方法：<br>        * getattr(obj,’name’):获取成员<br>            getattr(实例名，属性值)<br>        * hasattr(obj,’name’):检查是否含有成员<br>            hasattr(实例名，属性值)<br>        * setattr(obj,’age’,value): 设置成员<br>            getattr(实例名，属性值,修改值)<br>        * delattr(obj,’name’):删除成员<br>            delattr(实例名，属性值)</p>
<hr>
<p>25.python元类：  元类就是用来创建类的类   类是由type创建的  type是默认的一个元类<br>    type创建类    type(类名，(object),{方法:函数})<br>        第一个参数： 是写出类名<br>        第二个参数： 继承自谁<br>        第三个参数： ‘方法名’:函数(方法)</p>
<hr>
<p>26.抽象基类：  from abc import ABCmeta,abstractmethod        metaclass = ABCMeta<br>            @abstractmethod  下面的函数可以在子类中出现了该方法就可以直接调用</p>
<hr>
<p>27.闭包：在函数中可以(嵌套)<br>    定义另外一个函数，如果内部函数引用了外部的函数变量，则可能产生闭包<br>    闭包可以用来在一个函数于一组“私有”变量之间创建关联关系<br>    在给定函数被多次调用的过程中，这些私有变量能够保持其持久性<br>闭包形成的条件：<br>    * 有一个内嵌的函数<br>    * 内部函数必须要引用外部函数的变量<br>    * 外部函数返回内部函数(函数名)<br>闭包的特点：闭合范围内的变量是有状态的 随着调用 会不断的更新     </p>
<p>例子：<br>    def func01():<br>    a = 1<br>    def func02():<br>        # 表示使用上一层函数的变量<br>        nonlocal a<br>        #从右往左计算 那么a就没有值<br>        a = a+1<br>        print(a)<br>    return func02()</p>
<hr>
<p>28.编写装饰器;（作用：给函数添加功能）<br>    编写装饰器的固定模板：</p>
<pre><code>import functools
def 装饰器名(func):
    @functools.wraps(实例函数)
    def _dec(*args,**kwargs)
        你想添加的功能
        result = func(*args,**kwargs)
        你想添加的功能
        return result
return _dec

带参数的装饰器的模板：
def permission_required(user):
    def dec(func):
        def _dec(*args,**kwargs):
            # 你想添加的功能
            result = func(*args,**kwargs)
            # 你想添加的功能
            return result
        return _dec
    return dec


例子：import functools
    def login_required(func):
        @functools.wraps(func)   =》 是可以提示哪个函数被调用
        def _dec(a,b,*args,** kwargs):
            if name == &apos;root&apos;:
                print(f&quot;{func.__name__}被调用&quot;)
                return func(a,b,*args,** kwargs) =&gt; 
                                可变长参数   不用管函数传入的参数什么样子
            else:
                print(&apos;有问题&apos;)
                return False
        return _dec
    @login_required
    def add(a,b,*args,** kwargs):
        print(a+b)
        return a+b
    add(1,2,&apos;root&apos;)</code></pre><hr>
<p>29.用类来实现装饰器<br>    <strong>init</strong> 初始化类         <strong>call</strong>  传入参数的时候使用</p>
<p>例子：</p>
<pre><code>class logging(object):
def __init__(self,func):
    self.func = func

# 当函数中有参数的时候  会调用__call__ 方法
def __call__(self, *args, **kwargs):
    reslut  =  self.func(*args,**kwargs)
    print(f&apos;{self.func.__name__}被调用&apos;)
    return reslut</code></pre><p>@logging<br>def add(a,b):<br>    return a+b<br>print(add(1,2))</p>
<hr>
<p> 30.上下文管理器： 上下文管理器是一个包装任意代码块的对象<br>     进入上下文管理器时，每次代码执行的一致性<br>     当退出上下文管理器时，相关的资源会被正确回收 即使内部代码出错，退出步骤也会执行<br>     上下文管理器用的最多的就是  作为确保资源正确清理的一种方式<br>     重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性</p>
<p> with语句： 仅仅能对上下文管理协议的对象使用<br>             with语句的作用是返回一个遵循特定协议的的对象，具体来说就是必须要定义一个<br>             <strong>enter</strong>方法和<strong>exit</strong>方法</p>
<p>with的工作原理：<br>    with open() as f:            with context_expras cm:<br>        # obj.<strong>enter</strong>()                dosomething<br>        f.read()<br>        # obj.<strong>exit</strong>()</p>
<ul>
<li>在进入代码块之前会执行obj.<strong>enter</strong>()语句（自动调用）</li>
<li>在退出代码块之前会执行obj.<strong>exit</strong>()语句（自动调用）</li>
</ul>
<p>编写上下文管理器：   重点：编写上写文管理器的时候 必须要有 <strong>enter</strong> <strong>exit</strong> 属性<br>例子：<br>    class A(object):<br>        def <strong>init</strong>(self):                                  =&gt;第一步<br>        pass<br>        def <strong>enter</strong>(self):                                =&gt;第二步<br>        pass<br>        def <strong>exit</strong>(self, exc_type, exc_val, exc_tb):        =&gt;第四步<br>        pass<br>    with A() as a:<br>        print(‘xxx’)                                        =&gt;第三步</p>
<hr>
<p>31.上下文自动管理模块： contextlib 可以用简单的方法创建上下文管理器(没弄懂)<br>    @cotextlib.contextmanage  这是一个上下文管理的装饰器</p>
<hr>
<h2 id="32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出"><a href="#32-while-Ture-是表示一直循环下去-死循环-当遇到break-的时候就会退出" class="headerlink" title="32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出"></a>32.while Ture   是表示一直循环下去(死循环) 当遇到break 的时候就会退出</h2><p>33.logging日志的记录:</p>
<pre><code>import logging
#配置loging
#level 记录等级比自己高的日志
logging.basicConfig(level=logging.INFO,format=&apos;%(asctime)s-%(name)s-%(message)s&apos;)
#创建日子记录器
logger= logging.getLogger(&apos;cali_game&apos;)
#记日志
logging.debug(&quot;这是一个debug&quot;)
logging.info(&quot;这是一个info&quot;)
logging.warning(&quot;这是一个warning&quot;)
logging.error(&quot;这是一个error&quot;)
logging.critical(&quot;这是一个critical&quot;)
try:
    raise ValueError(&apos;value error&apos;)
except Exception as ex:
    logging.exception(ex)
print(&quot;finished&quot;)</code></pre><p>将日志放入log文件中</p>
<pre><code>import logging
#创建日志记录器
logger = logging.getLogger(__name__)
#为logger做日志配置
logger.setLevel(level=logging.INFO)
#把内容输出到文件中去
filehander = logging.FileHandler(&apos;log.txt&apos;)
filehander.setLevel(level=logging.DEBUG)
formatter = logging.Formatter(&apos;%(asctime)s -%(name)s:[%(levelname)s]:%(message)s&apos;)
filehander.setFormatter(formatter)
#给日志记录器添加存储位置
logger.addHandler(filehander)

logging.debug(&quot;这是一个debug&quot;)
logging.info(&quot;这是一个info&quot;) 
logging.warning(&quot;这是一个warning&quot;)
logging.error(&quot;这是一个error&quot;)
logging.critical(&quot;这是一个critical&quot;)</code></pre><hr>
<p>34.调试方式：asset断言<br>    assert expression ,(arguments)<br>    assert 表达式 参数                 直接报错退出</p>
<p>例子：<br>    score = input(“输入”)<br>    assert score.isdigit(),”输入的有问题”</p>
<hr>
<p>35.pdb 调试器<br>    可以直接使用启动调试器<br>        python -m pdb mypdb_base.py<br>    pdb 指令<br>        下一条语句  n next<br>        打印变量信息： p 变量名<br>        打印脚本信息： l<br>        退出pdb  q<br>        查看帮助  h</p>
<hr>
<p>36.列表中的数 自由排列  排列数列  从4个里面选出3个 排列<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>37.列表中的数自由组合<br>    import itertools<br>    mylist = list(itertools.permutations([1,2,3,4],3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>38.排列组合  生成密码<br>    import itertools<br>    mylist = list(itertools.product([1,2,3,4],repeat=3))<br>    print(mylist)<br>    print(len(mylist))</p>
<hr>
<p>39.正则表达式：<br>    re模块使python有了正则的功能 就是根据一种模式 来提取某些地方的数据</p>
<p>re.match函数：  match(pattern,string,flags = 0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>match.group: 返回匹配的字符串<br>match.start: 返回的是匹配的开始的位置<br>match.end:   返回的是匹配的结束的位置<br>match.groups:返回分组的全部内容 （””,””,,””）</p>
<p>功能：尝试从字符串的起始位置开始匹配的一个模式，如果不是起始位置匹配成功的话，返回None<br>例子：   import re<br>        print(re.match(‘www’,’wwW.baidu.com’,flags=re.I))  re.I :表示忽略大小写</p>
<!-- 结果：    <re.Match object; span=(0, 3), match='wwW'> -->

<p>re.search函数：  search(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串，会现显示前面的那段<br>      如果匹配不成功的话会返回None<br>例子：   import re<br>        print(re.search(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p>
<!-- 结果：<re.Match object; span=(7, 10), match='wwW'> -->

<p>re.findall函数：findall(pattern,string,flags=0)    <!-- (\)记得转义 --><br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个列表，<br>    如果没有则会返回None<br>例子：  import re<br>        print(re.findall(‘www’,’.baidu.wwW.wwWcom’,flags=re.I))</p>
<!-- 结果：    ['wwW', 'wwW'] -->

<!-- ret = re.finditer(r'[a-c\-]at', message) -->  \的重要性  有特殊意义的都是需要转义
<p>re.finditer函数： finditer(pattern,string,flags=0)<br>        pattern:匹配的正则表达式<br>        string:要匹配的字符串<br>        flags:标识位，用于控制正则表达式的匹配方式<br>                 re.I  忽略大小写<br>                 re.L  做本地户识别<br>                 re.M  多行匹配 影响^和$<br>                 re.S  是.匹配包括换行符在内的所欲字符<br>                 re.U  根据Unicode 字符集解析字符 影响\w \W \b \B<br>                 re.X  使我们以更加灵活的格式理解正则表达式<br>                 ?:i   是表示内联的标记<br>功能：在整个字符串中进行匹配的一种模式，如果出现相同的字符串则都会返回，返回的形式是个迭代器<br>    如果没有则会返回None<br>例子：   import re<br>        print(re.finditer(‘(lijian)’,’lijian a good man,lijian a handsome man’))<br>    <!-- 结果：<callable_iterator object at 0x0000024A9EC8ED30> --></p>
<hr>
<p>40.正则表达式：匹配单个字符和数字<br> .  匹配除换行符以外的任意字符<br>        例子：   import re<br>                print(re.search(‘.’,’lijian is a good man’))<br>        <!-- 结果：   <re.Match object; span=(0, 1), match='l'> --></p>
<p> [] 字符集合，表示匹配方括号中所包含的任意一个字符<br>    [a-z]: 匹配任意小写字母</p>
<!--      [A-Z]: 匹配任意大写字母
         [0-9]: 匹配任意数字
         [0-9a-zA-Z] : 匹配任意数字于字母
         [^lijian]:匹配出了lijian这几个字符意外的所有字符  -->
<pre><code> ^: 脱字符 表示不匹配集合中的字符 取反
 \d: 匹配所有的数字 效果同[0-9]
 \D:    匹配所有的非数字 效果同[^\d]
 \w: 匹配所有的数字 字母 下划线
 \W: 匹配非数字 字母 下划线
 \s: 匹配任意的空白符（空格，换行，回车，换页，制表）效果同：[ \f\n\r\t]
 \S: 匹配任非任意的空白符 [^ \f\n\r\t]

 例子：  import re
       print(re.search(&apos;[0-9]&apos;,&apos;lijian is a good man 2&apos;))
&lt;!-- 结果：&lt;re.Match object; span=(21, 22), match=&apos;2&apos;&gt; --</code></pre><hr>
<p>41.正则表达式：匹配锚字符（边界字符）<br>  ^  行首匹配  筛选某个字符串开头的方式   每行的开头<br>                   import re<br>               print(re.search(‘^lijian’,’lijian is a good man 2’))<br>        <!-- 结果：<re.Match object; span=(0, 6), match='lijian'> --><br>  $  行尾匹配  筛选某个字符串结尾的方式    每行的结尾<br>                  import re<br>               print(re.search(‘2&amp;’,’lijian is a good man 2’))<br>         <!-- 结果：<re.Match object; span=(21, 22), match='2'> --><br>  \A  匹配字符串的开始     换行后的第一字符串也不行  就是整个字符串的开头<br>          re.M(换行模式)模式下不会匹配他的行首<br>                  import re<br>                print(re.findall(‘\Alijian’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘lijian’]<br>  \Z   匹配字符串的结束     换行后的最后一个字符串也不行  就是整个字符串的结尾<br>          re.M(换行模式)模式下不会匹配他的行尾<br>                  import re<br>                print(re.findall(‘manb\Z’,’lijian is a good man manb\nlijian shifih  hishfkh manb’,re.M))<br>                结果：[‘manb’]<br>  \b   匹配以什么结尾的单词<br>                  import re<br>                  print(re.search(r’er\B’,’nerve’))  记得raw<br>              <!-- 结果： <re.Match object; span=(1, 3), match='er'> --><br>  \B   匹配中间含有什么的单词<br>                  import re<br>                  print(re.search(r’er\b’,’never’))   记得raw<br>              <!-- 结果：<re.Match object; span=(3, 5), match='er'> --></p>
<hr>
<p>42.正则表达式：匹配多个字符<br>    (x,y,x)   匹配括号里的xyz (把xyz看成一个整体)<br>                import re<br>                print(re.findall(‘(laugh)’,’never not to laugh myself’))<br>            <!-- 结果：<re.Match object; span=(13, 18), match='laugh'> --><br>    x？        匹配0个或者1个x  (就是将匹配的x一个一个显示出来)非贪婪匹配 尽可能少的匹配<br>                import re<br>                print(re.findall(‘x?’,’xxx’))<br>            <!-- 结果：['x', 'x', 'x', ''] --><br>    x*         匹配多个x   (就是将相邻的x合成一个字符串输出) 贪婪匹配 尽可能多的匹配<br>                import re<br>                print(re.findall (‘x*’, ‘xxx’))<br>            <!-- 结果：['xxx', ''] --><br>    x+         匹配至少一个x  (就是在有x的情况下 将相邻的x合成一个字符串输出)<br>                贪婪匹配 尽可能多的匹配</p>
<pre><code>            import re
            print(re.findall(&apos;x+&apos;,&apos;xxxbxxxx&apos;))
        &lt;!-- 结果：[&apos;xxx&apos;, &apos;xxxx&apos;] --&gt;
x{n}        匹配确定含有n个x的字符串（n 是一个非负整数） 贪婪匹配 将相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4}&apos;,&apos;xxxbxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxx&apos;] --&gt;
x{n,}        匹配至少含有n个x的字符串 （n 是一个非负整数）贪婪匹配 将相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4,}&apos;,&apos;xxxbxxxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;
x{n,m}   匹配至少含有n个最多m个x的字符串（n，m是一个非负整数）
            贪婪匹配 将符合要求的相邻的n个x一起打印
            import re
            print(re.findall(&apos;x{4,6}&apos;,&apos;xxxbxxxxxx&apos;))
        &lt;!-- 结果：[&apos;xxxxxx&apos;] --&gt;
x|y      匹配含有x或者y的字符串   
            import re
            print(re.findall(&apos;((x|y)aaa)&apos;,&apos;xaaa-yaaa&apos;))
        &lt;!-- 结果：[(&apos;xaaa&apos;, &apos;x&apos;), (&apos;yaaa&apos;, &apos;y&apos;)] --&gt;</code></pre><hr>
<p>43.正则表达式-特殊匹配<br>    * ？    + ？    x ？<br>    最小匹配，通长是尽可能多的匹配，可以使用这种解决贪婪匹配</p>
<h2 id="x-类似-xyz-但是不表示一个组-？p-分组命名"><a href="#x-类似-xyz-但是不表示一个组-？p-分组命名" class="headerlink" title="   (?:x)  类似(xyz)  但是不表示一个组      ？p  分组命名"></a>   (?:x)  类似(xyz)  但是不表示一个组      ？p<name>  分组命名</h2><p>44.正则表达式-字符串的替换和修改<br> sub(pattern,repl,string,count=0,flags=0) =&gt; 打印的类型  str<br> subn(pattern,repl,sttring,count=0,flags=0) =&gt; 打印的类型 tuple<br> 例子：   sub<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.sub(‘good’,’nice’,str1))<br> <!--  结果：lijian a nice nice man --><br> 例子：   subn<br>     import re<br>    str1 = ‘lijian a good good man’<br>    print(re.subn(‘good’,’nice’,str1))<br> <!--  结果：('lijian a nice nice man', 2) --><br> pattern:正则表达式（规则）<br> repl : 指定的用来替换的字符串<br> string： 目标字符串<br> count：最多替换次数<br>功能：在目标字符串中按照匹配规则进行匹配字符串，然后在将字符串替换成指定的字符串，count可以指定替换的次数</p>
<hr>
<p>45.正则表达式-分组<br>    正则表达式除了简单的判断是否匹配之外，正则表达式还有提取子串的功能<br>    用（）表示的就是提取分组<br>    提取数据：  m.group(0)   最外层<br>               m.group(1)    依次往里取组</p>
<hr>
<p>46.正则表达式-编译   将正则表达式变成一个对象 对用户友好<br>    当我们使用正则表达式的时候 re模块<br>    1.编译正则表达式，如果正则表达式不和法，会报错<br>    2.用编译后的正则表达式去匹配对象<br>    compile(pattern,flags=0)<br>功能：将正则表达式进行封装 到时候去匹配的时候 如果是按照正则表示的规则来的就会输出 否则就会输出None   (最常用)</p>
<p>例子：<br>    import re<br>    re_QQ = re.compile(r’[1-9]\d{5,9}$’)<br>    print(re_QQ.search(‘1234568789’))</p>
<!-- 结果：<re.Match object; span=(0, 10), match='1234568789'> -->
<hr>
<p>47.踩坑记录：<br>    message = “a.jpg, a.gif, a.css, b.gif, b.css”<br>    ret = re.findall(r’[a-zA-Z0-9].(?:jpg|gif)’, message)   =》 ?: 表示不是一个组<br>    print(ret)   </p>
<hr>
<p>49.练习：<br>长度为8-10的用户名（以字母、下划线开头，由字母、数字、下划线组成）<br>    content = “””<br>    a<br>    1aaaaaaaa<br>    <em>a<br>    <em>1<br>    asdfasddf<br>    11<br>    ad_a<br>    asd+s<br>    abcdefghi<br>    1aaaaaa<em>a<br>    1aaaaaaa a<br>    aaa</em>aaa_aa<br>    1234562452<br>    a_______</em></em><br>    <strong><strong><strong>_____</strong></strong></strong><br>    “””<br>    # ^ 表示以什么开头    $ 表示以什么结尾  [字母或者下划线]   \w 字母 数字 下划线   {7,9}长度<br>    ret = re.findall(r”^[a-zA-Z_]\w{7,9}$”,content,re.M)<br>    print(ret)</p>
<p>电子邮箱验证(<!-- xxx1@xxx2.xxx3 -->，xxx1、xxx2由字母数字下划线组成，xxx1长度为6-18)</p>
<!--     mystr = """
    a@163.com
    aaaasdf@16.com
    aaaasdf@16.net
    asd*wwf@sdf.com
    """ -->
<!-- ^ 表示以什么开头  \w字母 数字 下划线   +一个以上  \. 将点转义  (?:com|net)？:是不将括号看为分组 |或
ret = re.findall(r"^\w{6,18}@\w+\.[a-z]+$",mystr,re.M)
ret = re.findall(r"^\w{6,18}@\w+\.(?:com|net)$",mystr,re.M)
print(mystr) -->


<!-- #  URL地址验证(http[s]://www.baidu.com[/?a=111&b=111], -->
<p>mystr = “””</p>
<!-- http://www.baidu.com
http://baidu.com
https://www.baidu.com
https://t.cn
https://www.baidu.com/?a=111&b=111 -->
<!-- """
ret = re.findall(r"^http[s]?://\w+\.\w+\.(?:com|cn)",mystr,re.M)
print(ret) -->


<!-- msg = """
Feng Tel: 18392013983
Feng Tel: 183 9201 3983
Feng Tel: 183-9201-3983
Feng Tel: (+86) 183 9201 3983
Feng Tel: (+86) 18392013983
Feng Tel: (+01)18392013983"""

# (?:\(\+\d{2}\))? 一个整体是否存在(+86)   [ -]?空格和-中的一个  \d{3} 三个数字
ret = re.findall(r"(?:\(\+\d{2}\)[ -]?)?\d{3}[ -]?\d{4}[ -]?\d{4}",msg,re.M)
print(ret) -->

<hr>
<p>50.爬虫爬取网站照片：<br>    ### 总结 =&gt;<br>    ### 需求 =&gt; <a href="https://movie.douban.com/" target="_blank" rel="noopener">https://movie.douban.com/</a> =&gt; 图片保存当前目录的imgs目录下<br>    # 获取网页的内容<br>    import requests<br>    import os</p>
<pre><code>headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&quot;}

response = requests.get(&quot;https://movie.douban.com/&quot;,
                    headers=headers)
# 添加headers的user-agent的目的是告诉douban，我不是一个脚本，我是Firefox浏览器
html = response.text
# 从html页面中获取所有的图片链接
# &lt;img src=&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2581067467.jpg&quot;
all_imgs_link = re.findall(r&apos;src=&quot;(.*?\.(jpg|png|gif|bmp|webp))&quot;&apos;, html)
# 路径 。扩展名
# print(all_imgs_link)
# 将这些图片保存到当前目录的imgs目录下
output_dir = &apos;./imgs&apos;
if not os.path.exists(output_dir):
    os.mkdir(output_dir)

for i,pic_url in enumerate(all_imgs_link):
    # 把图片存在本地 =&gt; 二进制文件 =&gt; content
    #                            =&gt; text =&gt; content转化成str
    img = requests.get(pic_url[0], headers=headers).content
    # filepath = output_dir/i.pic_url[1]
    filepath = f&quot;{output_dir}/{i}.{pic_url[1]}&quot;
    print(filepath)
    with open(filepath, &apos;wb&apos;) as f:
        f.write(img)</code></pre><hr>
<p>51.断言：（存在问题）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/15/python%E7%AC%94%E5%BD%95/" data-id="ck6nd82820000wcv396cp687q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flask-jinja2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/13/flask-jinja2/" class="article-date">
  <time datetime="2020-02-13T14:29:13.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/13/flask-jinja2/">flask_jinja2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>base.html 文件：

 &lt;!DOCTYPE html&gt;
   &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;{% block title %}{% endblock %}</title>
			        <style>
			        .nav{
			            background: #3a3a3a;
			            height: 65px;
			        }
			        ul{
			            overflow: hidden;
			        }
			        ul li{
			            float: left;
			            list-style: none;
			            padding: 0 10px;
			            line-height: 65px;
			        }
			        ul li a{
			            color: white;
			        }
			    </style>
			</head>
			<body>
			    <div class="nav">
			    <ul>
			        <li><a href="#">首页</a></li>
			        <li><a href="#">发布问答</a></li>
			    </ul>
			</div>
			{% block main %}{% endblock %}
        &lt;/body&gt;
        &lt;/html&gt;

    login.html:
        {% extends 'base.html' %}
        {% block title %}
			    登陆页面
			{% endblock %}
        {% block main %}
			    <p>这是登陆页面</p>
			{% endblock %}

    index.html:
        {% extends 'base.html' %}
        {% block title %}
			    首页
			{% endblock %}
        {% block main %}
			    <p>这是首页面</p>
			{% endblock %}

6.URL链接和加载静态文件
    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;
    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径
    * 可以加载css文件，js文件 image文件
    image文件：
    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;

    js文件：
     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;

    css文件：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;

*url链接：使用url_for(视图函数名)，从而反转url 跳转页面
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;

url链接和加载静态文件的例子：
    Py文件：
        from flask import Flask,render_template

        app = Flask(__name__)


        @app.route(&apos;/&apos;)
        def index():
            return render_template(&apos;index.html&apos;)

        @app.route(&apos;/login/&apos;)
        def login():
            return render_template(&apos;login.html&apos;)

        if __name__ == &apos;__main__&apos;:
            app.run(debug=True)

    index.html文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;
            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;
        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    index.js文件：
        /**
         * Created by 栩森 on 2020/2/4.
         */

        alert(&apos;我是李坚&apos;)

    index.css文件：
           a{
                background: red;
            }

    login.html 文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;这是登陆页面&lt;/h1&gt;
        &lt;/body&gt;
        &lt;/html&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/13/flask-jinja2/" data-id="ck6kub5740000bgv3c91zdoff" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-jinja" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/09/Flask-jinja/" class="article-date">
  <time datetime="2020-02-09T07:48:18.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/Flask-jinja/">Flask-jinja</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>1.如何渲染Jinja2模板和传参：(主要是 &apos;render_template&apos;函数)

* 渲染模板：
    * 模板放在 templates 文件夹下面
    * 从 flask 中导入 render_template 函数
    * 在视图函数中，使用 render_template
    #注意：在templates文件夹下面没有其他文件夹的话可以直接render_template(文件名)

* 模板传参数：
    * 如果只有一个或则少量参数的时候，可以直接在render_template函数中添加关键字就好
         #   return render_template(&apos;index.html&apos;,&apos;user&apos; = &apos;username&apos;)
    * 如果有多个参数的时候就需要把参数放入一个字典中，然后在&apos;render_template&apos;中使用**
    把字典中的参数传递
    &apos;&apos;&apos;
            @app.route(&apos;/&apos;)
            def index():
                context = {
                    &apos;username&apos;:&apos;李坚&apos;,
                    &apos;gender&apos;:&apos;男&apos;,
                    &apos;age&apos;: 18
                }
                return render_template(&apos;index.html&apos;,**context)
    &apos;&apos;&apos;
* 在模板中，如果需要使用变量，语法是&apos;{{params}}&apos;
                &lt;p&gt;用户名：&apos;{{ username }}&apos;&lt;/p&gt;
        * 在访问类的属性或则是字典或则是列表的时候，可以通过&apos;{{params.proper}}&apos;的形式，或则是&apos;{{params[]}}&apos;
                   &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;

模板的渲染和传参的实例：

    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18
        }
        return render_template(&apos;index.html&apos;,**context)

    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;


模板的渲染和传参的实例：（含有类的例子）
    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        class Preson(object):
            name = &apos;李坚&apos;
            age = 20
        p = Preson()
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18,
            &apos;person&apos;: p
        }
        return render_template(&apos;index.html&apos;,**context)
    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;

        &lt;hr&gt;
        &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;
        &lt;p&gt;年您：{{ person.age }}&lt;/p&gt;
        &lt;/hr&gt;
    &lt;/body&gt;
    &lt;/html&gt;


2.if判断语句

* 语法格式：（Jinja模板中）
    {% if xxx %}
		{% else %}
		{% endif %}
if判断语句的具体实例（根据id的不同显示不同的页面）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&lt;id&gt;/&apos;)
def index(id):
    if id == &apos;1&apos;:
        user = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;age&apos; : 10
        }
    return render_template(&apos;index2.html&apos;,user=user)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)




&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% if user %}
	        <a href="#">{{ user.username }}</a>
	        <a href="#">注销</a>
	    {% else %}
	        <a href="#">登陆</a>
	        <a href="#">注册</a>
	    {% endif %}
&lt;/body&gt;
&lt;/html&gt;


3.for循环遍历列表和字典：

* 字典的遍历和语法与&apos;python&apos;一样，可以使用&apos;item()&apos; &apos;keys()&apos; &apos;values()&apos;等函数
    {% for k,v in user.item() %}
			<p>{{ k }}:{{ v }}</p>
		{% endfor %}
* 列表的遍历：
    {% for webisit in webisits %}
			<p>{{ webisit }}</p>
		{% endfor %}

for循环的案例：（四大名著的表格排序）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    books=[
        {
            &apos;name&apos;:&apos;西游记&apos;,
            &apos;author&apos;:&apos;吴承恩&apos;,
            &apos;price&apos;:&apos;100&apos;
        },
        {
            &apos;name&apos;:&apos;红楼梦&apos;,
            &apos;author&apos;:&apos;曹雪芹&apos;,
            &apos;price&apos;:&apos;50&apos;
        },
        {
            &apos;name&apos;:&apos;三国演义&apos;,
            &apos;author&apos;:&apos;罗贯中&apos;,
            &apos;price&apos;:&apos;150&apos;
        },
        {
            &quot;name&quot;:&apos;水浒传&apos;,
            &quot;author&quot;:&apos;施耐庵&apos;,
            &quot;price&quot;:200
        }
    ]
    return render_template(&apos;index2.html&apos;,books=books)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;th&gt;书名&lt;/th&gt;
            &lt;th&gt;作者&lt;/th&gt;
            &lt;th&gt;价格&lt;/th&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for book in books %}
	            <tr>
	                <td>{{book.name}}</td>
	                <td>{{book.author}}</td>
	                <td>{{book.price}}</td>
	            </tr>
	        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;


4.过滤器：
    * 介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来（就是设置一个默认的，
然后再用户没有设置的时候就可以直接过滤 输出默认的值）
* 语法： 
    {{ avater(用户输入的值的名字) | default（过滤器）('xxx')}}
* default（过滤器）:如果当前变量不存在的时候，这个时候就可以指定默认值
* length: 求列表或则字符串或则字典 元组的长度

过滤器的例子：（将图片的参数进行传递 ）    
from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    return render_template(&apos;index2.html&apos;,family=&apos;https://avatars2.githubusercontent.com/u/60211293?s=40&amp;v=4&apos;)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板：

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

过滤器的例子：（关于评论的显示 ）
Jinja模板：
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
    &lt;hr&gt;
    &lt;p&gt;评论数:({{comments|length}})&lt;/p&gt;
    &lt;ul&gt;
        {% for comment in comments %}
		        <li>
		            <a href="#">{{comment.user}}</a>
		            <p>{{ comment.content }}</p>
		        </li>
		    {% endfor %}
    &lt;/ul&gt;
    &lt;/body&gt;
    &lt;/html&gt;


python文件：

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    comments = [
        {
            &apos;user&apos;: &apos;李建安&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        },
        {
            &apos;user&apos;: &apos;李坚&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        }
    ]
    return render_template(&apos;index2.html&apos;,comments=comments)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

5.继承和block块
* 作用：可以把一些公共的代码放在父模板中（base.HTML）文件
* 语法：
#    {% extend 'base.html'%}
block 实现：
    * 作用：可以让子模版实现自己的需求，父模板需要提前定义好
    * 注意：子模板中的代码必须放在block块中，不然没有效果
    具体的block语法例子：{% block 模块名 %}{% endblock %}

	继承和block的具体实例：
	py文件：
	from flask import Flask,render_template

	app = Flask(__name__)

	@app.route('/')
	def index():
	    return render_template('index.html')

	@app.route('/login/')
	def login():
	    return render_template('login.html')
	if __name__ == '__main__':
	    app.run(debug= True)


	base.html 文件：

 	<!DOCTYPE html>
 <!--   <html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>{% block title %}{% endblock %}&lt;/title&gt;
            &lt;style&gt;
            .nav{
                background: #3a3a3a;
                height: 65px;
            }
            ul{
                overflow: hidden;
            }
            ul li{
                float: left;
                list-style: none;
                padding: 0 10px;
                line-height: 65px;
            }
            ul li a{
                color: white;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;nav&quot;&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发布问答&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    {% block main %}{% endblock %}
		</body>
		</html> -->

		login.html:
			{% extends 'base.html' %}
			{% block title %}
			    登陆页面
			{% endblock %}
        {% block main %}
			    <p>这是登陆页面</p>
			{% endblock %}

    index.html:
        {% extends 'base.html' %}
        {% block title %}
			    首页
			{% endblock %}
        {% block main %}
			    <p>这是首页面</p>
			{% endblock %}

6.URL链接和加载静态文件
    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;
    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径
    * 可以加载css文件，js文件 image文件
    image文件：
    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;

    js文件：
     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;

    css文件：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;

*url链接：使用url_for(视图函数名)，从而反转url 跳转页面
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;

url链接和加载静态文件的例子：
    Py文件：
        from flask import Flask,render_template

        app = Flask(__name__)


        @app.route(&apos;/&apos;)
        def index():
            return render_template(&apos;index.html&apos;)

        @app.route(&apos;/login/&apos;)
        def login():
            return render_template(&apos;login.html&apos;)

        if __name__ == &apos;__main__&apos;:
            app.run(debug=True)

    index.html文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;
            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;
        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    index.js文件：
        /**
         * Created by 栩森 on 2020/2/4.
         */

        alert(&apos;我是李坚&apos;)

    index.css文件：
           a{
                background: red;
            }

    login.html 文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;这是登陆页面&lt;/h1&gt;
        &lt;/body&gt;
        &lt;/html&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/09/Flask-jinja/" data-id="ck6eq92ul0000s0v345fzgnda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端学习随笔记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-02-09T02:55:00.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.css样式中：<br>    * id选择器： #id<br>    * class选择器： .class<br>    * 普通选择器： <h><br>    * 注意：如果想优先使用一个样式：在样式后面加入 ！important<br>    * 浮动： float left 左浮动  是将两行的东西放到同一行<br>            float right 右浮动  是将两行的东西放到同一行</p>
<hr>
<p>2.盒子模型：<br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>    Border(边框) - 围绕在内边距和内容外的边框。<br>    Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>    Content(内容) - 盒子的内容，显示文本和图像。</p>
<hr>
<p>3.css选择器<br>    * 分组选择器: h1,p1,h2<br>    * 后代选择器：.class p        .class div p<br>    * 相邻选择器 ： div+p<br>    * 普通兄弟选择器： div~p<br>    * 包含title属性对象选择器： [title],[id]<br>    * 伪类选择器： 标签名：自己定义的名字（使有相同的标签名的css精细化）</p>
<hr>
<p>4.javascript：具有动态交互的时，需要使用的语言<br>    * 在函数中定义参数的时候 有var时就是局部变量  没有的是的就是全局变量<br>        function func01(){<br>            var func01 = a<br>    }</p>
<hr>
<p>5.js运算符中 三元运算符的格式   ？xx1:xx2<br>    voteable = (age&lt;18)?’年龄太小’：’年龄达到’  符合要求输出前面 否则输出后面<br>———————————————————————————–6</p>
<p>6.js中弹窗的输出：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    // alert 弹窗 
    alert(&apos;abc&apos;);
    //弹出现在的使时间
    alert(new Date().toLocaleString());
&lt;/script&gt; </code></pre><hr>
<p>7.JS中的其他输出</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;JS的输出&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1 id=&quot;title&quot;&gt;我是标题&lt;/h1&gt;
        &lt;!-- 事件 双击 移动 --&gt;
        &lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            // 弹窗
            window.alert(&apos;提示信息1&apos;);
            // 写入内容到html文档
            // 当使用document.write时 如果页面加载完毕，会覆盖整个内容
            document.write(&apos;我是document_write_01\n&apos;);
            document.write(&apos;我是document_write_01&apos;);
            // 获取页面上ID=title的对象  并用inneHtml 修改对象的数据
            document.getElementById(&apos;title&apos;).innerHTML=&apos;我是HIML标题&apos;;
            console.log(&apos;这是一些console日记&apos;);
            // 定义函数
            function func01(){
                document.write(&apos;我是函数&apos;);
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>————————————————————————————8.JS的函数：<br>    var a=1 =&gt; 这是一个局部变量    a = 1 =&gt; 这是一个全局变量</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button onclick=&quot;sum02(1,2)&quot;&gt;点击计算&lt;/button&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function sum02(arg1,arg2){
                result = sum(arg1,arg2);
                console.log(result)
            }
            function sum(arg1,arg2){
                return arg1+arg2;
            }
            console.log(sum(1,2))
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>9.时间和函数的结合</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;事件与函数相结合&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间1&lt;/button&gt;&lt;br/&gt;
        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间2&lt;/button&gt;&lt;br/&gt;
        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间3&lt;/button&gt;&lt;br/&gt;
        &lt;button onmousedown=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;
        &lt;button onmouseover=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function func01(obj){
            obj.innerHTML = Date()
        }
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>10.js中的json字符串：json 是各个语言之间进行数据交互的桥梁</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;事件与函数相结合&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;时间1&lt;/button&gt;&lt;br/&gt;
        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间2&lt;/button&gt;&lt;br/&gt;
        &lt;button onclick=&quot;func01(this)&quot;&gt;看看时间3&lt;/button&gt;&lt;br/&gt;
        &lt;button onmousedown=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;
        &lt;button onmouseover=&quot;func01(this)&quot;&gt;看看时间4&lt;/button&gt;&lt;br/&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        function func01(obj){
            obj.innerHTML = Date()
        }
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>11.js中获取元素的方式：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
// 获取元素的第一种方式 getElementById  
var demo = document.getElementById(id=&apos;demo&apos;);
console.log(demo);
// 通过本来就有的标签来获取元素
var h1s = document.getElementsByTagName(&apos;h1&apos;)
console.log(h1s)
// 通过class名来获取元素
var sty01s = document.getElementsByClassName(&apos;sty01&apos;)
console.log(sty01s)
// 通过标签名来获取元素
var nov1 = document.getElementsByName(&apos;nov&apos;)
console.log(nov1)
// 通过索引的方式来读取获取元素里面的内容
console.log(nov1[0].innerHTML)
// 获取一个div下的第一元素
console.log(demo.firstElementChild);
// 获取一个div下的第一元素的名字
console.log(demo.firstElementChild.nodeName)
// 获取一个div下的第一元素的文本内容
console.log(demo.firstElementChild.innerHTML)
// 修改div下的第一元素里的内容
demo.firstElementChild.innerHTML = &apos;2020-02-09&apos;
&lt;/script&gt;</code></pre><hr>
<p>12.js中事件及其元素的获取</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 添加事件的一种方式 --&gt;
        &lt;h1 onclick=&quot;changetext(this)&quot;&gt;添加事件方法一 &lt;/h1&gt;        
        &lt;!-- 添加元素的第二种方式 --&gt;
        &lt;h1&gt;添加事件方法二&lt;/h1&gt;
        &lt;button id=&quot;myBtn1&quot;&gt;点我1&lt;/button&gt;
        &lt;p id=&apos;content&apos;&gt;这是要修改的内容&lt;/p&gt;        
        &lt;!-- 添加事件方法3 --&gt;
        &lt;button id=&quot;myBtn3&quot;&gt;点我&lt;/button&gt;
        &lt;p id=&quot;content1&quot;&gt;这是要修改的内容&lt;/p&gt;            
        &lt;script type=&quot;text/javascript&quot;&gt;
            function changetext(obj){
                obj.innerHTML = &apos;这里被点击了&apos;
            }
            function changecontent(){
                document.getElementById(&apos;content&apos;).innerHTML = &apos;添加事件修改类容&apos;
            }
            // 添加事件的方法二
            document.getElementById(&apos;myBtn1&apos;).onclick = changecontent
            // 添加事件方法三
            document.getElementById(&apos;myBtn3&apos;).addEventListener(&apos;click&apos;,function(){
                document.getElementById(&apos;content1&apos;).innerHTML = &apos;这是修改后的内容&apos;
            })
            // document.getElementById(&apos;myBtn3&apos;).removeEventListener(&apos;onclick&apos;,changecontent)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>13.在仿照百度页面的时候注意的问题<br>    事件监听：  onfocus 获取焦点   onblur 失去焦点<br>        * 用户名的input =&gt; onfocus 获取焦点 =&gt; 执行函数<br>        * 用户名的input =&gt; onblur  失去焦点  =&gt; 检查<br>    this =&gt; 在事件监控器中，默认又一个this的变量，表示的监听的对象本身<br>            当输入为空的时候，删除提示的信息</p>
<hr>
<p>14.Jquery<br>    Jquery是Javascript的一个库<br>    资源来源是   下载到本地 或者直接引用网络地址<br>    安装/导入/加载  <!--  <script src=""></script>> --><br>    jquery-1.10.2.min.js   压缩资源 =&gt; 线上环境<br>    jquery-1.10.2.js       非压缩资源 =&gt;开发环境<br>jquery的安装  是直接导入就好      </p>
<!-- <script src="http://libs.baidu.com/jquery/1.10.2/jquery.min.js"> -->
<p>基础的语法：     $(selector).action()<br>                美元符号定义 jQuery<br>                选择符（selector）”查询”和”查找” HTML 元素<br>                jQuery 的 action() 执行对元素的操作<br>选择器：在页面中选取所有 p 元素:    $(“p”)<br>        console.log($(‘p’))<br>        通过id来选择元素          $(‘#idname’)<br>        console.log($(‘#username’))<br>        通过类来选择元素          $(‘.classname’)<br>        console.log($(‘.register’))</p>
<hr>
<p>15.升级pip 就可以直接配置国内源<br>    python -m pip install –upgrade pip<br>    pip config set global.index-url <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<hr>
<p>16.获取服务器的信息的过程<br>    get请求方式</p>
<pre><code>// 获取服务器的信息
   url = &apos;http://127.0.0.1:5000/check_form?username=&apos;
   $.get(url+this.value,function(data){
       console.log(data);    
       if (data == &apos;200&apos;){
           $(&apos;#userinfo&apos;).html(&quot;&lt;img src=&apos;imgs/ok_small.png&apos;&gt;用户名合法&quot;)
       }else{
           $(&apos;#userinfo&apos;).html(&apos;用户名太受欢迎&apos;)
       }
   })                                                            </code></pre><hr>
<p>17.AJAX  与服务器进行数据交换并更新部分网页的艺术，在不重新加载整个页面的情况下<br>    AJAX    =    异步 JavaScript 和 XML</p>
<p>jqury中AJAX数据交换请求  post get   (json模式下的转换)</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input id=&quot;text1&quot; type=&quot;text&quot; /&gt;&lt;br/&gt;

    &lt;button id=&quot;btn1&quot;&gt;点击加载-get&lt;/button&gt;
    &lt;div id=&quot;content1&quot;&gt;信息待加载...&lt;/div&gt;

    &lt;button id=&quot;btn2&quot;&gt;点击加载-post&lt;/button&gt;
    &lt;div id=&quot;content2&quot;&gt;信息待加载...&lt;/div&gt;

    &lt;button id=&quot;btn3&quot;&gt;点击加载-JSON&lt;/button&gt;
    &lt;div id=&quot;content3&quot;&gt;信息待加载...&lt;/div&gt;

    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // Ajax是什么？
        // 有什么用？
        // 为什么要用Ajax?

        // $(选择器).action =&gt; 当文档加载完成之后，执行以下代码
        $(document).ready(function (){
            url = &quot;http://127.0.0.1:5000/check_form&quot;;
            // 发送一个Post请求: $.post(url, data, function)
            // data =&gt; object 字典格式
            username = $(&apos;#text1&apos;).val()
            $(&quot;#btn1&quot;).click(function(){
                $.get(url, {&quot;username&quot;:username},function(data){
                    $(&quot;#content1&quot;).html(data);
                })                    
            })
            $(&quot;#btn2&quot;).click(function(){
                $.post(url, {&quot;username&quot;:username},function(data){
                    $(&quot;#content2&quot;).html(data);
                })                
            })

            // 获取JSON字符串的方法
            $(&quot;#btn3&quot;).click(function(){
                var url = &quot;http://localhost:5000/show_detail&quot;
                username = $(&quot;#username&quot;).val()
                $.getJSON(url,function(data){
                    $(&quot;#content3&quot;).html(JSON.stringify(data));
                })                
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>18.jQuery-ajax-ajax的请求方式：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button id=&quot;btn4&quot; type=&quot;button&quot;&gt;加载数据&lt;/button&gt;
        &lt;div id=&quot;content4&quot;&gt;&lt;/div&gt;

    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        $(&quot;#btn4&quot;).click(function (){
            $.ajax({
                // 请求地址
                url:&quot;http://127.0.0.1:5000/check_form&quot;,
                // type 请求的方式
                type : &apos;GET&apos;,
                // data: 如果有参数到这里设置
                data:{
                    &quot;username&quot;:&quot;a1234567&quot;,
                },
                // dataType：指定数据类型  json text xml html
                dataType:&apos;text&apos;,
                // timeout:超时  毫秒为单位
                timeout:5000,
                // async: 设置是否异步
                async: true,
                // 如果执行成功 执行函数
                data: 是接口返回的数据
                textStatus： 状态码  success error
                xhr:xmlHttpRequest

                success:function(data,textStatus,xhr){
                    console.log(&quot;请求成功&quot;)
                    console.log(data)
                    console.log(textStatus)
                    console.log(xhr)
                    $(&apos;#content4&apos;).html(data)
                },
                // 如果执行失败
                error:function(xhr,textStatus){
                    console.log(&apos;请求失败&apos;)
                    console.log(data)
                    console.log(xhr)
                },
                // 整个ajax执行完成后
                complete:function(){
                    console.log(&quot;ajax执行完成&quot;)
                },
                // 执行开始前
                beforeSend:function(xhr){
                    console.log(&quot;发送请求前&quot;)
                    console.log(xhr)
                }
            })
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><p>19.jQuery-ajax-ajax的请求方式-跨域访问：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;input type=&quot;text&quot; id=&quot;wd&quot; /&gt;
        &lt;button id=&quot;btn4&quot;&gt;sp0-baidu-ajax&lt;/button&gt;
        &lt;div id=&quot;content4&quot;&gt;&lt;/div&gt;

    &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        /*
        同源策略: 当浏览器在访问资源的时候，只能允许访问同源的数据
                 协议、主机（ip/域名）、端口  全部相同，数据是同源的
        跨域共享CORS: 协议、主机（ip/域名）、端口 任意一个不同，都认为是跨域访问
        如何实现跨域共享CORS: 浏览器支持、服务端支持
                 方法1： jsonp =&gt; html页面请求jsonp,服务端处理
                 方法2： 服务端做cors处理

        */
        // 加载 &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;
        // 参数 wd 下一站幸福
        // 将接口返回的数据显示到content4中
        $(&quot;#btn4&quot;).click(function (){
            $.ajax({
                url: &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&quot;,
                // url: &quot;http://cache.video.iqiyi.com/jp/avlist/202861101/1/&quot;,
                data: {&quot;wd&quot;:$(&quot;#wd&quot;).val()},
                dataType: &apos;jsonp&apos;,
                // jsonp 默认值 =&gt;callback
                jsonp: &apos;cb&apos;,
                success: function(data){
                    console.log(data);
                    $(&quot;#content4&quot;).html(JSON.stringify(data))
                }
            })
        })

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>20.跨域访问的解决方法  Cors  jsonp<br>    同源测试： 已拦截跨源请求：同源策略禁止读取位于 <a href="http://localhost:5000/show_detail的" target="_blank" rel="noopener">http://localhost:5000/show_detail的</a><br>    远程资源  因为缺少: CORS头 缺少   ‘Access-Allow-Origin’<br>    允许访问资源  会访问并获取url的结果 但是不会处理这个结果<br>同源策略：  域名 协议 端口都相同</p>
<p>CORS处理的方式：<br>    1.浏览器发送Ajax<br>    2.服务器从处理这个请求，并且在请求上加上Access-Control-Allow-Origin:主机<br>    3.浏览器匹配Orgin字段和Access-Control-Allow-Origin字段是否一致 如果一致就处理<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p>
<p>JOSONP原理：可以通过动态创建script标签 然后利用src属性进行跨区域<br>JSONP 优点： 没有简便  没有兼容性问题<br>JSONP 缺点： 只支持GET请求</p>
<p>总结：<br>1.什么是同源策略？为什么要有同源策略<br>    同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。<br>    当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。<br>    如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p>
<p>2.想跨域访问 有什么办法解决<br>    Cors  jsonp</p>
<p>3.CORS的原理？如何做<br>    CORS处理的方式：<br>    1.浏览器发送Ajax<br>    2.服务器从处理这个请求，并且在请求上加上Access-Control-Allow-Origin:主机<br>    3.浏览器匹配Orgin字段和Access-Control-Allow-Origin字段是否一致 如果一致就处理<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p>
<p>4.JSONP的原理？如何做<br>    JOSONP原理：可以通过动态创建script标签 然后利用src属性进行跨区域</p>
<p>5.CORS和JSONP的区别<br>    JSONP 优点： 没有简便  没有兼容性问题<br>    JSONP 缺点： 只支持GET请求<br>    CORE：支持所有的类型HTTP请求  只需要服务端做处理</p>
<p>6.什么是Ajax<br>    AJAX  与服务器进行数据交换并更新部分网页的艺术，在不重新加载整个页面的情况下<br>    AJAX    =    异步 JavaScript 和 XML<br>7.为什么要用AJAX？<br>    在不重新加载页面的情况下进行数据的交互</p>
<p>8.什么场景下使用Ajax?<br>    例如在触发某个事件的时候 需要提取后台的数据时</p>
<hr>
<p>21.表单提交 submit与butten 的区别<br>    input =&gt; button 和 submit 的区别<br>    button 只是一个普通的按钮<br>    submit 当点击时，会自动用method的方式提交表单到action<br>    提交表单中带有name属性的元素的表单控制的值<br>    get =&gt; 参数直接加到url末尾？name = value$name=value<br>    post =&gt; request-headers</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form&gt;
            &lt;p&gt;&lt;label&gt;用户名&lt;/label&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt;
            &lt;p&gt;&lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt;
            &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/p&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>表单提交的方法： post 与get   submit button</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form id=&quot;form1&quot; method=&quot;post&quot; action=&quot;/login/&quot;&gt;
            &lt;p&gt;&lt;label&gt;用户名&lt;/label&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot;/&gt;&lt;/p&gt;
            &lt;p&gt;&lt;label&gt;密码&lt;/label&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt;&lt;/p&gt;
            &lt;p&gt;&lt;input id=&quot;bt_button&quot; type=&quot;button&quot; value=&quot;button&quot;/&gt; &lt;input id=&quot;bt_submit&quot; type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/p&gt;
        &lt;/form&gt;
        &lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            $(&quot;#bt_submit&quot;).click(function(){
                // 只有返回true 才会提交表单
                // 判断的语句
                return true
                // 判断的语句
                return false
            })

            $(&quot;#bt_button&quot;).click(function(){
                return $(&quot;#form1&quot;).submit()
            })
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><hr>
<p>22.bootstrap ： 基于HTML css Javascript  框架<br> css: 写好了一些样式<br> JS : 写好了一些事件 函数等<br>在使用bootstrap时候 可以直接连接网上资源：<br>    当只要css样式的时候 可以只加载bootstrap.css文件<br>    当要有交互的内容的时候  可以加载bootstrap.js文件 当时之前要加载jq文件</p>
<pre><code>&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;    
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;

&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;
&lt;!-- 注意 bookstrap是基于javaquary 的   我们要先加载jq资源 --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;

&lt;!-- 加载jq --&gt;
&lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;

&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></pre><hr>
<p>23.栅格系统：<br>    * bootstrap 把元素分成12等分<br>    * 响应式： 可以根据屏幕的大小，展示不同的大小内容<br>例子：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;
        &lt;style&gt;
            [class*=&quot;col-&quot;] {
                /*padding-top: 15px;*/
                /*padding-bottom: 15px;*/
                /*background-color: #eee;*/
                background-color: rgba(86, 61, 124, .15);
                /*border: 1px solid #ddd;*/
                border: 1px solid rgba(86, 61, 124, .2);
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 创建一个容器 --&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;h1&gt;你好，世界&lt;/h1&gt;
            &lt;h2&gt;1.栅格系统&lt;/h2&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-xs-4&quot;&gt;md4&lt;/div&gt;
                &lt;div class=&quot;col-xs-6&quot;&gt;md6&lt;/div&gt;
                &lt;div class=&quot;col-xs-2&quot;&gt;md2&lt;/div&gt;
            &lt;/div&gt;
            &lt;!-- 响应式 --&gt;
            &lt;h3&gt;2.响应式例子：&lt;/h3&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-4 col-xs-6&quot;&gt;md4&lt;/div&gt;
                &lt;div class=&quot;col-md-6 col-xs-6&quot;&gt;md6&lt;/div&gt;
                &lt;div class=&quot;col-md-2 col-xs-6&quot;&gt;md2&lt;/div&gt;
                &lt;div class=&quot;col-md-2 col-xs-6&quot;&gt;md2&lt;/div&gt;
            &lt;/div&gt; 
            &lt;!-- 小练习 --&gt;
            &lt;h3&gt;3.小练习&lt;/h3&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;1&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;2&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;3&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;4&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;5&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;6&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;7&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;8&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;9&lt;/div&gt;
                &lt;div class=&quot;col-xs-12 col-sm-6 col-md-4&quot;&gt;10&lt;/div&gt;        
            &lt;/div&gt;
            &lt;h3&gt;4.列偏移&lt;/h3&gt;
            &lt;div class=&quot;raw&quot;&gt;
                &lt;div class=&quot;col-md-4&quot;&gt;1&lt;/div&gt;
                &lt;div class=&quot;col-md-4 col-md-offset-2&quot;&gt;2&lt;/div&gt;
            &lt;/div&gt;
            &lt;h3&gt;5.列嵌套&lt;/h3&gt;
            &lt;!-- 将被嵌套的对象看成一个目标 进行切分 --&gt;
            &lt;div class=&quot;raw&quot;&gt;
                &lt;div class=&quot;col-xs-5&quot;&gt;1&lt;/div&gt;
                &lt;div class=&quot;col-xs-7&quot;&gt;
                    &lt;div class=&quot;col-xs-6&quot;&gt;2&lt;/div&gt;
                    &lt;div class=&quot;col-xs-6&quot;&gt;3&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>栅格系统还有一些格式 可以参考<a href="https://v3.bootcss.com/css/#type" target="_blank" rel="noopener">https://v3.bootcss.com/css/#type</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" data-id="ck6ehi3zs0000okv32y4ocldu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Migrate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/08/Flask-Migrate/" class="article-date">
  <time datetime="2020-02-08T12:03:10.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Flask-Migrate的作用：（代码在models_Migrate文件中）<br>    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，<br>    如果需要修改就必须要先删除表格。<br>    Flask-migrate就是为了解决不能在表格中添加或者修改内容的作用，可以解决在修改模型后<br>    直接映射到表中。</p>
<p>2.下载安装Flask-Migrate ： pip install flask-migrate</p>
<p>3.flask-migrate必须要借助 flask-script ，这个包中MigrateCommand 中的关于数据库的命令</p>
<p>4.flask-migrate 相关的命令：<br>    * python manage.py db init : 初始化迁移脚本的环境 只需要执行一次<br>    * python manage.py db migrate 生成迁移文件，每次修改都要执行<br>    * pythin manage.py db upgrade 将迁移的文件映射到数据中 每次需改都需要运行一次</p>
<p>5.要将数据库中的模型 madols.py 导入到manage文件中，这样才会找到相关的模块</p>
<p>6.各个文件的代码：<br>    config.py （同之前的一样）</p>
<pre><code>models_Migrate.py文件 ：

    from flask import Flask
    # 引入exts中的db
    from exts import db
    import config
    from models import Aritcle

    app = Flask(__name__)
    app.config.from_object(config)
    #防止循环引用 初始化app
    db.init_app(app)

    &apos;&apos;&apos;
    #手动将app推到服务器的栈里面（重点）
    with app.app_context():
        #这里通过db 将 models文件放入其中了（重点）
        db.create_all()
    &apos;&apos;&apos;

    @app.route(&apos;/&apos;)
    def hello_world():
        return &apos;Hello World!&apos;


    if __name__ == &apos;__main__&apos;:
        app.run(debug=True)

manage.py文件（重点）

    from flask_script import Manager
    from models_Migrate import app
    from flask_migrate import Migrate,MigrateCommand
    from exts import db
    from models import Aritcle

    manage = Manager(app)
    #1.要使用flasj_migrate 必须绑定app和db
    migrate = Migrate(app,db)

    #2. 把MigrateCommand 命令添加到 manager中
    manage.add_command(&apos;db&apos;,MigrateCommand)

    if __name__ == &apos;__main__&apos;:
        manage.run()

exts.py文件：（是为了防止循环应用app）
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()

models.py 文件：
    #引入exts 中的 db
    from exts import db
    class Aritcle(db.Model):
        id = db.Column(db.Integer,primary_key=True,autoincrement=True)
        title = db.Column(db.String(100),nullable=False)
        content = db.Column(db.Text,nullable=False)
        tags = db.Column(db.String(100),nullable=False)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/08/Flask-Migrate/" data-id="ck6dlbr88000018v36z2w2nw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/07/Flask-Script/" class="article-date">
  <time datetime="2020-02-07T11:50:40.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/07/Flask-Script/">Flask-Script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flask-Script的用处：<br>    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的<br>    服务器，设置数据库，定时任务等<br>Flask-Script的安装 ：     pip install flask-script  操作命令进行安装    </p>
<p>flask-Script :在创建好flask项目后 要在创建一个主文件manage.py<br>        manage.py的文件内容：</p>
<pre><code>#导入script的 Manager文件
from flask_script import Manager
#导入flask_scripr_demo文件中 app
from flask_script_demo import app

#初始化manage
manage = Manager(app)

#在命令行中可以执行的命令 装饰器
@manage.command
def runserver():
    print(&quot;服务器启动&quot;)

#因为是作为主app文件  则需要一下代码
if __name__== &apos;__main__&apos;:
    manage.run()</code></pre><p>在cmd运行命令的方法（必须在项目的目录下）<br>        python manage.py runserver<br>            显示：服务器启动</p>
<p>flask_script中有一集中控制数据库命令的文件db_script</p>
<pre><code>manage.py 中的内容：
    #导入script的 Manager文件
    from flask_script import Manager
    #导入flask_scripr_demo文件中 app
    from flask_script_demo import app
    #导入文件db_script 文件中的DBmanager对象
    from db_script import DBmanager

    #初始化manage
    manage = Manager(app)

    #在命令行中可以执行的命令 装饰器
    @manage.command
    def runserver():
        print(&quot;服务器启动&quot;)

    #将db_script.py中的命令放到主app中来
    manage.add_command(&apos;db&apos;,DBmanager)

    #因为是作为主app文件  则需要一下代码
    if __name__== &apos;__main__&apos;:
        manage.run()

db_script中的内容：
    #导入flask_script文件 中的manager
    from flask_script import Manager

    #初始化
    DBmanager = Manager()

    #设置命令
    @DBmanager.command
    def init():
        print(&quot;初始化服务器&quot;)

    @DBmanager.command
    def migrate():
        print(&quot;迁移成功&quot;)</code></pre><p>在cmd中运行的语句： python manage.py db init<br>                     显示结果：初始化服务器成功</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/07/Flask-Script/" data-id="ck6c8iu690000lcv3599ocweg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" rel="tag">前端框架</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Li-jian/" style="font-size: 10px;">Li jian</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" style="font-size: 10px;">代码在models_Migrate文件中</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">前端框架</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/05/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">Linux基本命令</a>
          </li>
        
          <li>
            <a href="/2020/03/05/linux%E9%AB%98%E7%BA%A7/">linux高级</a>
          </li>
        
          <li>
            <a href="/2020/03/04/linux%E5%9F%BA%E7%A1%80/">linux基础</a>
          </li>
        
          <li>
            <a href="/2020/02/27/Vue-js/">Vue.js</a>
          </li>
        
          <li>
            <a href="/2020/02/15/python%E7%AC%94%E5%BD%95/">python笔录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 li jian<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Curry-jian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Curry-jian">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Curry-jian">
<meta property="article:author" content="li jian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Curry-jian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Curry-jian</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-前端学习随笔记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-02-09T02:55:00.000Z" itemprop="datePublished">2020-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.css样式中：<br>    * id选择器： #id<br>    * class选择器： .class<br>    * 普通选择器： <h><br>    * 注意：如果想优先使用一个样式：在样式后面加入 ！important<br>    * 浮动： float left 左浮动  是将两行的东西放到同一行<br>            float right 右浮动  是将两行的东西放到同一行</p>
<hr>
<p>2.盒子模型：<br>    Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>    Border(边框) - 围绕在内边距和内容外的边框。<br>    Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>    Content(内容) - 盒子的内容，显示文本和图像。</p>
<hr>
<p>3.css选择器<br>    * 分组选择器: h1,p1,h2<br>    * 后代选择器：.class p        .class div p<br>    * 相邻选择器 ： div+p<br>    * 普通兄弟选择器： div~p<br>    * 包含title属性对象选择器： [title],[id]<br>    * 伪类选择器： 标签名：自己定义的名字（使有相同的标签名的css精细化）</p>
<hr>
<p>4.javascript：具有动态交互的时，需要使用的语言<br>    * 在函数中定义参数的时候 有var时就是局部变量  没有的是的就是全局变量<br>        function func01(){<br>            var func01 = a<br>    }</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/" data-id="ck6ehi3zs0000okv32y4ocldu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Migrate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/08/Flask-Migrate/" class="article-date">
  <time datetime="2020-02-08T12:03:10.000Z" itemprop="datePublished">2020-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.Flask-Migrate的作用：（代码在models_Migrate文件中）<br>    因为在主文件中采用了’db.create_all’之后，以后在class类中不能再对表格进行修改，<br>    如果需要修改就必须要先删除表格。<br>    Flask-migrate就是为了解决不能在表格中添加或者修改内容的作用，可以解决在修改模型后<br>    直接映射到表中。</p>
<p>2.下载安装Flask-Migrate ： pip install flask-migrate</p>
<p>3.flask-migrate必须要借助 flask-script ，这个包中MigrateCommand 中的关于数据库的命令</p>
<p>4.flask-migrate 相关的命令：<br>    * python manage.py db init : 初始化迁移脚本的环境 只需要执行一次<br>    * python manage.py db migrate 生成迁移文件，每次修改都要执行<br>    * pythin manage.py db upgrade 将迁移的文件映射到数据中 每次需改都需要运行一次</p>
<p>5.要将数据库中的模型 madols.py 导入到manage文件中，这样才会找到相关的模块</p>
<p>6.各个文件的代码：<br>    config.py （同之前的一样）</p>
<pre><code>models_Migrate.py文件 ：

    from flask import Flask
    # 引入exts中的db
    from exts import db
    import config
    from models import Aritcle

    app = Flask(__name__)
    app.config.from_object(config)
    #防止循环引用 初始化app
    db.init_app(app)

    &apos;&apos;&apos;
    #手动将app推到服务器的栈里面（重点）
    with app.app_context():
        #这里通过db 将 models文件放入其中了（重点）
        db.create_all()
    &apos;&apos;&apos;

    @app.route(&apos;/&apos;)
    def hello_world():
        return &apos;Hello World!&apos;


    if __name__ == &apos;__main__&apos;:
        app.run(debug=True)

manage.py文件（重点）

    from flask_script import Manager
    from models_Migrate import app
    from flask_migrate import Migrate,MigrateCommand
    from exts import db
    from models import Aritcle

    manage = Manager(app)
    #1.要使用flasj_migrate 必须绑定app和db
    migrate = Migrate(app,db)

    #2. 把MigrateCommand 命令添加到 manager中
    manage.add_command(&apos;db&apos;,MigrateCommand)

    if __name__ == &apos;__main__&apos;:
        manage.run()

exts.py文件：（是为了防止循环应用app）
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()

models.py 文件：
    #引入exts 中的 db
    from exts import db
    class Aritcle(db.Model):
        id = db.Column(db.Integer,primary_key=True,autoincrement=True)
        title = db.Column(db.String(100),nullable=False)
        content = db.Column(db.Text,nullable=False)
        tags = db.Column(db.String(100),nullable=False)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/08/Flask-Migrate/" data-id="ck6dlbr88000018v36z2w2nw3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-Script" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/07/Flask-Script/" class="article-date">
  <time datetime="2020-02-07T11:50:40.000Z" itemprop="datePublished">2020-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/07/Flask-Script/">Flask-Script</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flask-Script的用处：<br>    Flask-Script的作用是可以通过命令行的形式来操作Flask.例如通过命令跑一个开发版本的<br>    服务器，设置数据库，定时任务等<br>Flask-Script的安装 ：     pip install flask-script  操作命令进行安装    </p>
<p>flask-Script :在创建好flask项目后 要在创建一个主文件manage.py<br>        manage.py的文件内容：</p>
<pre><code>#导入script的 Manager文件
from flask_script import Manager
#导入flask_scripr_demo文件中 app
from flask_script_demo import app

#初始化manage
manage = Manager(app)

#在命令行中可以执行的命令 装饰器
@manage.command
def runserver():
    print(&quot;服务器启动&quot;)

#因为是作为主app文件  则需要一下代码
if __name__== &apos;__main__&apos;:
    manage.run()</code></pre><p>在cmd运行命令的方法（必须在项目的目录下）<br>        python manage.py runserver<br>            显示：服务器启动</p>
<p>flask_script中有一集中控制数据库命令的文件db_script</p>
<pre><code>manage.py 中的内容：
    #导入script的 Manager文件
    from flask_script import Manager
    #导入flask_scripr_demo文件中 app
    from flask_script_demo import app
    #导入文件db_script 文件中的DBmanager对象
    from db_script import DBmanager

    #初始化manage
    manage = Manager(app)

    #在命令行中可以执行的命令 装饰器
    @manage.command
    def runserver():
        print(&quot;服务器启动&quot;)

    #将db_script.py中的命令放到主app中来
    manage.add_command(&apos;db&apos;,DBmanager)

    #因为是作为主app文件  则需要一下代码
    if __name__== &apos;__main__&apos;:
        manage.run()

db_script中的内容：
    #导入flask_script文件 中的manager
    from flask_script import Manager

    #初始化
    DBmanager = Manager()

    #设置命令
    @DBmanager.command
    def init():
        print(&quot;初始化服务器&quot;)

    @DBmanager.command
    def migrate():
        print(&quot;迁移成功&quot;)</code></pre><p>在cmd中运行的语句： python manage.py db init<br>                     显示结果：初始化服务器成功</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/07/Flask-Script/" data-id="ck6c8iu690000lcv3599ocweg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python做题时发现的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-02-06T02:40:56.000Z" itemprop="datePublished">2020-02-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Python做题时发现的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>1.枚举函数的使用：enumerate()<br>    枚举函数的作用：枚举函数可以在一个列表中遍历，遍历出来的内容是index(下标)和item(这个下标表示的数)<br>    具体用用法实例:</p>
<pre><code>类型一：
    tmplist = [1234, 5677, 8899]
    for index,app_id in enumerate(tmplist):
        print index, app_id

    输出： 
    0 1234 
    1 5677 
    2 8899

类型二：（从下标1开始取值）
    tmplist = [1234, 5677, 8899]
    for index,app_id in enumerate(tmplist, 1):
        print index, app_id

    输出： 
    1 1234 
    2 5677 
    3 8899

类型三：使用range()或xrange()
         tmplist = [1234, 5677, 8899]
            for i in range(len(tmplist)):
                  print i,tmplist[i]

        输出： 
        0 1234 
        1 5677 
        2 8899</code></pre><hr>
<p>2.关于def add(x, y) -&gt; int:中符号-&gt;的意思：<br>-&gt;常常出现在python函数定义的函数名后面，为函数添加元数据,描述函数的返回类型，从而方便开发人员使用<br>    简而言之就是这个函数返回的类型会是 int 类型，如果不是可以强制性进行转换为int类型</p>
<ul>
<li>-&gt;  _Attr则表明函数返回的是一个外部可访问的类的私有变量</li>
</ul>
<hr>
<p>3.进制转化器：<br>    bin:二进制   cot:八进制   int:十进制  hex:十六进制</p>
<hr>
<p>4.Decimal类型数据是精确的小数，可以传递给Decimal整型或者字符串参数   decimal(小数)<br>     * 从浮点数据转换为Decimal类型<br>        #导入模块<br>        from decimal import getcontext,Decimal,Context<br>        mydec = Decimal.from_float(12.222)<br>        print(mydec)<br>        #结果为  12.222153432115212315……..精准的数字<br>    *  从字符串转化为Decimal类型<br>        mydec = Decimal(‘3.14’)<br>        print(mydec)<br>    * raw  将转义字符原样输出  r”hello\tworld”</p>
<hr>
<p>5.字符串（列表）里面的切片操作和下标取值操作（重点：包含开始 不包含结束）（切片没有下标越界）<br>    * 语法：[start:stop:step]  start:开始字符  stop:结束字符  step:步长  （其值可以省略）<br>    * step &gt; 0，从左往右切片       step &lt;0，从右往左切片<br>    * 左[0,1,2,3,……]   右[…….,-4-3,-2,-1]<br>    *  my_str=”mystr”<br>       print(my_str.count(‘m’))  查看字符串里面右几个m  也可以指定字符串的长度进行查看<br>       print(my_str.count(‘m’，1，3))     </p>
<hr>
<p> 6.判断字符是否为纯数字组成  str.isdigit()<br>   判断字符串是否为大写    str.isupper()<br>   判断字符串是否只包含字母： str.isalpha()<br>   判断字符串里的单词是否开头大写其他地方小写： str.istitle()<br>   判断字符串是否只只包含字母或者数字： str.isalnum()</p>
<p>   将字符串转换为大写： str.upper()<br>   将字符串转换为小写： str.lower()<br>   将字符中的单词第一字母大写其他字母小写 ：str.title()<br>   指定sep作为分割符号 将字符串切割成列表，分隔符可以任意设置（默认为空格）：<br>                           str.spilt(‘sep’)<br>       将列表用str拼接成一个大的字符串： ‘str’.join(list)(用str来拼接字符串)<br>       去除字符串中首尾的字符串，不带参数默认去除空格： str.strip([string])<br>       将字符串里的一个字符进行替代： str.replace(‘old’’new’[替换的个数])<br>       将字符中间对齐: str.center(witdth,’填充符号’)<br>       将字符左对齐:str.ljust(witdth,’填充符号’)<br>       将字符右对齐:str.rjust(witdth,’填充符号’)</p>
<pre><code>end 是可以表示最后字符串末尾的方式    end=&apos;&apos; 表示用空字符来连接字符</code></pre><hr>
<p>7.字符串格式化：<br>    {变量：[填充字符][对齐方式&lt;^&gt;][宽度][格式]}.format()</p>
<hr>
<p>8.math 模块 : import math<br>              math.方法<br>  getpass 模块： import getpass   隐藏密码的模块<br>                  getpass.getpass(“输入密码”)<br>  random模块： 随机生成一个范围内的数字<br>                  random.randint(0,100)  随机取0~100中的一个数字</p>
<hr>
<p>9.分支语句（if的三元运算）<br>    reslut = 条件成立的结果 if 条件 else 条件不成立的结果</p>
<hr>
<p>10.while语句：<br>    是符合该条件的情况下才会执行(注意 是需要一个结束的语句) 下面相关的内容<br>    while 条件：<br>        do sth<br>        break<br>    continue: 是指跳到循环的开头<br>    break: 表示退出循环</p>
<hr>
<p>11.for循环语句：<br>    for item in rang(3):<br>        do sth<br>    表循环几次  指定循环的次数</p>
<hr>
<ol start="12">
<li>自增长问题：<br>a+=i : a = a+1<br>a-=1 : a = a-1<br>自有在for循环语句中遍历出数字来 才能实现自增长的作用</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ck6a8svyf0000u8v3h9b4554g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-SQLAlchemy-DateBase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/04/Flask-SQLAlchemy-DateBase/" class="article-date">
  <time datetime="2020-02-04T07:21:13.000Z" itemprop="datePublished">2020-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/04/Flask-SQLAlchemy-DateBase/">Flask-SQLAlchemy-DateBase</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.MySQL-python中间件的介绍和安装<br>     * 在mac上可以直接输入  ‘sudo pip install mysql-python’进行安装<br>     * 在window下需要到’<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysql-python3&#39;</a><br>      这个网址下载对应的python版本的中间件<br>          对应的命令： pip install mysqlclient-1.4.6-cp38-cp38-win_amd64.whl<br>     * 注意：如果与python的版本不符合就会出现报错的现象</p>
<p>2.ORM与Flask-SQLALchemy的安装和介绍<br>    * ORM: Objct Relationship Mapping (模型关系映射)<br>    * flask-aqlalchemy是一套ORM框架<br>    * ORM的好处：可以不适用sql语句进行对数据的修改 ，可以直接使用类的语句就好.一个表<br>        就是一个类，一条数据就是一个对象<br>    * 安装Flask-SQLALchemy： pip install flask-sqlalchemy</p>
<pre><code>例子： class Ariticle(Moble):
        id = int()
        title = String()
        content = Text()
       #实例化
           article = Article(id = 1,title = &apos;aaa&apos;,content = &apos;bbb&apos;)
       #加入表格或者说类中
            add(article)
       #修改数据内容
             article.title = &apos;ccc&apos;
             update(article)
       #删除内容
             delete(article)</code></pre><p>3.SQLALchemy连接数据库<br>    SQLALchemy :SQLAlchemy采用简单的Python语言，为高效和高性能的数据库访问设计<br>                是访问和操作数据库的开源脚本<br>    * 在实际操作过程中遇到的问题：<br>        * 在Mysql workbeath 中修改连接密码：右键出现Edit connections 进行点击 进入后点击store in Vault 就可以进行修改<br>        * 如何进入Mysql 命令行的形式：找到Mysql sever 下的bin目录 再就如命令行输入<br>            ./mysql -u root -p<br>        * 创建一个新的数据库 命令     creat datebase  数据库名  charset  utf8<br>    使用flask_sqlalchemy中的SQLALchemy进行初始化：</p>
<pre><code>    #调用函数
    from flask_sqlalchemy import SQLAlchemy
    app = Flask(__name__)
    #初始化一个对象
    db = SQLAlchemy(app)

设置配置文件&apos;config.py&apos;文件中添加一下配置
#dialect+driver://username:password@host:post/database


    DIALECT = &apos;mysql&apos;
    DRIVER = &quot;mysqldb&quot;
    USERNAME = &apos;root&apos;
    PASSWORD = &apos;root&apos;
    HOST = &apos;127.0.0.1&apos;
    PORT = &apos;3306&apos;
    DATABASE = &apos;db_demo1&apos;
    SQLALCHEMY_DATABASE_URI = &quot;{}+{}://{}:{}@{}:{}/{}?charset=utf8&quot;.format(DIALECT,
                                                   DRIVER,USERNAME,
                                                   PASSWORD,HOST,PORT,
                                                   DATABASE)
    #去除警告信息
    SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>   在app文件中，添加配置文件，并且进行测试</p>
<pre><code>from flask import Flask
   #调用函数
from flask_sqlalchemy import SQLAlchemy
#引入config文件
import config
app = Flask(__name__)
#重点（不明白）
app.config.from_object(config)
#初始化一个对象
db = SQLAlchemy(app)
#进行测试
db.create_all()</code></pre><p>4.SQLALchemy模型与表映射<br>    * 创建的这个表可以称作为一个类，这个类必须要继承自’db.Model’，然后映射到表中的时候<br>       必须写成’db.Column’的数据类型<br>    * 数据类型：<br>        * ‘db.Integer’代表的是整型（int）<br>        * ‘db.String’ 代表的是’varcher’,需要指定最长的长度<br>        * ‘db.Text’代表的是 ‘text’<br>    * 参数类型：<br>        * ‘primary_key’:代表的是将字段是否设置为主键<br>        * ‘autoincrement’: 代表的是这个主键是否为自增长的<br>        * ‘nullable’ : 表示该字段是否可以为空，数据库默认是能为空<br>    * 最后需要用’db.create_all’来将模型真正的创建到数据库中</p>
<p>   在实践过程中遇到的问题：</p>
<ul>
<li><p>对数据库的连接不熟练，以及配置文件的编写</p>
<pre><code>from flask import Flask</code></pre><p>   from flask_sqlalchemy import SQLAlchemy<br>   import config<br>   app = Flask(<strong>name</strong>)<br>   app.config.from_object(config)<br>   #初始化对象<br>   db = SQLAlchemy(app)</p>
<p>配置文件的编写：</p>
<h1 id="dialect-driver-username-password-host-post-database"><a href="#dialect-driver-username-password-host-post-database" class="headerlink" title="dialect+driver://username:password@host:post/database"></a>dialect+driver://username:password@host:post/database</h1><p>   DIALECT = ‘mysql’<br>   DRIVER = ‘mysqldb’<br>   USERNAME = ‘root’<br>   PASSWORD = ‘root’<br>   HOST = ‘127.0.0.1’<br>   POST = ‘3306’<br>   DATABASE = ‘db_mode2’<br>   SQLALCHEMY_DATABASE_URI = ‘{}+{}://{}:{}@{}:{}/{}?charset=utf8’.format(DIALECT,</p>
<pre><code>DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)</code></pre><p>   SQLALCHEMY_TRACK_MODIFICATIONS = False</p>
</li>
<li><p>在数据库中需要使用的语句：</p>
<pre><code>创建数据库： create database 数据库名 charset utf8
查看数据库中的表 ： show tables 
查看表的内容： desc 表名
使用那个数据库： use 数据库名
展现创建的表格： show create table 表名
删除表格： drop table 表名</code></pre><ul>
<li><p>将SQL语句转化为py文件中类的语句<br>  ‘’’<br>SQL语句中创建表格<br>   create table article(</p>
<pre><code>id int primary key autoincrement,
title varchar(100) not null,
content text not null,</code></pre><p>   )<br>‘’’</p>
<p>class Article(db.Model):<br>   <strong>tablename</strong> =’article’<br>   id = db.Column(db.Integer,primary_key=True,autoincrement=True)<br>   title = db.Column(db.String(100),nullable=False)<br>   content = db.Column(db.Text,nullable=False)</p>
</li>
</ul>
</li>
</ul>
<p>创建一个表的例子：</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config
app = Flask(__name__)
app.config.from_object(config)
#初始化对象
db = SQLAlchemy(app)
&apos;&apos;&apos;
SQL语句中创建表格
    create table article(
        id int primary key autoincrement,
        title varchar(100) not null,
        content text not null,
    )
&apos;&apos;&apos;
class Article(db.Model):
    __tablename__ =&apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    content = db.Column(db.Text,nullable=False)
db.create_all()
@app.route(&apos;/&apos;)
def hello_world():
    return &apos;Hello World!&apos;
if __name__ == &apos;__main__&apos;:
    app.run()</code></pre><p>config 配置文件</p>
<pre><code># dialect+driver://username:password@host:post/database
DIALECT = &apos;mysql&apos;
DRIVER = &apos;mysqldb&apos;
USERNAME = &apos;root&apos;
PASSWORD = &apos;root&apos;
HOST = &apos;127.0.0.1&apos;
POST = &apos;3306&apos;
DATABASE = &apos;db_mode2&apos;
SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset=utf8&apos;.format(DIALECT,
                               DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)
SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><p>5.SQLALchemy 数据库的增删查改</p>
<pre><code>#数据库增加数据
    article = Article(title = &apos;aaa&apos;,content = &apos;bbb&apos;)
    db.session.add(article)
    #事务相应（操作的开关）
    db.session.commit()

#数据库查找数据
    #SQL： select * from article where article.title=&apos;aaa&apos;;
    #query:查找   fileter：过滤
    article1 = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    #返回的是一个列表 之后的操作可以根据列表的操作进行
    print(&apos;title:%s&apos; % article1.title)
    print(&apos;content:%s&apos; % article1.content)

#数据的修改
    #1.先要查找出修改的数据
    article1 = Article.query.filter(Article.title==&apos;aaa&apos;)[0,1]
    #2.在需要修改的地方进行修改
    article1.title = &apos;new title&apos;
    #3.提交事务
    db.session.commit()

#删除数据
    #1.把需要删除的数据查找出来
    article1 = Article.query.filter(Article.content == &apos;bbb&apos;)[0]
     #2.删除数据
    db.session.delete(article1)
    #3.事务处理
    db.session.commit()</code></pre><p>6.Flask-SQLALchemy 外键及其关系<br>    * 连接数据库（跟以上的操作一样）<br>    * 创建两个表（user article）</p>
<pre><code> #创建用户表(user)
 &apos;&apos;&apos;
 SQL语句：
         create table users(
         id int primary key autoincrement,
         username varchar(100) not null
 )
 &apos;&apos;&apos;
 class User(db.Model):
     __tablename__ = &apos;user&apos;
     id = db.Column(db.Integer,primary_key= True,autoincrement=True)
     username = db.Column(db.String(100),nullable=True)

  #创建文章表
     &apos;&apos;&apos;
     SQL语句：
             create table article(
                 id int primary key autoincrement,
                 title varchar(100) not null,
                 content text not null,
                 author_id int,
                 foreign key &apos;author_id&apos; references &apos;user_id&apos;
     )        
     &apos;&apos;&apos;
     class Article(db.Model):
         __tablename__ =&apos;article&apos;
         id = db.Column(db.Integer,primary_key=True,autoincrement=True)
         title = db.Column(db.String(100),nullable=False)
         content = db.Column(db.Text,nullable=False)
         #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
         author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))

    * 映射到数据库中：   db.create_all()
        注意： db.create_all() 它只会部署一次，如果中途在类里面去需改表的属性是没有任何用处的，只有把表格进行删除，再
        重新创建一个表格才能添加其他的属性

* 在用户表中添加用户
     user1 = User(username = &apos;lijian&apos;)
     db.session.add(user1)
     db.session.commit()</code></pre><ul>
<li><p>在文章表中添加文章</p>
<pre><code>article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)
db.session.add(article)
db.session.commit()</code></pre><ul>
<li><p>实现需求：查找文章名称为aaa的作者</p>
<pre><code>这是需求的普通写法:没有起到简化的作用 再Flask中不会使用
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author_id)
    author_id = article.author_id
    user = User.query.filter(User.id == author_id)[0]
    print(user.username)

再Flask-SQLALchemy-Darabases中使用的方法:
    * 先要在class类中就行设置;

            class Article(db.Model):
            __tablename__ =&apos;article&apos;
            id = db.Column(db.Integer,primary_key=True,autoincrement=True)
            title = db.Column(db.String(100),nullable=False)
            content = db.Column(db.Text,nullable=False)
            #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
            author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))
    #重点：db.relationship是表述关系的连接参数  db.backre是表示关系反转的参数
    #正向引用（relationship）与反向引用（backref）（User表与article表）        #正向关系：是只通过article表里面的外键来与User表中的主键进行连接             然后读取相关信息            
    #通过文章名称找出作者名称
    #反转关系：是只通过User中的主键来连接article中的外键，然后读取article中的相关信息             
    #通过作者找出他写作的文章
    #模块名=db.relationship(&apos;关联的类名&apos;，backref = db.backref(&apos;自定义参数&apos;))
            author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))
    * 实现通过文章名称查找作者：

            article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
            #通过 article.author.usename 来找出文章的作者
            print(article.author.username)</code></pre><ul>
<li><p>实现需求：通过作者名找出其作品</p>
<pre><code>user = User.query.filter(User.username == &apos;lijian&apos;)[0]
#通过 user.articles.title 来查找作者的文章
result = user.articles
for article in result:
    print(article.title)</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实例：数据库的连接 表的制作 数据的的添加 实现通过作者找出他的所有文章 通过文章找出作者</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config

app = Flask(__name__)
app.config.from_object(config)
db = SQLAlchemy(app)
#创建用户表
&apos;&apos;&apos;
SQL语句：
        create table users(
        id int primary key autoincrement,
        username varchar(100) not null
)
&apos;&apos;&apos;
class User(db.Model):
    __tablename__ = &apos;user&apos;
    id = db.Column(db.Integer,primary_key= True,autoincrement=True)
    username = db.Column(db.String(100),nullable=True)
#创建文章表
&apos;&apos;&apos;
SQL语句：
        create table article(
            id int primary key autoincrement,
            title varchar(100) not null,
            content text not null,
            author_id int,
            foreign key &apos;author_id&apos; references &apos;user_id&apos;
)        
&apos;&apos;&apos;
class Article(db.Model):
    __tablename__ =&apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    content = db.Column(db.Text,nullable=False)
    #引用的代码：db.ForeignKey(&apos;表名.属性值&apos;)
    author_id = db.Column(db.Integer,db.ForeignKey(&apos;user.id&apos;))
    #正向引用（relationship）与反向引用（backref）
    author = db.relationship(&apos;User&apos;,backref = db.backref(&apos;articles&apos;))
 #实现映射到表中
db.create_all()
##########
@app.route(&apos;/&apos;)
def hello_world():
    &apos;&apos;&apos;
    #在用户表中添加用户
    user1 = User(username = &apos;lijian&apos;)
    db.session.add(user1)
    db.session.commit()
    &apos;&apos;&apos;

    #添加作品信息
    &apos;&apos;&apos;
    article = Article(title=&apos;aaa&apos;,content=&apos;bbb&apos;,author_id=1)
    db.session.add(article)
    db.session.commit()
    &apos;&apos;&apos;
    #需求：寻找标题文章为aaa的作者
    &apos;&apos;&apos;
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author_id)
    author_id = article.author_id
    user = User.query.filter(User.id == author_id)[0]
    print(user.username)
    &apos;&apos;&apos;
    #上述需求的简化:
    #根据文章名称查找作者
    article = Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    print(article.author.username)
    print(&quot;*&quot;*20)

    #需求 找到lijian写过的所有的文章
    user = User.query.filter(User.username == &apos;lijian&apos;)[0]
    result = user.articles
    for article in result:
        print(article.title)
    &apos;&apos;&apos;
    #先添加一篇文章
    article = Article(title=&apos;111&apos;,content=&apos;222&apos;,author_id=1 )
    db.session.add(article)
    db.session.commit()
    &apos;&apos;&apos;
    return &apos;Hello World!&apos;
if __name__ == &apos;__main__&apos;:
    app.run(debug=True)</code></pre><p> 数据库连接的config 文件：</p>
<pre><code> #dialect+driver://username:password@host:post/database
DIALECT = &apos;mysql&apos;
DRIVER = &apos;mysqldb&apos;
USERNAME = &apos;root&apos;
PASSWORD = &apos;root&apos;
HOST = &apos;127.0.0.1&apos;
POST = &apos;3306&apos;
DATABASE = &apos;db_demo3&apos;
SQLALCHEMY_DATABASE_URI = &apos;{}+{}://{}:{}@{}:{}/{}?charset utf8&apos;.format(DIALECT,
                            DRIVER,USERNAME,PASSWORD,HOST,POST,DATABASE)
SQLALCHEMY_TRACK_MODIFICATIONS = False</code></pre><hr>
<p>7.SQLALchemy连接数据库中多对多关系<br>    * 配置相关的config 文件 与之前一样</p>
<pre><code>* 设置关联的语句（重点）（在class Aritcle 中进行设置）（secondary 设置中间表的连接）
    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))

* 需要建立三个表格 article  tag  article_tag
                                            article与tag 表格的建立与之前的一样.
  article_tag 表格的建立：（db.Table 进行建立）
      #关联表
    article_tag = db.Table(&apos;article_tag&apos;,
    db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),
    db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)
                   )

    * 数据的插入：（ article1.article.append(tag1) 这个语句是重点）
    article1 = Article(title = &apos;aaa&apos;)
    article2 = Article(title = &apos;bbb&apos;)
    tag1 = Tag(name = &apos;111&apos;)
    tag2 = Tag(name = &apos;222&apos;)
    #article1下有哪些标签  一个article1有多个标签（重点）
    article1.article.append(tag1)
    article1.article.append(tag2)
    # article2下有哪些标签  一个article2有多个标签（重点）
    article2.article.append(tag1)
    article2.article.append(tag2)
    db.session.add(article1)
    db.session.add(article2)
    db.session.add(tag1)
    db.session.add(tag2)
    db.session.commit()</code></pre><p>案例：连接数据库 创建表格包含中间表 插入数据 关联数据 实现通过文章找Tag(免去config文件)</p>
<pre><code>from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import config

app = Flask(__name__)
app.config.from_object(config)
db= SQLAlchemy(app)

&quot;&quot;&quot;
SQL语句：
    创建article表
    create table article(
        id int primary key autoincrement
        title varachar(100) not null
    )
    创建tag表
    create table tag(
        id int primary key autioncrement
        name varachar(50) not null
    )
    创建中间表
    create table article_tag(
        article_id int
        tag_id int
        primay key (&apos;article_id&apos;,&apos;tag_id&apos;)
        foreign_key &apos;article_id&apos; references &apos;article&apos;
        foreign_key &apos;tag_id&apos; references &apos;tag&apos;
    )

&quot;&quot;&quot;
#关联表
article_tag = db.Table(&apos;article_tag&apos;,
        db.Column(&apos;article_id&apos;,db.Integer,db.ForeignKey(&apos;article.id&apos;),primary_key=True,),
        db.Column(&apos;tag_id&apos;,db.Integer,db.ForeignKey(&apos;tag.id&apos;),primary_key=True,)
                       )

class Article(db.Model):
    __tablename__ = &apos;article&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    title = db.Column(db.String(100),nullable=False)
    #这是外键的是指 以及表的关联过程  secondary
    article = db.relationship(&apos;Tag&apos;,secondary=article_tag ,backref = db.backref(&apos;articles&apos;))

class Tag(db.Model):
    __tablename__ = &apos;tag&apos;
    id = db.Column(db.Integer,primary_key=True,autoincrement=True)
    name = db.Column(db.String(50),nullable=False)

db.create_all()

@app.route(&apos;/&apos;)
def hello_world():
    &apos;&apos;&apos;
    article1 = Article(title = &apos;aaa&apos;)
    article2 = Article(title = &apos;bbb&apos;)
    tag1 = Tag(name = &apos;111&apos;)
    tag2 = Tag(name = &apos;222&apos;)
    #article1下有哪些标签  一个article1有多个标签
    article1.article.append(tag1)
    article1.article.append(tag2)
    # article2下有哪些标签  一个article2有多个标签
    article2.article.append(tag1)
    article2.article.append(tag2)
    db.session.add(article1)
    db.session.add(article2)
    db.session.add(tag1)
    db.session.add(tag2)
    db.session.commit()
    &apos;&apos;&apos;
    article1= Article.query.filter(Article.title == &apos;aaa&apos;)[0]
    tags = article1.article
    for tag in tags:
        print(tag.name)

    return &apos;Hello World!&apos;

if __name__ == &apos;__main__&apos;:
    app.run(debug=True)</code></pre><hr>
<p>8.在分开models中解决循环引用<br>     分开models 的目的： 是为了更好的管理代码<br>     解决循环引用的方法：  是将add文件 分割开来  可以同时被几个文件引用 不会产生循环</p>
<pre><code>models.sep文件：（主文件）
    from flask import Flask
    # 引入models中的 Ariticle
    from models import Ariticle
    # 引入exts中的db
    from exts import db

    app = Flask(__name__)
    #防止循环引用 初始化app
    db.init_app(app)

    db.create_all()

    @app.route(&apos;/&apos;)
    def hello_world():
        return &apos;Hello World!&apos;

    if __name__ == &apos;__main__&apos;:
        app.run()

exts文件：
    from flask_sqlalchemy import SQLAlchemy
    db = SQLAlchemy()

models.py 文件：
    #引入exts 中的 db
    from exts import db
    class Ariticle(db.Model):
        __table__ = &apos;article&apos;
        id = db.Column(db.Integer, primary_key=True, autoincrement=True)
        title = db.Column(db.String(100), nullable=False)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/04/Flask-SQLAlchemy-DateBase/" data-id="ck67xvsxx0000a8v3e3e4ga4b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask-jinja模板" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/03/Flask-jinja%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2020-02-03T12:23:41.000Z" itemprop="datePublished">2020-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/03/Flask-jinja%E6%A8%A1%E6%9D%BF/">Flask--Jinja模板</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>1.如何渲染Jinja2模板和传参：(主要是 &apos;render_template&apos;函数)

* 渲染模板：
    * 模板放在 templates 文件夹下面
    * 从 flask 中导入 render_template 函数
    * 在视图函数中，使用 render_template
    #注意：在templates文件夹下面没有其他文件夹的话可以直接render_template(文件名)

* 模板传参数：
    * 如果只有一个或则少量参数的时候，可以直接在render_template函数中添加关键字就好
         #   return render_template(&apos;index.html&apos;,&apos;user&apos; = &apos;username&apos;)
    * 如果有多个参数的时候就需要把参数放入一个字典中，然后在&apos;render_template&apos;中使用**
    把字典中的参数传递
    &apos;&apos;&apos;
            @app.route(&apos;/&apos;)
            def index():
                context = {
                    &apos;username&apos;:&apos;李坚&apos;,
                    &apos;gender&apos;:&apos;男&apos;,
                    &apos;age&apos;: 18
                }
                return render_template(&apos;index.html&apos;,**context)
    &apos;&apos;&apos;
* 在模板中，如果需要使用变量，语法是&apos;{{params}}&apos;
                &lt;p&gt;用户名：&apos;{{ username }}&apos;&lt;/p&gt;
        * 在访问类的属性或则是字典或则是列表的时候，可以通过&apos;{{params.proper}}&apos;的形式，或则是&apos;{{params[]}}&apos;
                   &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;

模板的渲染和传参的实例：

    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18
        }
        return render_template(&apos;index.html&apos;,**context)

    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;
    &lt;/body&gt;
    &lt;/html&gt;


模板的渲染和传参的实例：（含有类的例子）
    from flask import Flask,render_template
    app = Flask(__name__)
    @app.route(&apos;/&apos;)
    def index():
        class Preson(object):
            name = &apos;李坚&apos;
            age = 20
        p = Preson()
        context = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;gender&apos;:&apos;男&apos;,
            &apos;age&apos;: 18,
            &apos;person&apos;: p
        }
        return render_template(&apos;index.html&apos;,**context)
    if __name__ == &apos;__main__&apos;:
        app.run(debug= True)


Jinja模板：

        &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        这是HTML文件中的文字
        &lt;p&gt;用户名：{{ username }}&lt;/p&gt;
        &lt;p&gt;用户名：{{ age}} &lt;/p&gt;
        &lt;p&gt;用户名：{{ gender }}&lt;/p&gt;

        &lt;hr&gt;
        &lt;p&gt;名字：{{ person.name }}&lt;/p&gt;
        &lt;p&gt;年您：{{ person.age }}&lt;/p&gt;
        &lt;/hr&gt;
    &lt;/body&gt;
    &lt;/html&gt;


2.if判断语句

* 语法格式：（Jinja模板中）
    {% if xxx %}
		{% else %}
		{% endif %}
if判断语句的具体实例（根据id的不同显示不同的页面）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&lt;id&gt;/&apos;)
def index(id):
    if id == &apos;1&apos;:
        user = {
            &apos;username&apos;:&apos;李坚&apos;,
            &apos;age&apos; : 10
        }
    return render_template(&apos;index2.html&apos;,user=user)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)




&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {% if user %}
	        <a href="#">{{ user.username }}</a>
	        <a href="#">注销</a>
	    {% else %}
	        <a href="#">登陆</a>
	        <a href="#">注册</a>
	    {% endif %}
&lt;/body&gt;
&lt;/html&gt;


3.for循环遍历列表和字典：

* 字典的遍历和语法与&apos;python&apos;一样，可以使用&apos;item()&apos; &apos;keys()&apos; &apos;values()&apos;等函数
    {% for k,v in user.item() %}
			<p>{{ k }}:{{ v }}</p>
		{% endfor %}
* 列表的遍历：
    {% for webisit in webisits %}
			<p>{{ webisit }}</p>
		{% endfor %}

for循环的案例：（四大名著的表格排序）

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    books=[
        {
            &apos;name&apos;:&apos;西游记&apos;,
            &apos;author&apos;:&apos;吴承恩&apos;,
            &apos;price&apos;:&apos;100&apos;
        },
        {
            &apos;name&apos;:&apos;红楼梦&apos;,
            &apos;author&apos;:&apos;曹雪芹&apos;,
            &apos;price&apos;:&apos;50&apos;
        },
        {
            &apos;name&apos;:&apos;三国演义&apos;,
            &apos;author&apos;:&apos;罗贯中&apos;,
            &apos;price&apos;:&apos;150&apos;
        },
        {
            &quot;name&quot;:&apos;水浒传&apos;,
            &quot;author&quot;:&apos;施耐庵&apos;,
            &quot;price&quot;:200
        }
    ]
    return render_template(&apos;index2.html&apos;,books=books)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;th&gt;书名&lt;/th&gt;
            &lt;th&gt;作者&lt;/th&gt;
            &lt;th&gt;价格&lt;/th&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for book in books %}
	            <tr>
	                <td>{{book.name}}</td>
	                <td>{{book.author}}</td>
	                <td>{{book.price}}</td>
	            </tr>
	        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;


4.过滤器：
    * 介绍：过滤器可以处理变量，把原始的变量经过处理后再展示出来（就是设置一个默认的，
然后再用户没有设置的时候就可以直接过滤 输出默认的值）
* 语法： 
    {{ avater(用户输入的值的名字) | default（过滤器）('xxx')}}
* default（过滤器）:如果当前变量不存在的时候，这个时候就可以指定默认值
* length: 求列表或则字符串或则字典 元组的长度

过滤器的例子：（将图片的参数进行传递 ）    
from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    return render_template(&apos;index2.html&apos;,family=&apos;https://avatars2.githubusercontent.com/u/60211293?s=40&amp;v=4&apos;)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

Jinja模板：

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;

过滤器的例子：（关于评论的显示 ）
Jinja模板：
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;img src=&quot;{{ family|default('https://avatars0.githubusercontent.com/u/472721?v=4')}}&quot; alt=&quot;&quot;&gt;
    &lt;hr&gt;
    &lt;p&gt;评论数:({{comments|length}})&lt;/p&gt;
    &lt;ul&gt;
        {% for comment in comments %}
		        <li>
		            <a href="#">{{comment.user}}</a>
		            <p>{{ comment.content }}</p>
		        </li>
		    {% endfor %}
    &lt;/ul&gt;
    &lt;/body&gt;
    &lt;/html&gt;


python文件：

from flask import Flask,render_template
app = Flask(__name__)
@app.route(&apos;/&apos;)
def index():
    comments = [
        {
            &apos;user&apos;: &apos;李建安&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        },
        {
            &apos;user&apos;: &apos;李坚&apos;,
            &apos;content&apos;:&apos;xxx&apos;
        }
    ]
    return render_template(&apos;index2.html&apos;,comments=comments)
if __name__ == &apos;__main__&apos;:
    app.run(debug= True)

5.继承和block块
* 作用：可以把一些公共的代码放在父模板中（base.HTML）文件
* 语法：
#    {% extend 'base.html'%}
block 实现：
    * 作用：可以让子模版实现自己的需求，父模板需要提前定义好
    * 注意：子模板中的代码必须放在block块中，不然没有效果
    具体的block语法例子：{% block 模块名 %}{% endblock %}

	继承和block的具体实例：
	py文件：
	from flask import Flask,render_template

	app = Flask(__name__)

	@app.route('/')
	def index():
	    return render_template('index.html')

	@app.route('/login/')
	def login():
	    return render_template('login.html')
	if __name__ == '__main__':
	    app.run(debug= True)

 base.html 文件：
	 	<!DOCTYPE html>
			<html lang="en">
			<head>
			    <meta charset="UTF-8">
			    <title>{% block title %}{% endblock %}&lt;/title&gt;
                &lt;style&gt;
                .nav{
                    background: #3a3a3a;
                    height: 65px;
                }
                ul{
                    overflow: hidden;
                }
                ul li{
                    float: left;
                    list-style: none;
                    padding: 0 10px;
                    line-height: 65px;
                }
                ul li a{
                    color: white;
                }
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div class=&quot;nav&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;发布问答&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        {% block main %}{% endblock %}
			</body>
			</html>

		login.html:
			{% extends 'base.html' %}
			{% block title %}
			    登陆页面
			{% endblock %}
        {% block main %}
			    <p>这是登陆页面</p>
			{% endblock %}

    index.html:
        {% extends 'base.html' %}
        {% block title %}
			    首页
			{% endblock %}
        {% block main %}
			    <p>这是首页面</p>
			{% endblock %}

6.URL链接和加载静态文件
    * 加载静态文件语法：&apos;url_for(&apos;static&apos;，filename=&apos;路径&apos;)&apos;
    * 静态文件 flask会在static文件夹中开始寻找，所有不需要再写static这个路径
    * 可以加载css文件，js文件 image文件
    image文件：
    &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;

    js文件：
     &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;

    css文件：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;

*url链接：使用url_for(视图函数名)，从而反转url 跳转页面
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;

url链接和加载静态文件的例子：
    Py文件：
        from flask import Flask,render_template

        app = Flask(__name__)


        @app.route(&apos;/&apos;)
        def index():
            return render_template(&apos;index.html&apos;)

        @app.route(&apos;/login/&apos;)
        def login():
            return render_template(&apos;login.html&apos;)

        if __name__ == &apos;__main__&apos;:
            app.run(debug=True)

    index.html文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
            &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='css/index.css') }}&quot;&gt;
            &lt;script src=&quot;{{ url_for('static',filename='js/index.js') }}&quot;&gt;&lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;a href=&quot;{{ url_for('login') }}&quot;&gt;登陆&lt;/a&gt;
        &lt;img src=&quot;{{ url_for('static',filename='images/lijian.jpg') }}&quot; alt=&quot;&quot;&gt;
        &lt;/body&gt;
        &lt;/html&gt;


    index.js文件：
        /**
         * Created by 栩森 on 2020/2/4.
         */

        alert(&apos;我是李坚&apos;)

    index.css文件：
           a{
                background: red;
            }

    login.html 文件：
        &lt;!DOCTYPE html&gt;
        &lt;html lang=&quot;en&quot;&gt;
        &lt;head&gt;
            &lt;meta charset=&quot;UTF-8&quot;&gt;
            &lt;title&gt;Title&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;这是登陆页面&lt;/h1&gt;
        &lt;/body&gt;
        &lt;/html&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/03/Flask-jinja%E6%A8%A1%E6%9D%BF/" data-id="ck66hb7gp000098v3g9gdfasa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Flask--urls和视图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/" class="article-date">
  <time datetime="2020-02-02T09:32:35.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/">Flask--urls和视图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>1.对代码的解析：
#encoding UTF-8
#模块的导入
from flask import Flask
#初始化一个Flask对象
#Flask()
#需要传递一个参数__name__
#1. 方便flask框架去寻找资源
#2. 方便flask插件 比如Flask-Sqlalchemy出现错误的时候，去寻找问题所在的位置
app = Flask(__name__)

# @app.route是一个装饰器
# @开头，并且在函数的上面，说明是一个装饰器
# 这个装饰器的作用，是做一个URL与视图函数的映射
# 127.0.0.1:5000/  去请求hello_woeld 这个函数  然后将结果返回到浏览器
@app.route(&apos;/&apos;)
def hello_world():
    return &apos;我是第一个程序&apos;

# 如果当前这个文件是作为入口程序进行运行， 那么就执行app.run()
if __name__ == &apos;__main__&apos;:
    #app.run()
    #启动一个应用服务器  来接受用户的请求
    #while True
    #   listen()
    #设置debug模式  将错误直接显示到网页上面
    app.run(debug= True)

2.设置debug模式
    a.在app.run()中传入一个关键字参数debug,例如：run(debug = Ture)，就设置当前项目为debug模式。

    b.debug模式的两大功能：
        * 当程序出现问题的时候，可以在页面中看到错误的信息和出错的位置
        * 只要修改项目中的python文件，程序就会自动的加载，不需要手动的重新启动服务器。
      具体的案例如下：
          from flask import Flask

        app = Flask(__name__)

        @app.route(&apos;/&apos;)
        def hello_world():
            return &apos;我是第一个程序&apos;

        if __name__ == &apos;__main__&apos;:
            #设置debug模式  将错误直接显示到网页上面
            app.run(debug= True)

3.使用配置文件
    * 新建一个&apos;config.py&apos;文件
    * 在主要的app文件中导入这个文件，并且配置到app文件中
        &apos;&apos;&apos;
        import config
        app.config.from_object(config)
        &apos;&apos;&apos;
    * 还有许多的其他参数也可以放置在文件中，比如&apos;SECRET_KEY&apos; 和 &apos;SQLALCHEMY&apos;这些配置文件

    主app文件实例如下：（其实主要的作用还是和debug模式一样的作用）
        from flask import Flask
        #导入config文件
        import config

        app = Flask(__name__)
        #加入config文件的配置
        app.config.from_object(config)

        @app.route(&apos;/&apos;)
        def hello_world():
            return &apos;我是第一个程序&apos;

        if __name__ == &apos;__main__&apos;:

            app.run()

    config文件的配置：（可以加入很多的参数 注意的是需要将文件导入和对文件配置的导入使用）
        DEBUG = True


4.url传递参数
    * 参数的作用： 可以在相同的URL，当时不指定相同的参数，来加载不同的数据。
                例如：http://127.0.0.1:5000/URL/参数        
    * 在flask中如何使用参数：
        &apos;&apos;&apos;
            @app.route(&apos;/article/&lt;id&gt;&apos;)
            def article(id):
                return &apos;您请求的参数是 ： %S&apos; % id
        &apos;&apos;&apos;
           注意：参数必须放在&lt;&gt;中    
                视图函数中需要放在和URL中的id相同的参数（就是函数括号里面的参数必须与id相同）

    url传递参数的例子：
            from flask import Flask
            app = Flask(__name__)
            #视图函数
            @app.route(&apos;/login/&lt;id&gt;&apos;)
            def login(id):
                return &quot;您请求的参数是 % S&quot; % id

            if __name__ == &apos;__main__&apos;:
                app.run(debug=True)


5.URL反转（需要一个模板：url_for）
    * 什么叫做反转URL： 从视图函数到url的转换叫做反转URL
      （根据视图的函数名字 可以直接切换到URL的参数）
    * 反转URL的用处：
        * 在页面重定向的时候，会使用url反转
        * 在模板中，也会使用url反转

    Url反转例子：
            from flask import Flask,url_for

            app = Flask(__name__)

            @app.route(&apos;/&apos;)
            def index():
                print(url_for(&apos;my_list&apos;))
                print(url_for(&apos;question&apos;),id = &quot;aaaa&quot;)
                return &apos;这是首页&apos;

            @app.route(&apos;/list/&apos;)
            def my_list():
                return &quot;这是登陆页面&quot;

            @app.route(&apos;/question/&lt;id&gt;&apos;)
            def question(id):
                return &apos;这是发布问答的页面:%S&apos; % id

            if __name__ == &apos;__main__&apos;:
                app.run(debug= True)

6.重定向和页面跳转：(需要两个模板： redirect  url_for)
    * 用处： 在用户访问一些需要登陆的页面的时候，如果用户没有登陆用户则会跳转到用户的登陆界面
    * 代码的实现：
        &apos;&apos;&apos;
            from flask import redirect,url_for
            redirect(url_for(&apos;login&apos;))
        &apos;&apos;&apos;

    重定向和页面跳转的代码演示：
        from flask import Flask,redirect,url_for

        app = Flask(__name__)

            @app.route(&apos;/&apos;)
            def index():
                   question_url = url_for(&apos;question&apos;,id = 1)
                   return redirect(question_url)
                   return &apos;这是首页&apos;

            @app.route(&apos;/login/&apos;)
            def login():
                return &quot;这是登陆页面&quot;

            @app.route(&apos;/question/&lt;id&gt;&apos;)
            # 关键点   条件性代码
            def question(id):
                if id==&quot;1&quot;:
                    return &apos;这是发布问答的页面&apos;
                else:
                    return redirect(url_for(&quot;login&quot;))
            if __name__ == &apos;__main__&apos;:
                app.run(debug=True)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/02/Flask--urls%E5%92%8C%E8%A7%86%E5%9B%BE/" data-id="ck66f1y110000iov30i1r1qp6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="cost-hexo的基本操作" class="article article-type-cost" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-01-24T05:11:04.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">hexo的基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.创建一个新的文件：<br>                hexo new post 文件名<br>                hexo new [layout(布局)] -p 路径 文件名</p>
<p>2.上传到网页并且进行部署（同时出现在GitHub上面）:<br>                hexo d -g</p>
<p>3.注意：在文档中有渲染的语法，或则有重定向的语法就会报错<br>        Template render error<br>        则需要进行注释或者标注</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/24/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="ck5rrkdl300009ov3a2yyhyw7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Li-jian/" rel="tag">Li jian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" rel="tag">代码在models_Migrate文件中</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Li-jian/" style="font-size: 10px;">Li jian</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E5%9C%A8models-Migrate%E6%96%87%E4%BB%B6%E4%B8%AD/" style="font-size: 10px;">代码在models_Migrate文件中</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/">前端学习随笔记录</a>
          </li>
        
          <li>
            <a href="/2020/02/08/Flask-Migrate/">Flask-Migrate</a>
          </li>
        
          <li>
            <a href="/2020/02/07/Flask-Script/">Flask-Script</a>
          </li>
        
          <li>
            <a href="/2020/02/06/Python%E5%81%9A%E9%A2%98%E6%97%B6%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">Python做题时发现的问题</a>
          </li>
        
          <li>
            <a href="/2020/02/04/Flask-SQLAlchemy-DateBase/">Flask-SQLAlchemy-DateBase</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 li jian<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>